{"ast":null,"code":"function _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport Configuration from '../config/Configuration';\nimport size from '../../utils/collection/size';\nimport keyupIsHiddenByCmd from '../../helpers/resolving-handlers/keyupIsHiddenByCmd';\n/**\r\n * Object containing all information necessary to match a handler to a history of\r\n * key combinations\r\n * @typedef {Object} MatchingActionConfig\r\n * @property {NormalizedKeySequenceId} prefix - String describing the sequence of key\r\n *          combinations, before the final key combination (an empty string for\r\n *          sequences that are a single key combination)\r\n * @property {number} sequenceLength - Number of combinations involved in the\r\n *           sequence\r\n * @property {KeyCombinationString} id - Serialized description of the key combinations\r\n *            that make up the sequence\r\n * @property {Object.<KeyName, Boolean>} keyDictionary - Dictionary of key names involved\r\n *           in the last key combination of the sequence\r\n * @property {KeyEventType} keyEventType - Record index for key event that\r\n *          the matcher should match on\r\n * @property {number} size - Number of keys involved in the final key combination\r\n * @property {EventMatchDictionary} events - Dictionary of EventMatches\r\n */\n\n/**\r\n * A dictionary mapping key event types to event matches\r\n * @typedef {Object.<KeyEventType, EventMatch>} EventMatchDictionary\r\n */\n\n/**\r\n * Object containing information to call a handler if an event type matches a\r\n * key event\r\n * @typedef {Object} EventMatch\r\n * @property {ActionName} actionName - Name of the action\r\n * @property {Function} handler - Handler to call if event type matches\r\n */\n\n/**\r\n * Matches a KeyCombination to a list of pre-registered ActionConfiguration and their\r\n * corresponding handler functions\r\n * @class\r\n */\n\nvar KeyCombinationMatcher = /*#__PURE__*/function () {\n  /**\r\n   * Returns a new instance of KeyCombinationMatcher\r\n   * @returns {KeyCombinationMatcher}\r\n   */\n  function KeyCombinationMatcher() {\n    _classCallCheck(this, KeyCombinationMatcher);\n\n    this._actionConfigs = {};\n    this._order = null;\n  }\n  /**\r\n   * Adds a new ActionConfiguration and handler to those that can be used to match a\r\n   * KeyCombination\r\n   * @param {ActionConfiguration} actionConfig\r\n   * @param {Function} handler Function to call if match is selected\r\n   * @returns {void}\r\n   */\n\n\n  _createClass(KeyCombinationMatcher, [{\n    key: \"addMatch\",\n    value: function addMatch(actionConfig, handler) {\n      if (this._includesMatcherForCombination(actionConfig.id)) {\n        var keyEventType = actionConfig.keyEventType,\n            actionName = actionConfig.actionName,\n            id = actionConfig.id;\n\n        this._addHandlerToActionConfig(id, {\n          keyEventType: keyEventType,\n          actionName: actionName,\n          handler: handler\n        });\n      } else {\n        this._addNewActionConfig(actionConfig, handler);\n      }\n    }\n    /**\r\n     * Finds a MatchingActionConfig for a KeyCombination, ReactKeyName and\r\n     * KeyEventType\r\n     * @param {KeyCombination} keyCombination Record of key combinations\r\n     *         to use in the match\r\n     * @param {ReactKeyName} keyName Name of the key to use in the match\r\n     * @param {KeyEventType} keyEventType The type of key event to use in the match\r\n     * @returns {MatchingActionConfig|null} A MatchingActionOptions that matches the\r\n     *          KeyCombination, ReactKeyName and KeyEventType\r\n     */\n\n  }, {\n    key: \"findMatch\",\n    value: function findMatch(keyCombination, keyName, keyEventType) {\n      if (!this._order) {\n        this._setOrder();\n      }\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this._order[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var combinationId = _step.value;\n          var actionOptions = this._actionConfigs[combinationId];\n\n          if (this._matchesActionConfig(keyCombination, keyName, keyEventType, actionOptions)) {\n            return actionOptions;\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return null;\n    }\n    /********************************************************************************\r\n     * Presentation\r\n     ********************************************************************************/\n\n    /**\r\n     * A plain JavaScript representation of the KeyCombinationMatcher, useful for\r\n     * serialization or debugging\r\n     * @returns {Object} Serialized representation of the key combination matcher\r\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        actionConfigs: this._actionConfigs,\n        order: this._order\n      };\n    }\n    /********************************************************************************\r\n     * Private methods\r\n     ********************************************************************************/\n\n  }, {\n    key: \"_matchesActionConfig\",\n    value: function _matchesActionConfig(keyCombination, keyName, keyEventType, actionOptions) {\n      if (!canBeMatched(keyCombination, actionOptions)) {\n        return false;\n      }\n\n      var combinationHasHandlerForEventType = actionOptions.events[keyEventType];\n\n      if (!combinationHasHandlerForEventType) {\n        /**\r\n         * If the combination does not have any actions bound to the key event we are\r\n         * currently processing, we skip checking if it matches the current keys being\r\n         * pressed.\r\n         */\n        return false;\n      }\n\n      var keyCompletesCombination = false;\n      var combinationMatchesKeysPressed = Object.keys(actionOptions.keyDictionary).every(function (candidateKeyName) {\n        if (keyCombination.isEventTriggered(candidateKeyName, keyEventType)) {\n          if (keyName && keyName === keyCombination.getNormalizedKeyName(candidateKeyName)) {\n            keyCompletesCombination = !keyCombination.wasEventPreviouslyTriggered(candidateKeyName, keyEventType);\n          }\n\n          return true;\n        } else {\n          return false;\n        }\n      });\n      return combinationMatchesKeysPressed && keyCompletesCombination;\n    }\n  }, {\n    key: \"_setOrder\",\n    value: function _setOrder() {\n      /**\r\n       * The first time the component that is currently handling the key event has\r\n       * its handlers searched for a match, order the combinations based on their\r\n       * size so that they may be applied in the correct priority order\r\n       */\n      var combinationsPartitionedBySize = Object.values(this._actionConfigs).reduce(function (memo, _ref) {\n        var id = _ref.id,\n            size = _ref.size;\n\n        if (!memo[size]) {\n          memo[size] = [];\n        }\n\n        memo[size].push(id);\n        return memo;\n      }, {});\n      this._order = Object.keys(combinationsPartitionedBySize).sort(function (a, b) {\n        return b - a;\n      }).reduce(function (memo, key) {\n        return memo.concat(combinationsPartitionedBySize[key]);\n      }, []);\n    }\n  }, {\n    key: \"_addNewActionConfig\",\n    value: function _addNewActionConfig(combinationSchema, handler) {\n      var prefix = combinationSchema.prefix,\n          sequenceLength = combinationSchema.sequenceLength,\n          id = combinationSchema.id,\n          keyDictionary = combinationSchema.keyDictionary,\n          size = combinationSchema.size,\n          keyEventType = combinationSchema.keyEventType,\n          actionName = combinationSchema.actionName;\n\n      this._setCombinationMatcher(id, {\n        prefix: prefix,\n        sequenceLength: sequenceLength,\n        id: id,\n        keyDictionary: keyDictionary,\n        size: size,\n        events: {}\n      });\n\n      this._addHandlerToActionConfig(id, {\n        keyEventType: keyEventType,\n        actionName: actionName,\n        handler: handler\n      });\n    }\n  }, {\n    key: \"_addHandlerToActionConfig\",\n    value: function _addHandlerToActionConfig(id, _ref2) {\n      var keyEventType = _ref2.keyEventType,\n          actionName = _ref2.actionName,\n          handler = _ref2.handler;\n\n      var combination = this._getCombinationMatcher(id);\n\n      this._setCombinationMatcher(id, _objectSpread({}, combination, {\n        events: _objectSpread({}, combination.events, _defineProperty({}, keyEventType, {\n          actionName: actionName,\n          handler: handler\n        }))\n      }));\n    }\n  }, {\n    key: \"_setCombinationMatcher\",\n    value: function _setCombinationMatcher(id, combinationMatcher) {\n      this._actionConfigs[id] = combinationMatcher;\n    }\n  }, {\n    key: \"_getCombinationMatcher\",\n    value: function _getCombinationMatcher(id) {\n      return this._actionConfigs[id];\n    }\n  }, {\n    key: \"_includesMatcherForCombination\",\n    value: function _includesMatcherForCombination(id) {\n      return !!this._getCombinationMatcher(id);\n    }\n  }]);\n\n  return KeyCombinationMatcher;\n}();\n\nfunction canBeMatched(keyCombination, combinationMatcher) {\n  var combinationKeysNo = size(combinationMatcher.keyDictionary);\n\n  if (Configuration.option('allowCombinationSubmatches') || keyUpIsBeingHidden(keyCombination)) {\n    return keyCombination.getNumberOfKeys() >= combinationKeysNo;\n  } else {\n    /**\r\n     * If sub-matches are not allow, the number of keys in the key state and the\r\n     * number of keys in the combination we are attempting to match, must be\r\n     * exactly the same\r\n     */\n    return keyCombination.getNumberOfKeys() === combinationKeysNo;\n  }\n}\n\nfunction keyUpIsBeingHidden(keyCombination) {\n  if (keyCombination.isKeyStillPressed('Meta')) {\n    return keyCombination.some(function (keyName) {\n      return keyupIsHiddenByCmd(keyName);\n    });\n  }\n\n  return false;\n}\n\nexport default KeyCombinationMatcher;","map":{"version":3,"sources":["D:/GitHub/ML4GIS/client/node_modules/react-hotkeys/es/lib/matching/KeyCombinationMatcher.js"],"names":["_objectSpread","target","i","arguments","length","source","ownKeys","Object","keys","getOwnPropertySymbols","concat","filter","sym","getOwnPropertyDescriptor","enumerable","forEach","key","_defineProperty","obj","value","defineProperty","configurable","writable","_classCallCheck","instance","Constructor","TypeError","_defineProperties","props","descriptor","_createClass","protoProps","staticProps","prototype","Configuration","size","keyupIsHiddenByCmd","KeyCombinationMatcher","_actionConfigs","_order","addMatch","actionConfig","handler","_includesMatcherForCombination","id","keyEventType","actionName","_addHandlerToActionConfig","_addNewActionConfig","findMatch","keyCombination","keyName","_setOrder","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_iterator","Symbol","iterator","_step","next","done","combinationId","actionOptions","_matchesActionConfig","err","return","toJSON","actionConfigs","order","canBeMatched","combinationHasHandlerForEventType","events","keyCompletesCombination","combinationMatchesKeysPressed","keyDictionary","every","candidateKeyName","isEventTriggered","getNormalizedKeyName","wasEventPreviouslyTriggered","combinationsPartitionedBySize","values","reduce","memo","_ref","push","sort","a","b","combinationSchema","prefix","sequenceLength","_setCombinationMatcher","_ref2","combination","_getCombinationMatcher","combinationMatcher","combinationKeysNo","option","keyUpIsBeingHidden","getNumberOfKeys","isKeyStillPressed","some"],"mappings":"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","sourcesContent":["function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\r\n\r\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\r\n\r\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\r\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\r\n\r\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\r\n\r\nimport Configuration from '../config/Configuration';\r\nimport size from '../../utils/collection/size';\r\nimport keyupIsHiddenByCmd from '../../helpers/resolving-handlers/keyupIsHiddenByCmd';\r\n/**\r\n * Object containing all information necessary to match a handler to a history of\r\n * key combinations\r\n * @typedef {Object} MatchingActionConfig\r\n * @property {NormalizedKeySequenceId} prefix - String describing the sequence of key\r\n *          combinations, before the final key combination (an empty string for\r\n *          sequences that are a single key combination)\r\n * @property {number} sequenceLength - Number of combinations involved in the\r\n *           sequence\r\n * @property {KeyCombinationString} id - Serialized description of the key combinations\r\n *            that make up the sequence\r\n * @property {Object.<KeyName, Boolean>} keyDictionary - Dictionary of key names involved\r\n *           in the last key combination of the sequence\r\n * @property {KeyEventType} keyEventType - Record index for key event that\r\n *          the matcher should match on\r\n * @property {number} size - Number of keys involved in the final key combination\r\n * @property {EventMatchDictionary} events - Dictionary of EventMatches\r\n */\r\n\r\n/**\r\n * A dictionary mapping key event types to event matches\r\n * @typedef {Object.<KeyEventType, EventMatch>} EventMatchDictionary\r\n */\r\n\r\n/**\r\n * Object containing information to call a handler if an event type matches a\r\n * key event\r\n * @typedef {Object} EventMatch\r\n * @property {ActionName} actionName - Name of the action\r\n * @property {Function} handler - Handler to call if event type matches\r\n */\r\n\r\n/**\r\n * Matches a KeyCombination to a list of pre-registered ActionConfiguration and their\r\n * corresponding handler functions\r\n * @class\r\n */\r\n\r\nvar KeyCombinationMatcher =\r\n/*#__PURE__*/\r\nfunction () {\r\n  /**\r\n   * Returns a new instance of KeyCombinationMatcher\r\n   * @returns {KeyCombinationMatcher}\r\n   */\r\n  function KeyCombinationMatcher() {\r\n    _classCallCheck(this, KeyCombinationMatcher);\r\n\r\n    this._actionConfigs = {};\r\n    this._order = null;\r\n  }\r\n  /**\r\n   * Adds a new ActionConfiguration and handler to those that can be used to match a\r\n   * KeyCombination\r\n   * @param {ActionConfiguration} actionConfig\r\n   * @param {Function} handler Function to call if match is selected\r\n   * @returns {void}\r\n   */\r\n\r\n\r\n  _createClass(KeyCombinationMatcher, [{\r\n    key: \"addMatch\",\r\n    value: function addMatch(actionConfig, handler) {\r\n      if (this._includesMatcherForCombination(actionConfig.id)) {\r\n        var keyEventType = actionConfig.keyEventType,\r\n            actionName = actionConfig.actionName,\r\n            id = actionConfig.id;\r\n\r\n        this._addHandlerToActionConfig(id, {\r\n          keyEventType: keyEventType,\r\n          actionName: actionName,\r\n          handler: handler\r\n        });\r\n      } else {\r\n        this._addNewActionConfig(actionConfig, handler);\r\n      }\r\n    }\r\n    /**\r\n     * Finds a MatchingActionConfig for a KeyCombination, ReactKeyName and\r\n     * KeyEventType\r\n     * @param {KeyCombination} keyCombination Record of key combinations\r\n     *         to use in the match\r\n     * @param {ReactKeyName} keyName Name of the key to use in the match\r\n     * @param {KeyEventType} keyEventType The type of key event to use in the match\r\n     * @returns {MatchingActionConfig|null} A MatchingActionOptions that matches the\r\n     *          KeyCombination, ReactKeyName and KeyEventType\r\n     */\r\n\r\n  }, {\r\n    key: \"findMatch\",\r\n    value: function findMatch(keyCombination, keyName, keyEventType) {\r\n      if (!this._order) {\r\n        this._setOrder();\r\n      }\r\n\r\n      var _iteratorNormalCompletion = true;\r\n      var _didIteratorError = false;\r\n      var _iteratorError = undefined;\r\n\r\n      try {\r\n        for (var _iterator = this._order[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\r\n          var combinationId = _step.value;\r\n          var actionOptions = this._actionConfigs[combinationId];\r\n\r\n          if (this._matchesActionConfig(keyCombination, keyName, keyEventType, actionOptions)) {\r\n            return actionOptions;\r\n          }\r\n        }\r\n      } catch (err) {\r\n        _didIteratorError = true;\r\n        _iteratorError = err;\r\n      } finally {\r\n        try {\r\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\r\n            _iterator.return();\r\n          }\r\n        } finally {\r\n          if (_didIteratorError) {\r\n            throw _iteratorError;\r\n          }\r\n        }\r\n      }\r\n\r\n      return null;\r\n    }\r\n    /********************************************************************************\r\n     * Presentation\r\n     ********************************************************************************/\r\n\r\n    /**\r\n     * A plain JavaScript representation of the KeyCombinationMatcher, useful for\r\n     * serialization or debugging\r\n     * @returns {Object} Serialized representation of the key combination matcher\r\n     */\r\n\r\n  }, {\r\n    key: \"toJSON\",\r\n    value: function toJSON() {\r\n      return {\r\n        actionConfigs: this._actionConfigs,\r\n        order: this._order\r\n      };\r\n    }\r\n    /********************************************************************************\r\n     * Private methods\r\n     ********************************************************************************/\r\n\r\n  }, {\r\n    key: \"_matchesActionConfig\",\r\n    value: function _matchesActionConfig(keyCombination, keyName, keyEventType, actionOptions) {\r\n      if (!canBeMatched(keyCombination, actionOptions)) {\r\n        return false;\r\n      }\r\n\r\n      var combinationHasHandlerForEventType = actionOptions.events[keyEventType];\r\n\r\n      if (!combinationHasHandlerForEventType) {\r\n        /**\r\n         * If the combination does not have any actions bound to the key event we are\r\n         * currently processing, we skip checking if it matches the current keys being\r\n         * pressed.\r\n         */\r\n        return false;\r\n      }\r\n\r\n      var keyCompletesCombination = false;\r\n      var combinationMatchesKeysPressed = Object.keys(actionOptions.keyDictionary).every(function (candidateKeyName) {\r\n        if (keyCombination.isEventTriggered(candidateKeyName, keyEventType)) {\r\n          if (keyName && keyName === keyCombination.getNormalizedKeyName(candidateKeyName)) {\r\n            keyCompletesCombination = !keyCombination.wasEventPreviouslyTriggered(candidateKeyName, keyEventType);\r\n          }\r\n\r\n          return true;\r\n        } else {\r\n          return false;\r\n        }\r\n      });\r\n      return combinationMatchesKeysPressed && keyCompletesCombination;\r\n    }\r\n  }, {\r\n    key: \"_setOrder\",\r\n    value: function _setOrder() {\r\n      /**\r\n       * The first time the component that is currently handling the key event has\r\n       * its handlers searched for a match, order the combinations based on their\r\n       * size so that they may be applied in the correct priority order\r\n       */\r\n      var combinationsPartitionedBySize = Object.values(this._actionConfigs).reduce(function (memo, _ref) {\r\n        var id = _ref.id,\r\n            size = _ref.size;\r\n\r\n        if (!memo[size]) {\r\n          memo[size] = [];\r\n        }\r\n\r\n        memo[size].push(id);\r\n        return memo;\r\n      }, {});\r\n      this._order = Object.keys(combinationsPartitionedBySize).sort(function (a, b) {\r\n        return b - a;\r\n      }).reduce(function (memo, key) {\r\n        return memo.concat(combinationsPartitionedBySize[key]);\r\n      }, []);\r\n    }\r\n  }, {\r\n    key: \"_addNewActionConfig\",\r\n    value: function _addNewActionConfig(combinationSchema, handler) {\r\n      var prefix = combinationSchema.prefix,\r\n          sequenceLength = combinationSchema.sequenceLength,\r\n          id = combinationSchema.id,\r\n          keyDictionary = combinationSchema.keyDictionary,\r\n          size = combinationSchema.size,\r\n          keyEventType = combinationSchema.keyEventType,\r\n          actionName = combinationSchema.actionName;\r\n\r\n      this._setCombinationMatcher(id, {\r\n        prefix: prefix,\r\n        sequenceLength: sequenceLength,\r\n        id: id,\r\n        keyDictionary: keyDictionary,\r\n        size: size,\r\n        events: {}\r\n      });\r\n\r\n      this._addHandlerToActionConfig(id, {\r\n        keyEventType: keyEventType,\r\n        actionName: actionName,\r\n        handler: handler\r\n      });\r\n    }\r\n  }, {\r\n    key: \"_addHandlerToActionConfig\",\r\n    value: function _addHandlerToActionConfig(id, _ref2) {\r\n      var keyEventType = _ref2.keyEventType,\r\n          actionName = _ref2.actionName,\r\n          handler = _ref2.handler;\r\n\r\n      var combination = this._getCombinationMatcher(id);\r\n\r\n      this._setCombinationMatcher(id, _objectSpread({}, combination, {\r\n        events: _objectSpread({}, combination.events, _defineProperty({}, keyEventType, {\r\n          actionName: actionName,\r\n          handler: handler\r\n        }))\r\n      }));\r\n    }\r\n  }, {\r\n    key: \"_setCombinationMatcher\",\r\n    value: function _setCombinationMatcher(id, combinationMatcher) {\r\n      this._actionConfigs[id] = combinationMatcher;\r\n    }\r\n  }, {\r\n    key: \"_getCombinationMatcher\",\r\n    value: function _getCombinationMatcher(id) {\r\n      return this._actionConfigs[id];\r\n    }\r\n  }, {\r\n    key: \"_includesMatcherForCombination\",\r\n    value: function _includesMatcherForCombination(id) {\r\n      return !!this._getCombinationMatcher(id);\r\n    }\r\n  }]);\r\n\r\n  return KeyCombinationMatcher;\r\n}();\r\n\r\nfunction canBeMatched(keyCombination, combinationMatcher) {\r\n  var combinationKeysNo = size(combinationMatcher.keyDictionary);\r\n\r\n  if (Configuration.option('allowCombinationSubmatches') || keyUpIsBeingHidden(keyCombination)) {\r\n    return keyCombination.getNumberOfKeys() >= combinationKeysNo;\r\n  } else {\r\n    /**\r\n     * If sub-matches are not allow, the number of keys in the key state and the\r\n     * number of keys in the combination we are attempting to match, must be\r\n     * exactly the same\r\n     */\r\n    return keyCombination.getNumberOfKeys() === combinationKeysNo;\r\n  }\r\n}\r\n\r\nfunction keyUpIsBeingHidden(keyCombination) {\r\n  if (keyCombination.isKeyStillPressed('Meta')) {\r\n    return keyCombination.some(function (keyName) {\r\n      return keyupIsHiddenByCmd(keyName);\r\n    });\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nexport default KeyCombinationMatcher;"]},"metadata":{},"sourceType":"module"}