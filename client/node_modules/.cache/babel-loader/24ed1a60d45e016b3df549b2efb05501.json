{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport stripSuperfluousWhitespace from '../../utils/string/stripSuperfluousWhitespace';\nimport standardizeKeyName from '../../helpers/parsing-key-maps/standardizeKeyName';\nimport isValidKey, { InvalidKeyNameError } from '../../helpers/parsing-key-maps/isValidKey';\n/**\n * Returns a normalized KeyCombinationString (with the key names in the combination\n * sorted in alphabetical order)\n * @param {KeyName[]} keys List of key names to sort and reconstitute as a\n *        KeyCombinationString\n * @returns {NormalizedKeyCombinationString} Normalized KeyCombinationString\n */\n\nfunction normalizedCombinationId(keys) {\n  return keys.sort().join('+');\n}\n/**\n * Parses KeySequenceStrings and returns KeySequenceOptions\n *\n * Used primarily to parse strings describing hot key sequences and combinations\n * so that they may be matched with key events when they occur.\n * @class\n */\n\n\nvar KeySequenceParser = /*#__PURE__*/function () {\n  function KeySequenceParser() {\n    _classCallCheck(this, KeySequenceParser);\n  }\n\n  _createClass(KeySequenceParser, null, [{\n    key: \"parse\",\n\n    /**\n     * @typedef {Object} BasicKeyCombination Object containing the basic information that\n     *          describes a key combination\n     * @property {KeyCombinationString} id - String description of keys involved in the key\n     *          combination\n     * @property {number} size - Number of keys involved in the combination\n     * @property {Object.<KeyName, Boolean>} keyDictionary - Dictionary of key names involved\n     *           in the key combination\n     * @property {KeyEventType} keyEventType - Record index for key event that\n     *          the matcher should match on\n     */\n\n    /**\n     * @typedef {string} KeySequenceString String describing a sequence of one or more key\n     * combinations with whitespace separating key combinations in the sequence and '+'\n     * separating keys within a key combination.\n     */\n\n    /**\n     * @typedef {KeySequenceString} NormalizedKeySequenceId key sequence id with all of the\n     * combination id's normalized\n     */\n\n    /**\n     * @typedef {Object} BasicKeySequence Object containing the basic information that\n     *          describes a key sequence\n     * @property {NormalizedKeySequenceId} prefix - Normalized key sequence id\n     * @property {number} size - Number of combinations involved in the sequence\n     */\n\n    /**\n     * @typedef {Object} KeySequenceObject Object containing description of a key sequence\n     *          to compared against key events\n     * @property {KeySequenceString} id Id describing key sequence used for matching against\n     *            key events\n     * @property {ComponentId} componentId Id associated with the HotKeys component\n     *          that registered the key sequence\n     * @property {BasicKeyCombination[]} sequence A list of key combinations involved in\n     *            the sequence\n     * @property {number} size Number of key combinations in the key sequence\n     * @property {KeyEventType} keyEventType Index that matches key event type\n     * @property {ActionName} actionName Name of the action that should be triggered if a\n     *           keyboard event matching the sequence and event type occur\n     */\n\n    /**\n     * @typedef {Object} KeySequenceOptions Object containing the results of parsing a\n     *          KeySequenceString\n     * @property {BasicKeyCombination} combination Properties of the final combination in\n     *        the sequence\n     * @property {BasicKeySequence} sequence Properties of the sequence of keys leading\n     *        up to the final combination\n     */\n\n    /**\n     * Parses a KeySequenceString and returns a KeySequenceOptions object containing\n     * information about the sequence in a format that is easier to query\n     * @param {KeySequenceString} sequenceString String describing a key sequence to\n     *        parse\n     * @param {Object} options Configuration object describing how the KeySequenceString\n     *        should be parsed.\n     * @param {KeyEventType} options.keyEventType Event record index indicating\n     *        what key event the sequence should match\n     * @param {boolean} options.ensureValidKeys Whether to throw an exception if an invalid\n     *        key name is found in the key combination string.\n     * @returns {KeySequenceOptions} Object containing information about the key\n     *        sequence described by the KeySequenceString\n     */\n    value: function parse(sequenceString) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var trimmedSequenceString = stripSuperfluousWhitespace(sequenceString);\n      var keyCombinationsArray = trimmedSequenceString.split(' ');\n\n      try {\n        var nonTerminalCombinations = keyCombinationsArray.slice(0, keyCombinationsArray.length - 1);\n        var terminalCombination = keyCombinationsArray[keyCombinationsArray.length - 1];\n        var prefix = nonTerminalCombinations.map(function (keyCombination) {\n          var keysInComboDict = parseCombination(keyCombination, options);\n          return normalizedCombinationId(Object.keys(keysInComboDict));\n        }).join(' ');\n        var keysInComboDict = parseCombination(terminalCombination, options);\n        var normalizedComboString = normalizedCombinationId(Object.keys(keysInComboDict));\n        var combination = {\n          id: normalizedComboString,\n          keyDictionary: keysInComboDict,\n          keyEventType: options.keyEventType,\n          size: Object.keys(keysInComboDict).length\n        };\n        return {\n          sequence: {\n            prefix: prefix,\n            size: nonTerminalCombinations.length + 1\n          },\n          combination: combination\n        };\n      } catch (InvalidKeyNameError) {\n        return {\n          sequence: null,\n          combination: null\n        };\n      }\n    }\n  }]);\n\n  return KeySequenceParser;\n}();\n/**\n * @typedef {string} KeyCombinationString String describing a combination of one or more\n * keys separated by '+'\n */\n\n/**\n * @typedef {KeyCombinationString} NormalizedKeyCombinationString key combination id where\n * the keys have been normalized (sorted in alphabetical order)\n */\n\n/**\n * @typedef {Object.<ReactKeyName, Boolean>} KeyDictionary Registry of the names\n * of keys in a particular combination, for easy/quick checking if a particular\n * key is in the key combination\n */\n\n/**\n * Parses a key combination string and returns the corresponding KeyDictionary\n * @param {KeyCombinationString} string Describes key combination\n * @param {Object} options Options hash of how the string should be parsed\n * @param {boolean} options.ensureValidKeys Whether to throw an exception if an invalid\n *        key name is found in the key combination string.\n * @returns {KeyDictionary} Dictionary of keys in the parsed combination\n */\n\n\nfunction parseCombination(string) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return string.replace(/^\\+|(\\s|[^+]\\+)\\+/, '$1plus').split('+').reduce(function (keyDictionary, keyName) {\n    var finalKeyName = standardizeKeyName(keyName);\n\n    if (options.ensureValidKeys) {\n      if (!isValidKey(finalKeyName)) {\n        throw new InvalidKeyNameError();\n      }\n    }\n\n    keyDictionary[finalKeyName] = true;\n    return keyDictionary;\n  }, {});\n}\n\nexport default KeySequenceParser;","map":{"version":3,"sources":["/Users/yan/Documents/proj/ML4GIS/client/node_modules/react-hotkeys/es/lib/shared/KeySequenceParser.js"],"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","stripSuperfluousWhitespace","standardizeKeyName","isValidKey","InvalidKeyNameError","normalizedCombinationId","keys","sort","join","KeySequenceParser","value","parse","sequenceString","options","arguments","undefined","trimmedSequenceString","keyCombinationsArray","split","nonTerminalCombinations","slice","terminalCombination","prefix","map","keyCombination","keysInComboDict","parseCombination","normalizedComboString","combination","id","keyDictionary","keyEventType","size","sequence","string","replace","reduce","keyName","finalKeyName","ensureValidKeys"],"mappings":"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","sourcesContent":["function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nimport stripSuperfluousWhitespace from '../../utils/string/stripSuperfluousWhitespace';\nimport standardizeKeyName from '../../helpers/parsing-key-maps/standardizeKeyName';\nimport isValidKey, { InvalidKeyNameError } from '../../helpers/parsing-key-maps/isValidKey';\n/**\n * Returns a normalized KeyCombinationString (with the key names in the combination\n * sorted in alphabetical order)\n * @param {KeyName[]} keys List of key names to sort and reconstitute as a\n *        KeyCombinationString\n * @returns {NormalizedKeyCombinationString} Normalized KeyCombinationString\n */\n\nfunction normalizedCombinationId(keys) {\n  return keys.sort().join('+');\n}\n/**\n * Parses KeySequenceStrings and returns KeySequenceOptions\n *\n * Used primarily to parse strings describing hot key sequences and combinations\n * so that they may be matched with key events when they occur.\n * @class\n */\n\n\nvar KeySequenceParser =\n/*#__PURE__*/\nfunction () {\n  function KeySequenceParser() {\n    _classCallCheck(this, KeySequenceParser);\n  }\n\n  _createClass(KeySequenceParser, null, [{\n    key: \"parse\",\n\n    /**\n     * @typedef {Object} BasicKeyCombination Object containing the basic information that\n     *          describes a key combination\n     * @property {KeyCombinationString} id - String description of keys involved in the key\n     *          combination\n     * @property {number} size - Number of keys involved in the combination\n     * @property {Object.<KeyName, Boolean>} keyDictionary - Dictionary of key names involved\n     *           in the key combination\n     * @property {KeyEventType} keyEventType - Record index for key event that\n     *          the matcher should match on\n     */\n\n    /**\n     * @typedef {string} KeySequenceString String describing a sequence of one or more key\n     * combinations with whitespace separating key combinations in the sequence and '+'\n     * separating keys within a key combination.\n     */\n\n    /**\n     * @typedef {KeySequenceString} NormalizedKeySequenceId key sequence id with all of the\n     * combination id's normalized\n     */\n\n    /**\n     * @typedef {Object} BasicKeySequence Object containing the basic information that\n     *          describes a key sequence\n     * @property {NormalizedKeySequenceId} prefix - Normalized key sequence id\n     * @property {number} size - Number of combinations involved in the sequence\n     */\n\n    /**\n     * @typedef {Object} KeySequenceObject Object containing description of a key sequence\n     *          to compared against key events\n     * @property {KeySequenceString} id Id describing key sequence used for matching against\n     *            key events\n     * @property {ComponentId} componentId Id associated with the HotKeys component\n     *          that registered the key sequence\n     * @property {BasicKeyCombination[]} sequence A list of key combinations involved in\n     *            the sequence\n     * @property {number} size Number of key combinations in the key sequence\n     * @property {KeyEventType} keyEventType Index that matches key event type\n     * @property {ActionName} actionName Name of the action that should be triggered if a\n     *           keyboard event matching the sequence and event type occur\n     */\n\n    /**\n     * @typedef {Object} KeySequenceOptions Object containing the results of parsing a\n     *          KeySequenceString\n     * @property {BasicKeyCombination} combination Properties of the final combination in\n     *        the sequence\n     * @property {BasicKeySequence} sequence Properties of the sequence of keys leading\n     *        up to the final combination\n     */\n\n    /**\n     * Parses a KeySequenceString and returns a KeySequenceOptions object containing\n     * information about the sequence in a format that is easier to query\n     * @param {KeySequenceString} sequenceString String describing a key sequence to\n     *        parse\n     * @param {Object} options Configuration object describing how the KeySequenceString\n     *        should be parsed.\n     * @param {KeyEventType} options.keyEventType Event record index indicating\n     *        what key event the sequence should match\n     * @param {boolean} options.ensureValidKeys Whether to throw an exception if an invalid\n     *        key name is found in the key combination string.\n     * @returns {KeySequenceOptions} Object containing information about the key\n     *        sequence described by the KeySequenceString\n     */\n    value: function parse(sequenceString) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var trimmedSequenceString = stripSuperfluousWhitespace(sequenceString);\n      var keyCombinationsArray = trimmedSequenceString.split(' ');\n\n      try {\n        var nonTerminalCombinations = keyCombinationsArray.slice(0, keyCombinationsArray.length - 1);\n        var terminalCombination = keyCombinationsArray[keyCombinationsArray.length - 1];\n        var prefix = nonTerminalCombinations.map(function (keyCombination) {\n          var keysInComboDict = parseCombination(keyCombination, options);\n          return normalizedCombinationId(Object.keys(keysInComboDict));\n        }).join(' ');\n        var keysInComboDict = parseCombination(terminalCombination, options);\n        var normalizedComboString = normalizedCombinationId(Object.keys(keysInComboDict));\n        var combination = {\n          id: normalizedComboString,\n          keyDictionary: keysInComboDict,\n          keyEventType: options.keyEventType,\n          size: Object.keys(keysInComboDict).length\n        };\n        return {\n          sequence: {\n            prefix: prefix,\n            size: nonTerminalCombinations.length + 1\n          },\n          combination: combination\n        };\n      } catch (InvalidKeyNameError) {\n        return {\n          sequence: null,\n          combination: null\n        };\n      }\n    }\n  }]);\n\n  return KeySequenceParser;\n}();\n/**\n * @typedef {string} KeyCombinationString String describing a combination of one or more\n * keys separated by '+'\n */\n\n/**\n * @typedef {KeyCombinationString} NormalizedKeyCombinationString key combination id where\n * the keys have been normalized (sorted in alphabetical order)\n */\n\n/**\n * @typedef {Object.<ReactKeyName, Boolean>} KeyDictionary Registry of the names\n * of keys in a particular combination, for easy/quick checking if a particular\n * key is in the key combination\n */\n\n/**\n * Parses a key combination string and returns the corresponding KeyDictionary\n * @param {KeyCombinationString} string Describes key combination\n * @param {Object} options Options hash of how the string should be parsed\n * @param {boolean} options.ensureValidKeys Whether to throw an exception if an invalid\n *        key name is found in the key combination string.\n * @returns {KeyDictionary} Dictionary of keys in the parsed combination\n */\n\n\nfunction parseCombination(string) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return string.replace(/^\\+|(\\s|[^+]\\+)\\+/, '$1plus').split('+').reduce(function (keyDictionary, keyName) {\n    var finalKeyName = standardizeKeyName(keyName);\n\n    if (options.ensureValidKeys) {\n      if (!isValidKey(finalKeyName)) {\n        throw new InvalidKeyNameError();\n      }\n    }\n\n    keyDictionary[finalKeyName] = true;\n    return keyDictionary;\n  }, {});\n}\n\nexport default KeySequenceParser;"]},"metadata":{},"sourceType":"module"}