{"ast":null,"code":"function _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _get(target, property, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get(target, property, receiver || target);\n}\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nimport KeyEventType from '../../const/KeyEventType';\nimport AbstractKeyEventStrategy from './AbstractKeyEventStrategy';\nimport describeKeyEventType from '../../helpers/logging/describeKeyEventType';\nimport KeyEventCounter from '../listening/KeyEventCounter';\nimport Logger from '../logging/Logger';\nimport isUndefined from '../../utils/isUndefined';\nimport printComponent from '../../helpers/logging/printComponent';\nimport getKeyName from '../../helpers/resolving-handlers/getKeyName';\nimport Configuration from '../config/Configuration';\nimport describeKeyEvent from '../../helpers/logging/describeKeyEvent';\nimport isCmdKey from '../../helpers/parsing-key-maps/isCmdKey';\nimport EventResponse from '../../const/EventResponse';\nimport contains from '../../utils/collection/contains';\nimport stateFromEvent from '../../helpers/parsing-key-maps/stateFromEvent';\nimport normalizeEventName from '../../utils/string/normalizeEventName';\n/**\n * Defines behaviour for dealing with key maps defined in global HotKey components\n * @class\n */\n\nvar GlobalKeyEventStrategy = /*#__PURE__*/function (_AbstractKeyEventStra) {\n  _inherits(GlobalKeyEventStrategy, _AbstractKeyEventStra);\n  /********************************************************************************\n   * Init & Reset\n   ********************************************************************************/\n\n\n  function GlobalKeyEventStrategy() {\n    var _this;\n\n    var configuration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var keyEventManager = arguments.length > 1 ? arguments[1] : undefined;\n\n    _classCallCheck(this, GlobalKeyEventStrategy);\n    /**\n     * Set state that gets cleared every time a component gets mounted or unmounted\n     */\n\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(GlobalKeyEventStrategy).call(this, configuration, keyEventManager));\n    /**\n     * Set state that doesn't get cleared each time a new new component is mounted\n     * or unmounted\n     * @type {number}\n     */\n\n    /**\n     * Whether the global key event handlers have been bound to document yet or not\n     * @type {boolean}\n     */\n\n    _this.listenersBound = false;\n    _this.eventOptions = {\n      ignoreEventsCondition: Configuration.option('ignoreEventsCondition')\n    };\n    /**\n     * Dictionary of listener functions - currently only intended to house\n     * keyCombinationListener\n     */\n\n    _this.listeners = {};\n    return _this;\n  }\n  /********************************************************************************\n   * Enabling key maps and handlers\n   ********************************************************************************/\n\n  /**\n   * Registers the actions and handlers of a HotKeys component that has mounted\n   * @param {ComponentId} componentId - Id of the component that the keyMap belongs to\n   * @param {KeyMap} actionNameToKeyMap - Map of actions to key expressions\n   * @param {HandlersMap} actionNameToHandlersMap - Map of actions to handler functions\n   * @param {Object} options Hash of options that configure how the actions\n   *        and handlers are associated and called.\n   * @param {Object} eventOptions - Options for how the event should be handled\n   */\n\n\n  _createClass(GlobalKeyEventStrategy, [{\n    key: \"enableHotKeys\",\n    value: function enableHotKeys(componentId) {\n      var actionNameToKeyMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var actionNameToHandlersMap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var options = arguments.length > 3 ? arguments[3] : undefined;\n      var eventOptions = arguments.length > 4 ? arguments[4] : undefined;\n      this.eventOptions = eventOptions;\n\n      this._addComponent(componentId, actionNameToKeyMap, actionNameToHandlersMap, options);\n\n      this._updateDocumentHandlers();\n      /**\n       * Reset handler resolution state\n       */\n\n\n      this._initHandlerResolutionState();\n\n      this.logger.debug(this._logPrefix(componentId, {\n        eventId: false\n      }), 'Mounted.');\n      this.logger.verbose(this._logPrefix(componentId, {\n        eventId: false\n      }), 'Component options: \\n', printComponent(this.componentList.get(componentId)));\n    }\n    /**\n     * Handles when a mounted global HotKeys component updates its props and changes\n     * either the keyMap or handlers prop value\n     * @param {ComponentId} componentId - The component index of the component to\n     *        update\n     * @param {KeyMap} actionNameToKeyMap - Map of actions to key expressions\n     * @param {HandlersMap} actionNameToHandlersMap - Map of actions to handler functions\n     * @param {Object} options Hash of options that configure how the actions\n     *        and handlers are associated and called.\n     * @param {Object} eventOptions - Options for how the event should be handled\n     */\n\n  }, {\n    key: \"updateEnabledHotKeys\",\n    value: function updateEnabledHotKeys(componentId) {\n      var actionNameToKeyMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var actionNameToHandlersMap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var options = arguments.length > 3 ? arguments[3] : undefined;\n      var eventOptions = arguments.length > 4 ? arguments[4] : undefined;\n      this.eventOptions = eventOptions;\n      this.componentList.update(componentId, actionNameToKeyMap, actionNameToHandlersMap, options);\n      this.getKeyHistory().setMaxLength(this.componentList.getLongestSequence());\n      /**\n       * Reset strategy state specific to the global strategy\n       */\n\n      this._updateDocumentHandlers();\n      /**\n       * Reset handler resolution state\n       */\n\n\n      this._initHandlerResolutionState();\n\n      this.logger.debug(this._logPrefix(componentId, {\n        eventId: false\n      }), \"Global component \".concat(componentId, \" updated.\"));\n      this.logger.verbose(this._logPrefix(componentId, {\n        eventId: false\n      }), 'Component options: \\n', printComponent(this.componentList.get(componentId)));\n    }\n    /**\n     * Handles when a component is unmounted\n     * @param {ComponentId} componentId - Index of component that is being unmounted\n     */\n\n  }, {\n    key: \"disableHotKeys\",\n    value: function disableHotKeys(componentId) {\n      /**\n       * Manually update the registered key map state, usually reset using\n       * _resetRegisteredKeyMapsState() method\n       */\n      this.componentList.remove(componentId);\n      this.getKeyHistory().setMaxLength(this.componentList.getLongestSequence());\n\n      this._updateDocumentHandlers();\n      /**\n       * Reset handler resolution state\n       */\n\n\n      this._initHandlerResolutionState();\n\n      this.logger.debug(this._logPrefix(componentId, {\n        eventId: false\n      }), \"Unmounted global component \".concat(componentId));\n    }\n  }, {\n    key: \"_updateDocumentHandlers\",\n    value: function _updateDocumentHandlers() {\n      var _this2 = this;\n\n      var listenersShouldBeBound = this._listenersShouldBeBound();\n\n      if (!this.listenersBound && listenersShouldBeBound) {\n        Object.values(KeyEventType).forEach(function (recordIndex) {\n          var eventName = describeKeyEventType(recordIndex);\n\n          document[\"on\".concat(eventName)] = function (keyEvent) {\n            _this2.keyEventManager[\"handleGlobal\".concat(normalizeEventName(eventName))](keyEvent);\n          };\n\n          _this2.logger.debug(_this2._logPrefix(_this2.componentId, {\n            eventId: false\n          }), \"Bound handler handleGlobal\".concat(normalizeEventName(eventName), \"() to document.on\").concat(eventName, \"()\"));\n        });\n        this.listenersBound = true;\n      } else if (this.listenersBound && !listenersShouldBeBound) {\n        Object.values(KeyEventType).forEach(function (recordIndex) {\n          var eventName = describeKeyEventType(recordIndex);\n          delete document[\"on\".concat(eventName)];\n\n          _this2.logger.debug(_this2._logPrefix(_this2.componentId, {\n            eventId: false\n          }), \"Removed handler handleGlobal\".concat(normalizeEventName(eventName), \"() from document.on\").concat(eventName, \"()\"));\n        });\n        this.listenersBound = false;\n      }\n    }\n    /**\n     * Whether the document listeners should be bound, to record key events. Basically a check\n     * to see if there are any global key maps, or whether the user is currently rebinding to\n     * a new key combination.\n     * @returns {boolean} True if the document listeners should be bound\n     * @private\n     */\n\n  }, {\n    key: \"_listenersShouldBeBound\",\n    value: function _listenersShouldBeBound() {\n      return this.componentList.any() || this.listeners.keyCombination;\n    }\n    /********************************************************************************\n     * Recording key events\n     ********************************************************************************/\n\n    /**\n     * Records a keydown keyboard event and matches it against the list of pre-registered\n     * event handlers, calling the first matching handler with the highest priority if\n     * one exists.\n     *\n     * This method is called once when a keyboard event bubbles up to document, and checks\n     * the keymaps for all of the mounted global HotKey components.\n     * @param {KeyboardEvent} event - Event containing the key name and state\n     */\n\n  }, {\n    key: \"handleKeydown\",\n    value: function handleKeydown(event) {\n      var _key = getKeyName(event);\n\n      if (event.repeat && Configuration.option('ignoreRepeatedEventsWhenKeyHeldDown')) {\n        this.logger.debug(this._logPrefix(), \"Ignored repeated \".concat(describeKeyEvent(event, _key, KeyEventType.keydown), \" event.\"));\n        return true;\n      }\n\n      this._checkForModifierFlagDiscrepancies(event, _key, KeyEventType.keydown);\n\n      var reactAppResponse = this._howReactAppRespondedTo(event, _key, KeyEventType.keydown);\n\n      if (reactAppResponse === EventResponse.unseen && this.eventOptions.ignoreEventsCondition(event)) {\n        this.logger.debug(this._logPrefix(), \"Ignored \".concat(describeKeyEvent(event, _key, KeyEventType.keydown), \" event because ignoreEventsFilter rejected it.\"));\n        return;\n      }\n\n      if (reactAppResponse !== EventResponse.ignored) {\n        var keyEventState = stateFromEvent(event);\n        var currentCombination = this.getCurrentCombination();\n\n        if (currentCombination.isKeyIncluded(_key) || currentCombination.isEnding()) {\n          this._startAndLogNewKeyCombination(_key, keyEventState);\n        } else {\n          this._addToAndLogCurrentKeyCombination(_key, KeyEventType.keydown, keyEventState);\n        }\n      }\n\n      if (!contains([EventResponse.ignored, EventResponse.handled], reactAppResponse)) {\n        this._callHandlerIfExists(event, _key, KeyEventType.keydown);\n      }\n\n      this._simulateKeyPressForNonPrintableKeys(event, _key);\n    }\n  }, {\n    key: \"_howReactAppRespondedTo\",\n    value: function _howReactAppRespondedTo(event, key, keyEventType) {\n      var reactAppHistoryWithEvent = this.keyEventManager.reactAppHistoryWithEvent(key, keyEventType);\n\n      switch (reactAppHistoryWithEvent) {\n        case EventResponse.handled:\n          this.logger.debug(this._logPrefix(), \"Ignored \".concat(describeKeyEvent(event, key, keyEventType), \" event because React app has already handled it.\"));\n          break;\n\n        case EventResponse.ignored:\n          this.logger.debug(this._logPrefix(), \"Ignored \".concat(describeKeyEvent(event, key, keyEventType), \" event because React app has declared it should be ignored.\"));\n          break;\n\n        case EventResponse.seen:\n          this.logger.debug(this._logPrefix(), \"Received \".concat(describeKeyEvent(event, key, keyEventType), \" event (that has already passed through React app).\"));\n          break;\n\n        default:\n          KeyEventCounter.incrementId();\n          this.logger.debug(this._logPrefix(), \"New \".concat(describeKeyEvent(event, key, keyEventType), \" event (that has NOT passed through React app).\"));\n      }\n\n      return reactAppHistoryWithEvent;\n    }\n    /**\n     * Records a keypress keyboard event and matches it against the list of pre-registered\n     * event handlers, calling the first matching handler with the highest priority if\n     * one exists.\n     *\n     * This method is called once when a keyboard event bubbles up to document, and checks\n     * the keymaps for all of the mounted global HotKey components.\n     * @param {KeyboardEvent} event - Event containing the key name and state\n     */\n\n  }, {\n    key: \"handleKeyPress\",\n    value: function handleKeyPress(event) {\n      var key = getKeyName(event);\n\n      if (event.repeat && Configuration.option('ignoreRepeatedEventsWhenKeyHeldDown')) {\n        this.logger.debug(this._logPrefix(), \"Ignored repeated \".concat(describeKeyEvent(event, key, KeyEventType.keypress), \" event.\"));\n        return true;\n      }\n\n      var currentCombination = this.getCurrentCombination();\n\n      if (currentCombination.isKeyPressSimulated(key)) {\n        this.logger.debug(this._logPrefix(), \"Ignored \".concat(describeKeyEvent(event, key, KeyEventType.keypress), \" as it was not expected, and has already been simulated.\"));\n        return true;\n      }\n      /**\n       * We first decide if the keypress event should be handled (to ensure the correct\n       * order of logging statements)\n       */\n\n\n      var reactAppResponse = this._howReactAppRespondedTo(event, key, KeyEventType.keypress);\n      /**\n       * Add new key event to key combination history\n       */\n\n\n      if (currentCombination.isKeyIncluded(key)) {\n        this._addToAndLogCurrentKeyCombination(key, KeyEventType.keypress, stateFromEvent(event));\n      }\n\n      if (reactAppResponse === EventResponse.unseen) {\n        /**\n         * If the key event has not been seen by the React application, we ensure that\n         * it's not still waiting for it. This occurs when action handlers bound to keydown\n         * move the focus outside of the react app before it can record the keypress or\n         * keyup\n         */\n        this.keyEventManager.closeHangingKeyCombination(key, KeyEventType.keypress);\n\n        if (this.eventOptions.ignoreEventsCondition(event)) {\n          this.logger.debug(this._logPrefix(), \"Ignored \".concat(describeKeyEvent(event, key, KeyEventType.keypress), \" event because ignoreEventsFilter rejected it.\"));\n          return;\n        }\n      }\n\n      if (!contains([EventResponse.ignored, EventResponse.handled], reactAppResponse)) {\n        this._callHandlerIfExists(event, key, KeyEventType.keypress);\n      }\n    }\n    /**\n     * Records a keyup keyboard event and matches it against the list of pre-registered\n     * event handlers, calling the first matching handler with the highest priority if\n     * one exists.\n     *\n     * This method is called once when a keyboard event bubbles up to document, and checks\n     * the keymaps for all of the mounted global HotKey components.\n     * @param {KeyboardEvent} event - Event containing the key name and state\n     */\n\n  }, {\n    key: \"handleKeyUp\",\n    value: function handleKeyUp(event) {\n      var key = getKeyName(event);\n      var currentCombination = this.getCurrentCombination();\n\n      if (currentCombination.isKeyUpSimulated(key)) {\n        this.logger.debug(this._logPrefix(), \"Ignored \".concat(describeKeyEvent(event, key, KeyEventType.keyup), \" as it was not expected, and has already been simulated.\"));\n        return true;\n      }\n      /**\n       * We first decide if the keyup event should be handled (to ensure the correct\n       * order of logging statements)\n       */\n\n\n      var reactAppResponse = this._howReactAppRespondedTo(event, key, KeyEventType.keyup);\n      /**\n       * We then add the keyup to our current combination - regardless of whether\n       * it's to be handled or not. We need to do this to ensure that if a handler\n       * function changes focus to a context that ignored events, the keyup event\n       * is not lost (leaving react hotkeys thinking the key is still pressed).\n       */\n\n\n      if (currentCombination.isKeyIncluded(key)) {\n        this._addToAndLogCurrentKeyCombination(key, KeyEventType.keyup, stateFromEvent(event));\n      }\n\n      if (reactAppResponse === EventResponse.unseen) {\n        /**\n         * If the key event has not been seen by the React application, we ensure that\n         * it's not still waiting for it. This occurs when action handlers bound to keydown\n         * or keypress move the focus outside of the react app before it can record the keyup\n         */\n        this.keyEventManager.closeHangingKeyCombination(key, KeyEventType.keyup);\n\n        if (this.eventOptions.ignoreEventsCondition(event)) {\n          this.logger.debug(this._logPrefix(), \"Ignored \".concat(describeKeyEvent(event, key, KeyEventType.keyup), \" event because ignoreEventsFilter rejected it.\"));\n        } else {\n          /**\n           * We attempt to find a handler of the event, only if it has not already\n           * been handled and should not be ignored\n           */\n          if (!contains([EventResponse.ignored, EventResponse.handled], reactAppResponse)) {\n            this._callHandlerIfExists(event, key, KeyEventType.keyup);\n          }\n        }\n      } else {\n        /**\n         * We attempt to find a handler of the event, only if it has not already\n         * been handled and should not be ignored\n         */\n        if (!contains([EventResponse.ignored, EventResponse.handled], reactAppResponse)) {\n          this._callHandlerIfExists(event, key, KeyEventType.keyup);\n        }\n      }\n      /**\n       * We simulate any hidden keyup events hidden by the command key, regardless\n       * of whether the event should be ignored or not\n       */\n\n\n      this._simulateKeyUpEventsHiddenByCmd(event, key);\n\n      if (this.listeners.keyCombination && this._allKeysAreReleased()) {\n        this.listeners.keyCombination({\n          keys: currentCombination.getKeyDictionary(),\n          id: currentCombination.describe()\n        });\n      }\n    }\n  }, {\n    key: \"_simulateKeyPressForNonPrintableKeys\",\n    value: function _simulateKeyPressForNonPrintableKeys(event, key) {\n      this.keyEventManager.simulatePendingKeyPressEvents();\n\n      this._handleEventSimulation('handleKeyPress', this._shouldSimulate(KeyEventType.keypress, key), {\n        event: event,\n        key: key\n      });\n    }\n  }, {\n    key: \"_simulateKeyUpEventsHiddenByCmd\",\n    value: function _simulateKeyUpEventsHiddenByCmd(event, key) {\n      var _this3 = this;\n\n      if (isCmdKey(key)) {\n        /**\n         * We simulate pending key events in the React app before we do it globally\n         */\n        this.keyEventManager.simulatePendingKeyUpEvents();\n        this.getCurrentCombination().forEachKey(function (keyName) {\n          if (isCmdKey(keyName)) {\n            return;\n          }\n\n          _this3._handleEventSimulation('handleKeyUp', _this3._shouldSimulate(KeyEventType.keyup, keyName), {\n            event: event,\n            key: keyName\n          });\n        });\n      }\n    }\n  }, {\n    key: \"_startAndLogNewKeyCombination\",\n    value: function _startAndLogNewKeyCombination(keyName, keyEventState) {\n      this.getKeyHistory().startNewKeyCombination(keyName, keyEventState);\n      this.logger.verbose(this._logPrefix(), \"Started a new combination with '\".concat(keyName, \"'.\"));\n      this.logger.verbose(this._logPrefix(), \"Key history: \".concat(printComponent(this.getKeyHistory().toJSON()), \".\"));\n    }\n  }, {\n    key: \"_addToAndLogCurrentKeyCombination\",\n    value: function _addToAndLogCurrentKeyCombination(keyName, keyEventType, keyEventState) {\n      this.getKeyHistory().addKeyToCurrentCombination(keyName, keyEventType, keyEventState);\n\n      if (keyEventType === KeyEventType.keydown) {\n        this.logger.verbose(this._logPrefix(), \"Added '\".concat(keyName, \"' to current combination: '\").concat(this.getCurrentCombination().describe(), \"'.\"));\n      }\n\n      this.logger.verbose(this._logPrefix(), \"Key history: \".concat(printComponent(this.getKeyHistory().toJSON()), \".\"));\n    }\n    /********************************************************************************\n     * Event simulation\n     ********************************************************************************/\n\n  }, {\n    key: \"_handleEventSimulation\",\n    value: function _handleEventSimulation(handlerName, shouldSimulate, _ref) {\n      var event = _ref.event,\n          key = _ref.key;\n\n      if (shouldSimulate && Configuration.option('simulateMissingKeyPressEvents')) {\n        /**\n         * If a key does not have a keypress event, we simulate one immediately after\n         * the keydown event, to keep the behaviour consistent across all keys\n         */\n        var _event = this._cloneAndMergeEvent(event, {\n          key: key,\n          simulated: true\n        });\n\n        this[handlerName](_event);\n      }\n    }\n    /********************************************************************************\n     * Matching and calling handlers\n     ********************************************************************************/\n\n  }, {\n    key: \"_callHandlerIfExists\",\n    value: function _callHandlerIfExists(event, keyName, keyEventType) {\n      var eventName = describeKeyEventType(keyEventType);\n      var combinationName = this.getCurrentCombination().describe();\n\n      if (!this.componentList.anyActionsForEventType(keyEventType)) {\n        /**\n         * If there are no handlers registered for the particular key event type\n         * (keydown, keypress, keyup) then skip trying to find a matching handler\n         * for the current key combination\n         */\n        this.logger.debug(this._logPrefix(), \"Ignored '\".concat(combinationName, \"' \").concat(eventName, \" because it doesn't have any \").concat(eventName, \" handlers.\"));\n        return;\n      }\n      /**\n       * If there is at least one handler for the specified key event type (keydown,\n       * keypress, keyup), then attempt to find a handler that matches the current\n       * key combination\n       */\n\n\n      this.logger.verbose(this._logPrefix(), \"Attempting to find action matching '\".concat(combinationName, \"' \").concat(eventName, \" . . .\"));\n\n      this._callClosestMatchingHandler(event, keyName, keyEventType);\n    }\n  }, {\n    key: \"_callClosestMatchingHandler\",\n    value: function _callClosestMatchingHandler(event, keyName, keyEventType) {\n      var componentListIterator = this.componentList.getNewIterator();\n\n      while (componentListIterator.next()) {\n        var matchFound = _get(_getPrototypeOf(GlobalKeyEventStrategy.prototype), \"_callClosestMatchingHandler\", this).call(this, event, keyName, keyEventType, componentListIterator.getPosition(), 0);\n\n        if (matchFound) {\n          this.logger.debug(this._logPrefix(), \"Searching no further, as handler has been found (and called).\");\n          return;\n        }\n      }\n    }\n  }, {\n    key: \"_stopEventPropagation\",\n    value: function _stopEventPropagation(event, componentId) {\n      this.logger.debug(this._logPrefix(componentId), 'Stopping further event propagation.');\n\n      if (!event.simulated) {\n        event.stopPropagation();\n      }\n    }\n    /********************************************************************************\n     * Recording key combination\n     ********************************************************************************/\n\n    /**\n     * Add a new key combination listener function to be called the next time a key\n     * combination completes (assuming the cancel function is not called).\n     * @param {keyCombinationListener} callbackFunction Function to call with the next\n     *        completed key combination\n     * @returns {function} Function to call to cancel listening for the next key\n     *        combination\n     */\n\n  }, {\n    key: \"addKeyCombinationListener\",\n    value: function addKeyCombinationListener(callbackFunction) {\n      var _this4 = this;\n\n      var cancel = function cancel() {\n        delete _this4.listeners.keyCombination;\n      };\n\n      this.listeners.keyCombination = function (keyCombination) {\n        callbackFunction(keyCombination);\n        cancel();\n      };\n\n      this._updateDocumentHandlers();\n\n      return cancel;\n    }\n    /********************************************************************************\n     * Logging\n     ********************************************************************************/\n\n  }, {\n    key: \"_logPrefix\",\n    value: function _logPrefix(componentId) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var eventIcons = Logger.eventIcons;\n      var componentIcons = Logger.componentIcons;\n      var base = 'HotKeys (GLOBAL';\n\n      if (options.eventId !== false) {\n        var eventId = isUndefined(options.eventId) ? KeyEventCounter.getId() : options.eventId;\n        base = \"\".concat(base, \"-E\").concat(eventId).concat(eventIcons[eventId % eventIcons.length]);\n      }\n\n      if (isUndefined(componentId)) {\n        return \"\".concat(base, \"):\");\n      } else {\n        return \"\".concat(base, \"-C\").concat(componentId).concat(componentIcons[componentId % componentIcons.length], \"):\");\n      }\n    }\n  }]);\n\n  return GlobalKeyEventStrategy;\n}(AbstractKeyEventStrategy);\n\nexport default GlobalKeyEventStrategy;","map":{"version":3,"sources":["C:/Users/pccis/Desktop/ML4GIS-develop/client/node_modules/react-hotkeys/es/lib/strategies/GlobalKeyEventStrategy.js"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","_possibleConstructorReturn","self","call","_assertThisInitialized","ReferenceError","_get","property","receiver","Reflect","get","base","_superPropBase","desc","getOwnPropertyDescriptor","value","object","hasOwnProperty","_getPrototypeOf","o","setPrototypeOf","getPrototypeOf","__proto__","_inherits","subClass","superClass","create","_setPrototypeOf","p","KeyEventType","AbstractKeyEventStrategy","describeKeyEventType","KeyEventCounter","Logger","isUndefined","printComponent","getKeyName","Configuration","describeKeyEvent","isCmdKey","EventResponse","contains","stateFromEvent","normalizeEventName","GlobalKeyEventStrategy","_AbstractKeyEventStra","_this","configuration","arguments","undefined","keyEventManager","listenersBound","eventOptions","ignoreEventsCondition","option","listeners","enableHotKeys","componentId","actionNameToKeyMap","actionNameToHandlersMap","options","_addComponent","_updateDocumentHandlers","_initHandlerResolutionState","logger","debug","_logPrefix","eventId","verbose","componentList","updateEnabledHotKeys","update","getKeyHistory","setMaxLength","getLongestSequence","concat","disableHotKeys","remove","_this2","listenersShouldBeBound","_listenersShouldBeBound","values","forEach","recordIndex","eventName","document","keyEvent","any","keyCombination","handleKeydown","event","_key","repeat","keydown","_checkForModifierFlagDiscrepancies","reactAppResponse","_howReactAppRespondedTo","unseen","ignored","keyEventState","currentCombination","getCurrentCombination","isKeyIncluded","isEnding","_startAndLogNewKeyCombination","_addToAndLogCurrentKeyCombination","handled","_callHandlerIfExists","_simulateKeyPressForNonPrintableKeys","keyEventType","reactAppHistoryWithEvent","seen","incrementId","handleKeyPress","keypress","isKeyPressSimulated","closeHangingKeyCombination","handleKeyUp","isKeyUpSimulated","keyup","_simulateKeyUpEventsHiddenByCmd","_allKeysAreReleased","keys","getKeyDictionary","id","describe","simulatePendingKeyPressEvents","_handleEventSimulation","_shouldSimulate","_this3","simulatePendingKeyUpEvents","forEachKey","keyName","startNewKeyCombination","toJSON","addKeyToCurrentCombination","handlerName","shouldSimulate","_ref","_event","_cloneAndMergeEvent","simulated","combinationName","anyActionsForEventType","_callClosestMatchingHandler","componentListIterator","getNewIterator","next","matchFound","getPosition","_stopEventPropagation","stopPropagation","addKeyCombinationListener","callbackFunction","_this4","cancel","eventIcons","componentIcons","getId"],"mappings":"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","sourcesContent":["function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nimport KeyEventType from '../../const/KeyEventType';\nimport AbstractKeyEventStrategy from './AbstractKeyEventStrategy';\nimport describeKeyEventType from '../../helpers/logging/describeKeyEventType';\nimport KeyEventCounter from '../listening/KeyEventCounter';\nimport Logger from '../logging/Logger';\nimport isUndefined from '../../utils/isUndefined';\nimport printComponent from '../../helpers/logging/printComponent';\nimport getKeyName from '../../helpers/resolving-handlers/getKeyName';\nimport Configuration from '../config/Configuration';\nimport describeKeyEvent from '../../helpers/logging/describeKeyEvent';\nimport isCmdKey from '../../helpers/parsing-key-maps/isCmdKey';\nimport EventResponse from '../../const/EventResponse';\nimport contains from '../../utils/collection/contains';\nimport stateFromEvent from '../../helpers/parsing-key-maps/stateFromEvent';\nimport normalizeEventName from '../../utils/string/normalizeEventName';\n/**\n * Defines behaviour for dealing with key maps defined in global HotKey components\n * @class\n */\n\nvar GlobalKeyEventStrategy =\n/*#__PURE__*/\nfunction (_AbstractKeyEventStra) {\n  _inherits(GlobalKeyEventStrategy, _AbstractKeyEventStra);\n\n  /********************************************************************************\n   * Init & Reset\n   ********************************************************************************/\n  function GlobalKeyEventStrategy() {\n    var _this;\n\n    var configuration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var keyEventManager = arguments.length > 1 ? arguments[1] : undefined;\n\n    _classCallCheck(this, GlobalKeyEventStrategy);\n\n    /**\n     * Set state that gets cleared every time a component gets mounted or unmounted\n     */\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(GlobalKeyEventStrategy).call(this, configuration, keyEventManager));\n    /**\n     * Set state that doesn't get cleared each time a new new component is mounted\n     * or unmounted\n     * @type {number}\n     */\n\n    /**\n     * Whether the global key event handlers have been bound to document yet or not\n     * @type {boolean}\n     */\n\n    _this.listenersBound = false;\n    _this.eventOptions = {\n      ignoreEventsCondition: Configuration.option('ignoreEventsCondition')\n    };\n    /**\n     * Dictionary of listener functions - currently only intended to house\n     * keyCombinationListener\n     */\n\n    _this.listeners = {};\n    return _this;\n  }\n  /********************************************************************************\n   * Enabling key maps and handlers\n   ********************************************************************************/\n\n  /**\n   * Registers the actions and handlers of a HotKeys component that has mounted\n   * @param {ComponentId} componentId - Id of the component that the keyMap belongs to\n   * @param {KeyMap} actionNameToKeyMap - Map of actions to key expressions\n   * @param {HandlersMap} actionNameToHandlersMap - Map of actions to handler functions\n   * @param {Object} options Hash of options that configure how the actions\n   *        and handlers are associated and called.\n   * @param {Object} eventOptions - Options for how the event should be handled\n   */\n\n\n  _createClass(GlobalKeyEventStrategy, [{\n    key: \"enableHotKeys\",\n    value: function enableHotKeys(componentId) {\n      var actionNameToKeyMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var actionNameToHandlersMap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var options = arguments.length > 3 ? arguments[3] : undefined;\n      var eventOptions = arguments.length > 4 ? arguments[4] : undefined;\n      this.eventOptions = eventOptions;\n\n      this._addComponent(componentId, actionNameToKeyMap, actionNameToHandlersMap, options);\n\n      this._updateDocumentHandlers();\n      /**\n       * Reset handler resolution state\n       */\n\n\n      this._initHandlerResolutionState();\n\n      this.logger.debug(this._logPrefix(componentId, {\n        eventId: false\n      }), 'Mounted.');\n      this.logger.verbose(this._logPrefix(componentId, {\n        eventId: false\n      }), 'Component options: \\n', printComponent(this.componentList.get(componentId)));\n    }\n    /**\n     * Handles when a mounted global HotKeys component updates its props and changes\n     * either the keyMap or handlers prop value\n     * @param {ComponentId} componentId - The component index of the component to\n     *        update\n     * @param {KeyMap} actionNameToKeyMap - Map of actions to key expressions\n     * @param {HandlersMap} actionNameToHandlersMap - Map of actions to handler functions\n     * @param {Object} options Hash of options that configure how the actions\n     *        and handlers are associated and called.\n     * @param {Object} eventOptions - Options for how the event should be handled\n     */\n\n  }, {\n    key: \"updateEnabledHotKeys\",\n    value: function updateEnabledHotKeys(componentId) {\n      var actionNameToKeyMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var actionNameToHandlersMap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var options = arguments.length > 3 ? arguments[3] : undefined;\n      var eventOptions = arguments.length > 4 ? arguments[4] : undefined;\n      this.eventOptions = eventOptions;\n      this.componentList.update(componentId, actionNameToKeyMap, actionNameToHandlersMap, options);\n      this.getKeyHistory().setMaxLength(this.componentList.getLongestSequence());\n      /**\n       * Reset strategy state specific to the global strategy\n       */\n\n      this._updateDocumentHandlers();\n      /**\n       * Reset handler resolution state\n       */\n\n\n      this._initHandlerResolutionState();\n\n      this.logger.debug(this._logPrefix(componentId, {\n        eventId: false\n      }), \"Global component \".concat(componentId, \" updated.\"));\n      this.logger.verbose(this._logPrefix(componentId, {\n        eventId: false\n      }), 'Component options: \\n', printComponent(this.componentList.get(componentId)));\n    }\n    /**\n     * Handles when a component is unmounted\n     * @param {ComponentId} componentId - Index of component that is being unmounted\n     */\n\n  }, {\n    key: \"disableHotKeys\",\n    value: function disableHotKeys(componentId) {\n      /**\n       * Manually update the registered key map state, usually reset using\n       * _resetRegisteredKeyMapsState() method\n       */\n      this.componentList.remove(componentId);\n      this.getKeyHistory().setMaxLength(this.componentList.getLongestSequence());\n\n      this._updateDocumentHandlers();\n      /**\n       * Reset handler resolution state\n       */\n\n\n      this._initHandlerResolutionState();\n\n      this.logger.debug(this._logPrefix(componentId, {\n        eventId: false\n      }), \"Unmounted global component \".concat(componentId));\n    }\n  }, {\n    key: \"_updateDocumentHandlers\",\n    value: function _updateDocumentHandlers() {\n      var _this2 = this;\n\n      var listenersShouldBeBound = this._listenersShouldBeBound();\n\n      if (!this.listenersBound && listenersShouldBeBound) {\n        Object.values(KeyEventType).forEach(function (recordIndex) {\n          var eventName = describeKeyEventType(recordIndex);\n\n          document[\"on\".concat(eventName)] = function (keyEvent) {\n            _this2.keyEventManager[\"handleGlobal\".concat(normalizeEventName(eventName))](keyEvent);\n          };\n\n          _this2.logger.debug(_this2._logPrefix(_this2.componentId, {\n            eventId: false\n          }), \"Bound handler handleGlobal\".concat(normalizeEventName(eventName), \"() to document.on\").concat(eventName, \"()\"));\n        });\n        this.listenersBound = true;\n      } else if (this.listenersBound && !listenersShouldBeBound) {\n        Object.values(KeyEventType).forEach(function (recordIndex) {\n          var eventName = describeKeyEventType(recordIndex);\n          delete document[\"on\".concat(eventName)];\n\n          _this2.logger.debug(_this2._logPrefix(_this2.componentId, {\n            eventId: false\n          }), \"Removed handler handleGlobal\".concat(normalizeEventName(eventName), \"() from document.on\").concat(eventName, \"()\"));\n        });\n        this.listenersBound = false;\n      }\n    }\n    /**\n     * Whether the document listeners should be bound, to record key events. Basically a check\n     * to see if there are any global key maps, or whether the user is currently rebinding to\n     * a new key combination.\n     * @returns {boolean} True if the document listeners should be bound\n     * @private\n     */\n\n  }, {\n    key: \"_listenersShouldBeBound\",\n    value: function _listenersShouldBeBound() {\n      return this.componentList.any() || this.listeners.keyCombination;\n    }\n    /********************************************************************************\n     * Recording key events\n     ********************************************************************************/\n\n    /**\n     * Records a keydown keyboard event and matches it against the list of pre-registered\n     * event handlers, calling the first matching handler with the highest priority if\n     * one exists.\n     *\n     * This method is called once when a keyboard event bubbles up to document, and checks\n     * the keymaps for all of the mounted global HotKey components.\n     * @param {KeyboardEvent} event - Event containing the key name and state\n     */\n\n  }, {\n    key: \"handleKeydown\",\n    value: function handleKeydown(event) {\n      var _key = getKeyName(event);\n\n      if (event.repeat && Configuration.option('ignoreRepeatedEventsWhenKeyHeldDown')) {\n        this.logger.debug(this._logPrefix(), \"Ignored repeated \".concat(describeKeyEvent(event, _key, KeyEventType.keydown), \" event.\"));\n        return true;\n      }\n\n      this._checkForModifierFlagDiscrepancies(event, _key, KeyEventType.keydown);\n\n      var reactAppResponse = this._howReactAppRespondedTo(event, _key, KeyEventType.keydown);\n\n      if (reactAppResponse === EventResponse.unseen && this.eventOptions.ignoreEventsCondition(event)) {\n        this.logger.debug(this._logPrefix(), \"Ignored \".concat(describeKeyEvent(event, _key, KeyEventType.keydown), \" event because ignoreEventsFilter rejected it.\"));\n        return;\n      }\n\n      if (reactAppResponse !== EventResponse.ignored) {\n        var keyEventState = stateFromEvent(event);\n        var currentCombination = this.getCurrentCombination();\n\n        if (currentCombination.isKeyIncluded(_key) || currentCombination.isEnding()) {\n          this._startAndLogNewKeyCombination(_key, keyEventState);\n        } else {\n          this._addToAndLogCurrentKeyCombination(_key, KeyEventType.keydown, keyEventState);\n        }\n      }\n\n      if (!contains([EventResponse.ignored, EventResponse.handled], reactAppResponse)) {\n        this._callHandlerIfExists(event, _key, KeyEventType.keydown);\n      }\n\n      this._simulateKeyPressForNonPrintableKeys(event, _key);\n    }\n  }, {\n    key: \"_howReactAppRespondedTo\",\n    value: function _howReactAppRespondedTo(event, key, keyEventType) {\n      var reactAppHistoryWithEvent = this.keyEventManager.reactAppHistoryWithEvent(key, keyEventType);\n\n      switch (reactAppHistoryWithEvent) {\n        case EventResponse.handled:\n          this.logger.debug(this._logPrefix(), \"Ignored \".concat(describeKeyEvent(event, key, keyEventType), \" event because React app has already handled it.\"));\n          break;\n\n        case EventResponse.ignored:\n          this.logger.debug(this._logPrefix(), \"Ignored \".concat(describeKeyEvent(event, key, keyEventType), \" event because React app has declared it should be ignored.\"));\n          break;\n\n        case EventResponse.seen:\n          this.logger.debug(this._logPrefix(), \"Received \".concat(describeKeyEvent(event, key, keyEventType), \" event (that has already passed through React app).\"));\n          break;\n\n        default:\n          KeyEventCounter.incrementId();\n          this.logger.debug(this._logPrefix(), \"New \".concat(describeKeyEvent(event, key, keyEventType), \" event (that has NOT passed through React app).\"));\n      }\n\n      return reactAppHistoryWithEvent;\n    }\n    /**\n     * Records a keypress keyboard event and matches it against the list of pre-registered\n     * event handlers, calling the first matching handler with the highest priority if\n     * one exists.\n     *\n     * This method is called once when a keyboard event bubbles up to document, and checks\n     * the keymaps for all of the mounted global HotKey components.\n     * @param {KeyboardEvent} event - Event containing the key name and state\n     */\n\n  }, {\n    key: \"handleKeyPress\",\n    value: function handleKeyPress(event) {\n      var key = getKeyName(event);\n\n      if (event.repeat && Configuration.option('ignoreRepeatedEventsWhenKeyHeldDown')) {\n        this.logger.debug(this._logPrefix(), \"Ignored repeated \".concat(describeKeyEvent(event, key, KeyEventType.keypress), \" event.\"));\n        return true;\n      }\n\n      var currentCombination = this.getCurrentCombination();\n\n      if (currentCombination.isKeyPressSimulated(key)) {\n        this.logger.debug(this._logPrefix(), \"Ignored \".concat(describeKeyEvent(event, key, KeyEventType.keypress), \" as it was not expected, and has already been simulated.\"));\n        return true;\n      }\n      /**\n       * We first decide if the keypress event should be handled (to ensure the correct\n       * order of logging statements)\n       */\n\n\n      var reactAppResponse = this._howReactAppRespondedTo(event, key, KeyEventType.keypress);\n      /**\n       * Add new key event to key combination history\n       */\n\n\n      if (currentCombination.isKeyIncluded(key)) {\n        this._addToAndLogCurrentKeyCombination(key, KeyEventType.keypress, stateFromEvent(event));\n      }\n\n      if (reactAppResponse === EventResponse.unseen) {\n        /**\n         * If the key event has not been seen by the React application, we ensure that\n         * it's not still waiting for it. This occurs when action handlers bound to keydown\n         * move the focus outside of the react app before it can record the keypress or\n         * keyup\n         */\n        this.keyEventManager.closeHangingKeyCombination(key, KeyEventType.keypress);\n\n        if (this.eventOptions.ignoreEventsCondition(event)) {\n          this.logger.debug(this._logPrefix(), \"Ignored \".concat(describeKeyEvent(event, key, KeyEventType.keypress), \" event because ignoreEventsFilter rejected it.\"));\n          return;\n        }\n      }\n\n      if (!contains([EventResponse.ignored, EventResponse.handled], reactAppResponse)) {\n        this._callHandlerIfExists(event, key, KeyEventType.keypress);\n      }\n    }\n    /**\n     * Records a keyup keyboard event and matches it against the list of pre-registered\n     * event handlers, calling the first matching handler with the highest priority if\n     * one exists.\n     *\n     * This method is called once when a keyboard event bubbles up to document, and checks\n     * the keymaps for all of the mounted global HotKey components.\n     * @param {KeyboardEvent} event - Event containing the key name and state\n     */\n\n  }, {\n    key: \"handleKeyUp\",\n    value: function handleKeyUp(event) {\n      var key = getKeyName(event);\n      var currentCombination = this.getCurrentCombination();\n\n      if (currentCombination.isKeyUpSimulated(key)) {\n        this.logger.debug(this._logPrefix(), \"Ignored \".concat(describeKeyEvent(event, key, KeyEventType.keyup), \" as it was not expected, and has already been simulated.\"));\n        return true;\n      }\n      /**\n       * We first decide if the keyup event should be handled (to ensure the correct\n       * order of logging statements)\n       */\n\n\n      var reactAppResponse = this._howReactAppRespondedTo(event, key, KeyEventType.keyup);\n      /**\n       * We then add the keyup to our current combination - regardless of whether\n       * it's to be handled or not. We need to do this to ensure that if a handler\n       * function changes focus to a context that ignored events, the keyup event\n       * is not lost (leaving react hotkeys thinking the key is still pressed).\n       */\n\n\n      if (currentCombination.isKeyIncluded(key)) {\n        this._addToAndLogCurrentKeyCombination(key, KeyEventType.keyup, stateFromEvent(event));\n      }\n\n      if (reactAppResponse === EventResponse.unseen) {\n        /**\n         * If the key event has not been seen by the React application, we ensure that\n         * it's not still waiting for it. This occurs when action handlers bound to keydown\n         * or keypress move the focus outside of the react app before it can record the keyup\n         */\n        this.keyEventManager.closeHangingKeyCombination(key, KeyEventType.keyup);\n\n        if (this.eventOptions.ignoreEventsCondition(event)) {\n          this.logger.debug(this._logPrefix(), \"Ignored \".concat(describeKeyEvent(event, key, KeyEventType.keyup), \" event because ignoreEventsFilter rejected it.\"));\n        } else {\n          /**\n           * We attempt to find a handler of the event, only if it has not already\n           * been handled and should not be ignored\n           */\n          if (!contains([EventResponse.ignored, EventResponse.handled], reactAppResponse)) {\n            this._callHandlerIfExists(event, key, KeyEventType.keyup);\n          }\n        }\n      } else {\n        /**\n         * We attempt to find a handler of the event, only if it has not already\n         * been handled and should not be ignored\n         */\n        if (!contains([EventResponse.ignored, EventResponse.handled], reactAppResponse)) {\n          this._callHandlerIfExists(event, key, KeyEventType.keyup);\n        }\n      }\n      /**\n       * We simulate any hidden keyup events hidden by the command key, regardless\n       * of whether the event should be ignored or not\n       */\n\n\n      this._simulateKeyUpEventsHiddenByCmd(event, key);\n\n      if (this.listeners.keyCombination && this._allKeysAreReleased()) {\n        this.listeners.keyCombination({\n          keys: currentCombination.getKeyDictionary(),\n          id: currentCombination.describe()\n        });\n      }\n    }\n  }, {\n    key: \"_simulateKeyPressForNonPrintableKeys\",\n    value: function _simulateKeyPressForNonPrintableKeys(event, key) {\n      this.keyEventManager.simulatePendingKeyPressEvents();\n\n      this._handleEventSimulation('handleKeyPress', this._shouldSimulate(KeyEventType.keypress, key), {\n        event: event,\n        key: key\n      });\n    }\n  }, {\n    key: \"_simulateKeyUpEventsHiddenByCmd\",\n    value: function _simulateKeyUpEventsHiddenByCmd(event, key) {\n      var _this3 = this;\n\n      if (isCmdKey(key)) {\n        /**\n         * We simulate pending key events in the React app before we do it globally\n         */\n        this.keyEventManager.simulatePendingKeyUpEvents();\n        this.getCurrentCombination().forEachKey(function (keyName) {\n          if (isCmdKey(keyName)) {\n            return;\n          }\n\n          _this3._handleEventSimulation('handleKeyUp', _this3._shouldSimulate(KeyEventType.keyup, keyName), {\n            event: event,\n            key: keyName\n          });\n        });\n      }\n    }\n  }, {\n    key: \"_startAndLogNewKeyCombination\",\n    value: function _startAndLogNewKeyCombination(keyName, keyEventState) {\n      this.getKeyHistory().startNewKeyCombination(keyName, keyEventState);\n      this.logger.verbose(this._logPrefix(), \"Started a new combination with '\".concat(keyName, \"'.\"));\n      this.logger.verbose(this._logPrefix(), \"Key history: \".concat(printComponent(this.getKeyHistory().toJSON()), \".\"));\n    }\n  }, {\n    key: \"_addToAndLogCurrentKeyCombination\",\n    value: function _addToAndLogCurrentKeyCombination(keyName, keyEventType, keyEventState) {\n      this.getKeyHistory().addKeyToCurrentCombination(keyName, keyEventType, keyEventState);\n\n      if (keyEventType === KeyEventType.keydown) {\n        this.logger.verbose(this._logPrefix(), \"Added '\".concat(keyName, \"' to current combination: '\").concat(this.getCurrentCombination().describe(), \"'.\"));\n      }\n\n      this.logger.verbose(this._logPrefix(), \"Key history: \".concat(printComponent(this.getKeyHistory().toJSON()), \".\"));\n    }\n    /********************************************************************************\n     * Event simulation\n     ********************************************************************************/\n\n  }, {\n    key: \"_handleEventSimulation\",\n    value: function _handleEventSimulation(handlerName, shouldSimulate, _ref) {\n      var event = _ref.event,\n          key = _ref.key;\n\n      if (shouldSimulate && Configuration.option('simulateMissingKeyPressEvents')) {\n        /**\n         * If a key does not have a keypress event, we simulate one immediately after\n         * the keydown event, to keep the behaviour consistent across all keys\n         */\n        var _event = this._cloneAndMergeEvent(event, {\n          key: key,\n          simulated: true\n        });\n\n        this[handlerName](_event);\n      }\n    }\n    /********************************************************************************\n     * Matching and calling handlers\n     ********************************************************************************/\n\n  }, {\n    key: \"_callHandlerIfExists\",\n    value: function _callHandlerIfExists(event, keyName, keyEventType) {\n      var eventName = describeKeyEventType(keyEventType);\n      var combinationName = this.getCurrentCombination().describe();\n\n      if (!this.componentList.anyActionsForEventType(keyEventType)) {\n        /**\n         * If there are no handlers registered for the particular key event type\n         * (keydown, keypress, keyup) then skip trying to find a matching handler\n         * for the current key combination\n         */\n        this.logger.debug(this._logPrefix(), \"Ignored '\".concat(combinationName, \"' \").concat(eventName, \" because it doesn't have any \").concat(eventName, \" handlers.\"));\n        return;\n      }\n      /**\n       * If there is at least one handler for the specified key event type (keydown,\n       * keypress, keyup), then attempt to find a handler that matches the current\n       * key combination\n       */\n\n\n      this.logger.verbose(this._logPrefix(), \"Attempting to find action matching '\".concat(combinationName, \"' \").concat(eventName, \" . . .\"));\n\n      this._callClosestMatchingHandler(event, keyName, keyEventType);\n    }\n  }, {\n    key: \"_callClosestMatchingHandler\",\n    value: function _callClosestMatchingHandler(event, keyName, keyEventType) {\n      var componentListIterator = this.componentList.getNewIterator();\n\n      while (componentListIterator.next()) {\n        var matchFound = _get(_getPrototypeOf(GlobalKeyEventStrategy.prototype), \"_callClosestMatchingHandler\", this).call(this, event, keyName, keyEventType, componentListIterator.getPosition(), 0);\n\n        if (matchFound) {\n          this.logger.debug(this._logPrefix(), \"Searching no further, as handler has been found (and called).\");\n          return;\n        }\n      }\n    }\n  }, {\n    key: \"_stopEventPropagation\",\n    value: function _stopEventPropagation(event, componentId) {\n      this.logger.debug(this._logPrefix(componentId), 'Stopping further event propagation.');\n\n      if (!event.simulated) {\n        event.stopPropagation();\n      }\n    }\n    /********************************************************************************\n     * Recording key combination\n     ********************************************************************************/\n\n    /**\n     * Add a new key combination listener function to be called the next time a key\n     * combination completes (assuming the cancel function is not called).\n     * @param {keyCombinationListener} callbackFunction Function to call with the next\n     *        completed key combination\n     * @returns {function} Function to call to cancel listening for the next key\n     *        combination\n     */\n\n  }, {\n    key: \"addKeyCombinationListener\",\n    value: function addKeyCombinationListener(callbackFunction) {\n      var _this4 = this;\n\n      var cancel = function cancel() {\n        delete _this4.listeners.keyCombination;\n      };\n\n      this.listeners.keyCombination = function (keyCombination) {\n        callbackFunction(keyCombination);\n        cancel();\n      };\n\n      this._updateDocumentHandlers();\n\n      return cancel;\n    }\n    /********************************************************************************\n     * Logging\n     ********************************************************************************/\n\n  }, {\n    key: \"_logPrefix\",\n    value: function _logPrefix(componentId) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var eventIcons = Logger.eventIcons;\n      var componentIcons = Logger.componentIcons;\n      var base = 'HotKeys (GLOBAL';\n\n      if (options.eventId !== false) {\n        var eventId = isUndefined(options.eventId) ? KeyEventCounter.getId() : options.eventId;\n        base = \"\".concat(base, \"-E\").concat(eventId).concat(eventIcons[eventId % eventIcons.length]);\n      }\n\n      if (isUndefined(componentId)) {\n        return \"\".concat(base, \"):\");\n      } else {\n        return \"\".concat(base, \"-C\").concat(componentId).concat(componentIcons[componentId % componentIcons.length], \"):\");\n      }\n    }\n  }]);\n\n  return GlobalKeyEventStrategy;\n}(AbstractKeyEventStrategy);\n\nexport default GlobalKeyEventStrategy;"]},"metadata":{},"sourceType":"module"}