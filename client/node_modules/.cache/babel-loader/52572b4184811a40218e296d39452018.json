{"ast":null,"code":"var _jsxFileName = \"/Users/yan/Documents/proj/ML4GIS/client/src/annotateComponents/RegionShapes/index.js\";\nimport React, { memo } from \"react\";\nimport colorAlpha from \"color-alpha\";\n\nfunction clamp(num, min, max) {\n  return num <= min ? min : num >= max ? max : num;\n}\n\nconst RegionComponents = {\n  point: memo(({\n    region,\n    iw,\n    ih\n  }) => /*#__PURE__*/React.createElement(\"g\", {\n    transform: \"translate(\".concat(region.x * iw, \" \").concat(region.y * ih, \")\"),\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 12,\n      columnNumber: 5\n    }\n  }, /*#__PURE__*/React.createElement(\"path\", {\n    d: \"M0 8L8 0L0 -8L-8 0Z\",\n    strokeWidth: 2,\n    stroke: region.color,\n    fill: \"transparent\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 13,\n      columnNumber: 7\n    }\n  }))),\n  rectangle: memo(({\n    region,\n    iw,\n    ih\n  }) => /*#__PURE__*/React.createElement(\"g\", {\n    transform: \"translate(\".concat(region.x * iw, \" \").concat(region.y * ih, \")\"),\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 22,\n      columnNumber: 5\n    }\n  }, /*#__PURE__*/React.createElement(\"rect\", {\n    strokeWidth: 2,\n    x: 0,\n    y: 0,\n    width: Math.max(region.w * iw, 0),\n    height: Math.max(region.h * ih, 0),\n    stroke: colorAlpha(region.color, 0.75),\n    fill: colorAlpha(region.color, 0.25),\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 23,\n      columnNumber: 7\n    }\n  }))),\n  polygon: memo(({\n    region,\n    iw,\n    ih,\n    fullSegmentationMode\n  }) => {\n    const Component = region.open ? \"polyline\" : \"polygon\";\n    const alphaBase = fullSegmentationMode ? 0.5 : 1;\n    return /*#__PURE__*/React.createElement(Component, {\n      points: region.points.map(([x, y]) => [x * iw, y * ih]).map(a => a.join(\" \")).join(\" \"),\n      strokeWidth: 2,\n      stroke: colorAlpha(region.color, 0.75),\n      fill: colorAlpha(region.color, 0.25),\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 38,\n        columnNumber: 7\n      }\n    });\n  }),\n  // keypoints: ({ region, iw, ih, keypointDefinitions }) => {\n  //   const { points, keypointsDefinitionId } = region\n  //   if (!keypointDefinitions[keypointsDefinitionId]) {\n  //     throw new Error(\n  //       `No definition for keypoint configuration \"${keypointsDefinitionId}\"`\n  //     )\n  //   }\n  //   const { landmarks, connections } = keypointDefinitions[\n  //     keypointsDefinitionId\n  //   ]\n  //   return (\n  //     <g>\n  //       {Object.entries(points).map(([keypointId, { x, y }], i) => (\n  //         <g key={i} transform={`translate(${x * iw} ${y * ih})`}>\n  //           <path\n  //             d={\"M0 8L8 0L0 -8L-8 0Z\"}\n  //             strokeWidth={2}\n  //             stroke={landmarks[keypointId].color}\n  //             fill=\"transparent\"\n  //           />\n  //         </g>\n  //       ))}\n  //       {connections.map(([kp1Id, kp2Id]) => {\n  //         const kp1 = points[kp1Id]\n  //         const kp2 = points[kp2Id]\n  //         const midPoint = { x: (kp1.x + kp2.x) / 2, y: (kp1.y + kp2.y) / 2 }\n  //\n  //         return (\n  //           <g key={`${kp1.x},${kp1.y}.${kp2.x},${kp2.y}`}>\n  //             <line\n  //               x1={kp1.x * iw}\n  //               y1={kp1.y * ih}\n  //               x2={midPoint.x * iw}\n  //               y2={midPoint.y * ih}\n  //               strokeWidth={2}\n  //               stroke={landmarks[kp1Id].color}\n  //             />\n  //             <line\n  //               x1={kp2.x * iw}\n  //               y1={kp2.y * ih}\n  //               x2={midPoint.x * iw}\n  //               y2={midPoint.y * ih}\n  //               strokeWidth={2}\n  //               stroke={landmarks[kp2Id].color}\n  //             />\n  //           </g>\n  //         )\n  //       })}\n  //     </g>\n  //   )\n  // },\n  pixel: () => null\n};\nexport const WrappedRegionList = memo(({\n  regions,\n  keypointDefinitions,\n  iw,\n  ih,\n  fullSegmentationMode\n}) => {\n  return regions.filter(r => r.visible !== false).map(r => {\n    const Component = RegionComponents[r.type];\n    return /*#__PURE__*/React.createElement(Component, {\n      key: r.regionId,\n      region: r,\n      iw: iw,\n      ih: ih // keypointDefinitions={keypointDefinitions}\n      // fullSegmentationMode={fullSegmentationMode}\n      ,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 111,\n        columnNumber: 11\n      }\n    });\n  });\n}, (n, p) => n.regions === p.regions && n.iw === p.iw && n.ih === p.ih);\nexport const RegionShapes = ({\n  mat,\n  imagePosition,\n  regions = [] // keypointDefinitions,\n  // fullSegmentationMode,\n\n}) => {\n  const iw = imagePosition.bottomRight.x - imagePosition.topLeft.x;\n  const ih = imagePosition.bottomRight.y - imagePosition.topLeft.y;\n  if (isNaN(iw) || isNaN(ih)) return null;\n  return /*#__PURE__*/React.createElement(\"svg\", {\n    width: iw,\n    height: ih,\n    style: {\n      position: \"absolute\",\n      zIndex: 2,\n      left: imagePosition.topLeft.x,\n      top: imagePosition.topLeft.y,\n      pointerEvents: \"none\",\n      width: iw,\n      height: ih\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 136,\n      columnNumber: 5\n    }\n  }, /*#__PURE__*/React.createElement(WrappedRegionList, {\n    key: \"wrapped-region-list\",\n    regions: regions,\n    iw: iw,\n    ih: ih // keypointDefinitions={keypointDefinitions}\n    // fullSegmentationMode={fullSegmentationMode}\n    ,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 149,\n      columnNumber: 7\n    }\n  }));\n};\nexport default RegionShapes;","map":{"version":3,"sources":["/Users/yan/Documents/proj/ML4GIS/client/src/annotateComponents/RegionShapes/index.js"],"names":["React","memo","colorAlpha","clamp","num","min","max","RegionComponents","point","region","iw","ih","x","y","color","rectangle","Math","w","h","polygon","fullSegmentationMode","Component","open","alphaBase","points","map","a","join","pixel","WrappedRegionList","regions","keypointDefinitions","filter","r","visible","type","regionId","n","p","RegionShapes","mat","imagePosition","bottomRight","topLeft","isNaN","position","zIndex","left","top","pointerEvents","width","height"],"mappings":"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","sourcesContent":["// @flow\n\nimport React, { memo } from \"react\"\nimport colorAlpha from \"color-alpha\"\n\nfunction clamp(num, min, max) {\n  return num <= min ? min : num >= max ? max : num\n}\n\nconst RegionComponents = {\n  point: memo(({ region, iw, ih }) => (\n    <g transform={`translate(${region.x * iw} ${region.y * ih})`}>\n      <path\n        d={\"M0 8L8 0L0 -8L-8 0Z\"}\n        strokeWidth={2}\n        stroke={region.color}\n        fill=\"transparent\"\n      />\n    </g>\n  )),\n    rectangle: memo(({ region, iw, ih }) => (\n    <g transform={`translate(${region.x * iw} ${region.y * ih})`}>\n      <rect\n        strokeWidth={2}\n        x={0}\n        y={0}\n        width={Math.max(region.w * iw, 0)}\n        height={Math.max(region.h * ih, 0)}\n        stroke={colorAlpha(region.color, 0.75)}\n        fill={colorAlpha(region.color, 0.25)}\n      />\n    </g>\n  )),\n  polygon: memo(({ region, iw, ih, fullSegmentationMode }) => {\n    const Component = region.open ? \"polyline\" : \"polygon\"\n    const alphaBase = fullSegmentationMode ? 0.5 : 1\n    return (\n      <Component\n        points={region.points\n          .map(([x, y]) => [x * iw, y * ih])\n          .map((a) => a.join(\" \"))\n          .join(\" \")}\n        strokeWidth={2}\n        stroke={colorAlpha(region.color, 0.75)}\n        fill={colorAlpha(region.color, 0.25)}\n      />\n    )\n  }),\n  // keypoints: ({ region, iw, ih, keypointDefinitions }) => {\n  //   const { points, keypointsDefinitionId } = region\n  //   if (!keypointDefinitions[keypointsDefinitionId]) {\n  //     throw new Error(\n  //       `No definition for keypoint configuration \"${keypointsDefinitionId}\"`\n  //     )\n  //   }\n  //   const { landmarks, connections } = keypointDefinitions[\n  //     keypointsDefinitionId\n  //   ]\n  //   return (\n  //     <g>\n  //       {Object.entries(points).map(([keypointId, { x, y }], i) => (\n  //         <g key={i} transform={`translate(${x * iw} ${y * ih})`}>\n  //           <path\n  //             d={\"M0 8L8 0L0 -8L-8 0Z\"}\n  //             strokeWidth={2}\n  //             stroke={landmarks[keypointId].color}\n  //             fill=\"transparent\"\n  //           />\n  //         </g>\n  //       ))}\n  //       {connections.map(([kp1Id, kp2Id]) => {\n  //         const kp1 = points[kp1Id]\n  //         const kp2 = points[kp2Id]\n  //         const midPoint = { x: (kp1.x + kp2.x) / 2, y: (kp1.y + kp2.y) / 2 }\n  //\n  //         return (\n  //           <g key={`${kp1.x},${kp1.y}.${kp2.x},${kp2.y}`}>\n  //             <line\n  //               x1={kp1.x * iw}\n  //               y1={kp1.y * ih}\n  //               x2={midPoint.x * iw}\n  //               y2={midPoint.y * ih}\n  //               strokeWidth={2}\n  //               stroke={landmarks[kp1Id].color}\n  //             />\n  //             <line\n  //               x1={kp2.x * iw}\n  //               y1={kp2.y * ih}\n  //               x2={midPoint.x * iw}\n  //               y2={midPoint.y * ih}\n  //               strokeWidth={2}\n  //               stroke={landmarks[kp2Id].color}\n  //             />\n  //           </g>\n  //         )\n  //       })}\n  //     </g>\n  //   )\n  // },\n \n  pixel: () => null,\n}\n\nexport const WrappedRegionList = memo(\n  ({ regions, keypointDefinitions, iw, ih, fullSegmentationMode }) => {\n    return regions\n      .filter((r) => r.visible !== false)\n      .map((r) => {\n        const Component = RegionComponents[r.type]\n        return (\n          <Component\n            key={r.regionId}\n            region={r}\n            iw={iw}\n            ih={ih}\n            // keypointDefinitions={keypointDefinitions}\n            // fullSegmentationMode={fullSegmentationMode}\n          />\n        )\n      })\n  },\n  (n, p) => n.regions === p.regions && n.iw === p.iw && n.ih === p.ih\n)\n\nexport const RegionShapes = ({\n  mat,\n  imagePosition,\n  regions = [],\n  // keypointDefinitions,\n  // fullSegmentationMode,\n}) => {\n  const iw = imagePosition.bottomRight.x - imagePosition.topLeft.x\n  const ih = imagePosition.bottomRight.y - imagePosition.topLeft.y\n  if (isNaN(iw) || isNaN(ih)) return null\n  return (\n    <svg\n      width={iw}\n      height={ih}\n      style={{\n        position: \"absolute\",\n        zIndex: 2,\n        left: imagePosition.topLeft.x,\n        top: imagePosition.topLeft.y,\n        pointerEvents: \"none\",\n        width: iw,\n        height: ih,\n      }}\n    >\n      <WrappedRegionList\n        key=\"wrapped-region-list\"\n        regions={regions}\n        iw={iw}\n        ih={ih}\n        // keypointDefinitions={keypointDefinitions}\n        // fullSegmentationMode={fullSegmentationMode}\n      />\n    </svg>\n  )\n}\n\nexport default RegionShapes\n"]},"metadata":{},"sourceType":"module"}