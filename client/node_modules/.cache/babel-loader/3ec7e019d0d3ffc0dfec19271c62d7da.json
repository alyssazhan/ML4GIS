{"ast":null,"code":"function _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport removeAtIndex from '../../utils/array/removeAtIndex';\nimport KeyEventStateArrayManager from '../shared/KeyEventStateArrayManager';\nimport Configuration from '../config/Configuration';\nimport KeyCombinationSerializer from '../shared/KeyCombinationSerializer';\nimport isObject from '../../utils/object/isObject';\nimport hasKey from '../../utils/object/hasKey';\nimport arrayFrom from '../../utils/array/arrayFrom';\nimport isUndefined from '../../utils/isUndefined';\nimport KeyEventType from '../../const/KeyEventType';\nimport KeySequenceParser from '../shared/KeySequenceParser';\nimport KeyEventState from '../../const/KeyEventState';\nimport ComponentOptionsListIterator from './ComponentOptionsListIterator';\n/**\r\n * @typedef {Object} ComponentOptions a hotkeys component's options in a normalized\r\n *          format\r\n * @property {ActionDictionary} actions The dictionary of actions defined by the\r\n *           component\r\n */\n\n/**\r\n * A mapping between ActionName and ActionConfiguration\r\n * @typedef {Object.<ActionName,ActionConfiguration>} ActionDictionary\r\n */\n\n/**\r\n * Standardized format for defining an action\r\n * @typedef {Object} ActionConfiguration\r\n * @property {NormalizedKeySequenceId} prefix - String describing the sequence of key\r\n *          combinations, before the final key combination (an empty string for\r\n *          sequences that are a single key combination)\r\n * @property {ActionName} actionName - Name of the action\r\n * @property {number} sequenceLength - Number of combinations involved in the\r\n *           sequence\r\n * @property {KeyCombinationString} id - Serialized description of the key combinations\r\n *            that make up the sequence\r\n * @property {Object.<KeyName, Boolean>} keyDictionary - Dictionary of key names involved\r\n *           in the last key combination of the sequence\r\n * @property {KeyEventType} keyEventType - Record index for key event that\r\n *          the matcher should match on\r\n * @property {number} size - Number of keys involved in the final key combination\r\n */\n\n/**\r\n * List of component options that define the application's currently enabled key\r\n * maps and handlers, starting from the inner-most (most deeply nested) component,\r\n * that is closest to the DOM element currently in focus, and ending with the options\r\n * of the root hotkeys component.\r\n * @class\r\n */\n\nvar ComponentOptionsList = /*#__PURE__*/function () {\n  function ComponentOptionsList() {\n    _classCallCheck(this, ComponentOptionsList);\n    /**\r\n     * List of ComponentOptions for the actions registered by each hot keys component.\r\n     * @type {ComponentOptions[]}\r\n     */\n\n\n    this._list = [];\n    /**\r\n     * Dictionary mapping the ids of the components defining actions, and their\r\n     * position in the list.\r\n     * @type {Object.<ComponentId, Number>}\r\n     */\n\n    this._idToIndex = {};\n    /**\r\n     * Counter for the length of the longest sequence currently enabled.\r\n     * @type {number}\r\n     */\n\n    this._longestSequence = 1;\n    /**\r\n     * The id of the component with the longest key sequence\r\n     * @type {ComponentId}\r\n     */\n\n    this._longestSequenceComponentId = null;\n    /**\r\n     * Record of whether at least one keymap is bound to each event type (keydown,\r\n     * keypress or keyup)\r\n     * @type {KeyEvent}\r\n     */\n\n    this._keyMapEventRecord = KeyEventStateArrayManager.newRecord();\n  }\n  /**\r\n   * Return a new iterator that can be used to enumerate the list\r\n   * @returns {ComponentOptionsListIterator}\r\n   */\n\n\n  _createClass(ComponentOptionsList, [{\n    key: \"getNewIterator\",\n    value: function getNewIterator() {\n      return new ComponentOptionsListIterator(this);\n    }\n    /**\r\n     * Adds a new hot key component's options, to be parsed and standardised before being\r\n     * added to the list\r\n     * @param {ComponentId} componentId - Id of the component the options belong to\r\n     * @param {KeyMap} actionNameToKeyMap - Map of actions to key maps\r\n     * @param {HandlersMap} actionNameToHandlersMap - Map of actions to handlers\r\n     * @param {Object} options - Hash of options that configure how the key map is built.\r\n     * @param {string} options.defaultKeyEvent - The default key event to use for any\r\n     *        action that does not explicitly define one.\r\n     * @returns {number} The position the component options have in the list\r\n     */\n\n  }, {\n    key: \"add\",\n    value: function add(componentId, actionNameToKeyMap, actionNameToHandlersMap, options) {\n      if (this.containsId(componentId)) {\n        return this.update(componentId, actionNameToKeyMap, actionNameToHandlersMap, options);\n      }\n\n      var componentOptions = this._build(componentId, actionNameToKeyMap, actionNameToHandlersMap, options);\n\n      this._list.push(componentOptions);\n\n      var newIndex = this._getLastIndex();\n\n      return this._idToIndex[componentId] = newIndex;\n    }\n    /**\r\n     * Whether the list contains options for a component with the specified id\r\n     * @param {ComponentId} id Id of the component\r\n     * @returns {boolean} True if the list contains options for the component with the\r\n     *        specified id\r\n     */\n\n  }, {\n    key: \"containsId\",\n    value: function containsId(id) {\n      return !!this.get(id);\n    }\n    /**\r\n     * Retrieves options for a component from the list\r\n     * @param {ComponentId} id Id of the component to retrieve the options for\r\n     * @returns {ComponentOptions} Options for the component with the specified id\r\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(id) {\n      return this.getAtPosition(this.getIndexById(id));\n    }\n    /**\r\n     * Returns the position of the options belonging to the component with the specified\r\n     * id.\r\n     * @param {ComponentId} id Id of the component to retrieve the options for\r\n     * @returns {number} The position of the component options in the list.\r\n     */\n\n  }, {\n    key: \"getIndexById\",\n    value: function getIndexById(id) {\n      return this._idToIndex[id];\n    }\n    /**\r\n     * Replaces the options of a component already in the list with new values\r\n     * @param {ComponentId} componentId - Id of the component to replace the options of\r\n     * @param {KeyMap} actionNameToKeyMap - Map of actions to key maps\r\n     * @param {HandlersMap} actionNameToHandlersMap - Map of actions to handlers\r\n     * @param {Object} options - Hash of options that configure how the key map is built.\r\n     * @param {string} options.defaultKeyEvent - The default key event to use for any\r\n     *        action that does not explicitly define one.\r\n     * @returns {number} The position the component options have in the list\r\n     */\n\n  }, {\n    key: \"update\",\n    value: function update(componentId, actionNameToKeyMap, actionNameToHandlersMap, options) {\n      /**\r\n       * We record whether we're building new options for the component that currently\r\n       * has the longest sequence, to decide whether we need to recalculate the longest\r\n       * sequence.\r\n       */\n      var isUpdatingLongestSequenceComponent = this._isUpdatingComponentWithLongestSequence(componentId);\n\n      var longestSequenceBefore = this.getLongestSequence();\n\n      var componentOptions = this._build(componentId, actionNameToKeyMap, actionNameToHandlersMap, options);\n\n      if (isUpdatingLongestSequenceComponent && componentOptions.sequenceLength !== longestSequenceBefore) {\n        /**\r\n         * Component with the longest sequence has just had new options registered\r\n         * so we need to reset the longest sequence\r\n         */\n        if (componentOptions.sequenceLength > longestSequenceBefore) {\n          /**\r\n           * The same component has registered a longer sequence, so we just\r\n           * need to update the sequence length to the new, larger number\r\n           */\n          this._longestSequence = componentOptions.sequenceLength;\n        } else {\n          /**\r\n           * The component may no longer have the longest sequence, so we need to\r\n           * recalculate\r\n           */\n          this._recalculateLongestSequence();\n        }\n      }\n\n      this._list[this.getIndexById(componentId)] = componentOptions;\n    }\n    /**\r\n     * Removes the options of a component from the list\r\n     * @param {ComponentId} id The id of the component whose options are removed\r\n     * @returns {void}\r\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove(id) {\n      var isUpdatingLongestSequenceComponent = this._isUpdatingComponentWithLongestSequence(id);\n\n      this.removeAtPosition(this.getIndexById(id));\n\n      if (isUpdatingLongestSequenceComponent) {\n        this._recalculateLongestSequence();\n      }\n    }\n    /**\r\n     * Whether the list has any options in it (non-empty)\r\n     * @returns {boolean} true if the list has one or more options in it\r\n     */\n\n  }, {\n    key: \"any\",\n    value: function any() {\n      return this.getLength() !== 0;\n    }\n    /**\r\n     * Whether a component is the root component (the last one in the list)\r\n     * @param {ComponentId} id Id of the component to query if it is the root\r\n     * @returns {boolean} true if the component is the last in the list\r\n     */\n\n  }, {\n    key: \"isRoot\",\n    value: function isRoot(id) {\n      return this.getIndexById(id) >= this.getLength() - 1;\n    }\n    /**\r\n     * The length of the longest sequence currently defined.\r\n     * @returns {number} The sequence length\r\n     */\n\n  }, {\n    key: \"getLongestSequence\",\n    value: function getLongestSequence() {\n      return this._longestSequence;\n    }\n    /**\r\n     * Whether the list contains at least one component with an action bound to a\r\n     * particular keyboard event type.\r\n     * @param {KeyEventType} keyEventType Index of the keyboard event type\r\n     * @returns {boolean} true when the list contains a component with an action bound\r\n     *          to the event type\r\n     */\n\n  }, {\n    key: \"anyActionsForEventType\",\n    value: function anyActionsForEventType(keyEventType) {\n      return !!this._keyMapEventRecord[keyEventType];\n    }\n    /**\r\n     * The number of components in the list\r\n     * @returns {number} Number of components in the list\r\n     */\n\n  }, {\n    key: \"getLength\",\n    value: function getLength() {\n      return this._list.length;\n    }\n    /**\r\n     * The component options at particular position in the list\r\n     * @param {number} position The position in the list\r\n     * @returns {ComponentOptions} The component options at the position in the list\r\n     */\n\n  }, {\n    key: \"getAtPosition\",\n    value: function getAtPosition(position) {\n      return this._list[position];\n    }\n    /**\r\n     * Remove the component options at a position in the list\r\n     * @param {number} position The position in the list to remove the options\r\n     * return {void}\r\n     */\n\n  }, {\n    key: \"removeAtPosition\",\n    value: function removeAtPosition(position) {\n      this._list = removeAtIndex(this._list, position);\n      var counter = position;\n\n      while (counter < this.getLength()) {\n        this._idToIndex[this.getAtPosition(counter).componentId] = counter;\n        counter++;\n      }\n    }\n    /**\r\n     * A plain JavaScript object representation of the component options list that can\r\n     * be used for serialization or debugging\r\n     * @returns {ComponentOptions[]} plain JavaScript object representation of the list\r\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return this._list;\n    }\n    /********************************************************************************\r\n     * Private methods\r\n     ********************************************************************************/\n\n  }, {\n    key: \"_getLastIndex\",\n    value: function _getLastIndex() {\n      return this.getLength() - 1;\n    }\n    /**\r\n     * Builds the internal representation that described the options passed to a hot keys\r\n     * component\r\n     * @param {ComponentId} componentId - Id of the component the options belong to\r\n     * @param {KeyMap} actionNameToKeyMap - Map of actions to key maps\r\n     * @param {HandlersMap} actionNameToHandlersMap - Map of actions to handlers\r\n     * @param {Object} options - Hash of options that configure how the key map is built.\r\n     * @returns {ComponentOptions} Options for the specified component\r\n     * @private\r\n     */\n\n  }, {\n    key: \"_build\",\n    value: function _build(componentId, actionNameToKeyMap, actionNameToHandlersMap, options) {\n      var _this$_applyHardSeque = this._applyHardSequences(actionNameToKeyMap, actionNameToHandlersMap),\n          hardSequenceKeyMap = _this$_applyHardSeque.keyMap,\n          includingHardSequenceHandlers = _this$_applyHardSeque.handlers;\n\n      var actions = this._buildActionDictionary(_objectSpread({}, actionNameToKeyMap, hardSequenceKeyMap), options, componentId);\n\n      return {\n        actions: actions,\n        handlers: includingHardSequenceHandlers,\n        componentId: componentId,\n        options: options\n      };\n    }\n  }, {\n    key: \"_isUpdatingComponentWithLongestSequence\",\n    value: function _isUpdatingComponentWithLongestSequence(componentId) {\n      return componentId === this._getLongestSequenceComponentId();\n    }\n  }, {\n    key: \"_getLongestSequenceComponentId\",\n    value: function _getLongestSequenceComponentId() {\n      return this._longestSequenceComponentId;\n    }\n  }, {\n    key: \"_recalculateLongestSequence\",\n    value: function _recalculateLongestSequence() {\n      var iterator = this.getNewIterator();\n\n      while (iterator.next()) {\n        var _iterator$getComponen = iterator.getComponent(),\n            longestSequence = _iterator$getComponen.longestSequence,\n            componentId = _iterator$getComponen.componentId;\n\n        if (longestSequence > this.getLongestSequence()) {\n          this._longestSequenceComponentId = componentId;\n          this._longestSequence = longestSequence;\n        }\n      }\n    }\n    /**\r\n     * Applies hard sequences (handlers attached to actions with names that are valid\r\n     * KeySequenceStrings) that implicitly define a corresponding action name.\r\n     * @param {KeyMap} actionNameToKeyMap - KeyMap specified by HotKeys component\r\n     * @param {HandlersMap} actionMap - HandlersMap specified by HotKeys component\r\n     * @returns {{keyMap: {}, handlers: {}}} Object containing keymap and handlers map\r\n     *        with the hard sequence actions applied\r\n     * @private\r\n     */\n\n  }, {\n    key: \"_applyHardSequences\",\n    value: function _applyHardSequences(actionNameToKeyMap, actionMap) {\n      if (Configuration.option('enableHardSequences')) {\n        return Object.keys(actionMap).reduce(function (memo, actionNameOrHardSequence) {\n          var actionNameIsInKeyMap = !!actionNameToKeyMap[actionNameOrHardSequence];\n\n          if (!actionNameIsInKeyMap && KeyCombinationSerializer.isValidKeySerialization(actionNameOrHardSequence)) {\n            memo.keyMap[actionNameOrHardSequence] = actionNameOrHardSequence;\n          }\n\n          memo.handlers[actionNameOrHardSequence] = actionMap[actionNameOrHardSequence];\n          return memo;\n        }, {\n          keyMap: {},\n          handlers: {}\n        });\n      } else {\n        return {\n          keyMap: actionNameToKeyMap,\n          handlers: actionMap\n        };\n      }\n    }\n    /**\r\n     * Returns a mapping between ActionNames and ActionConfiguration\r\n     * @param {KeyMap} actionNameToKeyMap - Mapping of ActionNames to key sequences.\r\n     * @param {Object} options - Hash of options that configure how the key map is built.\r\n     * @param {string} options.defaultKeyEvent - The default key event to use for any\r\n     *        action that does not explicitly define one.\r\n     * @param {ComponentId} componentId Index of the component the matcher belongs to\r\n     * @returns {ActionDictionary} Map from ActionNames to ActionConfiguration\r\n     * @private\r\n     */\n\n  }, {\n    key: \"_buildActionDictionary\",\n    value: function _buildActionDictionary(actionNameToKeyMap, options, componentId) {\n      var _this = this;\n\n      return Object.keys(actionNameToKeyMap).reduce(function (memo, actionName) {\n        var keyMapConfig = actionNameToKeyMap[actionName];\n\n        var keyMapOptions = function () {\n          if (isObject(keyMapConfig) && hasKey(keyMapConfig, 'sequences')) {\n            return arrayFrom(keyMapConfig.sequences);\n          } else {\n            return arrayFrom(keyMapConfig);\n          }\n        }();\n\n        keyMapOptions.forEach(function (keyMapOption) {\n          var _normalizeActionOptio = normalizeActionOptions(keyMapOption, options),\n              keySequence = _normalizeActionOptio.keySequence,\n              keyEventType = _normalizeActionOptio.keyEventType;\n\n          _this._addActionOptions(memo, componentId, actionName, keySequence, keyEventType);\n        });\n        return memo;\n      }, {});\n    }\n  }, {\n    key: \"_addActionOptions\",\n    value: function _addActionOptions(memo, componentId, actionName, keySequence, keyEventType) {\n      var _KeySequenceParser$pa = KeySequenceParser.parse(keySequence, {\n        keyEventType: keyEventType\n      }),\n          sequence = _KeySequenceParser$pa.sequence,\n          combination = _KeySequenceParser$pa.combination;\n\n      if (sequence.size > this.getLongestSequence()) {\n        this._longestSequence = sequence.size;\n        this._longestSequenceComponentId = componentId;\n      }\n      /**\r\n       * Record that there is at least one key sequence in the focus tree bound to\r\n       * the keyboard event\r\n       */\n\n\n      this._keyMapEventRecord[keyEventType] = KeyEventState.seen;\n\n      if (!memo[actionName]) {\n        memo[actionName] = [];\n      }\n\n      memo[actionName].push(_objectSpread({\n        prefix: sequence.prefix,\n        actionName: actionName,\n        sequenceLength: sequence.size\n      }, combination));\n    }\n  }]);\n\n  return ComponentOptionsList;\n}();\n\nfunction normalizeActionOptions(keyMapOption, options) {\n  if (isObject(keyMapOption)) {\n    var sequence = keyMapOption.sequence,\n        action = keyMapOption.action;\n    return {\n      keySequence: sequence,\n      keyEventType: isUndefined(action) ? KeyEventType[options.defaultKeyEvent] : KeyEventType[action]\n    };\n  } else {\n    return {\n      keySequence: keyMapOption,\n      keyEventType: KeyEventType[options.defaultKeyEvent]\n    };\n  }\n}\n\nexport default ComponentOptionsList;","map":{"version":3,"sources":["D:/GitHub/ML4GIS/client/node_modules/react-hotkeys/es/lib/definitions/ComponentOptionsList.js"],"names":["_objectSpread","target","i","arguments","length","source","ownKeys","Object","keys","getOwnPropertySymbols","concat","filter","sym","getOwnPropertyDescriptor","enumerable","forEach","key","_defineProperty","obj","value","defineProperty","configurable","writable","_classCallCheck","instance","Constructor","TypeError","_defineProperties","props","descriptor","_createClass","protoProps","staticProps","prototype","removeAtIndex","KeyEventStateArrayManager","Configuration","KeyCombinationSerializer","isObject","hasKey","arrayFrom","isUndefined","KeyEventType","KeySequenceParser","KeyEventState","ComponentOptionsListIterator","ComponentOptionsList","_list","_idToIndex","_longestSequence","_longestSequenceComponentId","_keyMapEventRecord","newRecord","getNewIterator","add","componentId","actionNameToKeyMap","actionNameToHandlersMap","options","containsId","update","componentOptions","_build","push","newIndex","_getLastIndex","id","get","getAtPosition","getIndexById","isUpdatingLongestSequenceComponent","_isUpdatingComponentWithLongestSequence","longestSequenceBefore","getLongestSequence","sequenceLength","_recalculateLongestSequence","remove","removeAtPosition","any","getLength","isRoot","anyActionsForEventType","keyEventType","position","counter","toJSON","_this$_applyHardSeque","_applyHardSequences","hardSequenceKeyMap","keyMap","includingHardSequenceHandlers","handlers","actions","_buildActionDictionary","_getLongestSequenceComponentId","iterator","next","_iterator$getComponen","getComponent","longestSequence","actionMap","option","reduce","memo","actionNameOrHardSequence","actionNameIsInKeyMap","isValidKeySerialization","_this","actionName","keyMapConfig","keyMapOptions","sequences","keyMapOption","_normalizeActionOptio","normalizeActionOptions","keySequence","_addActionOptions","_KeySequenceParser$pa","parse","sequence","combination","size","seen","prefix","action","defaultKeyEvent"],"mappings":"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","sourcesContent":["function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\r\n\r\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\r\n\r\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\r\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\r\n\r\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\r\n\r\nimport removeAtIndex from '../../utils/array/removeAtIndex';\r\nimport KeyEventStateArrayManager from '../shared/KeyEventStateArrayManager';\r\nimport Configuration from '../config/Configuration';\r\nimport KeyCombinationSerializer from '../shared/KeyCombinationSerializer';\r\nimport isObject from '../../utils/object/isObject';\r\nimport hasKey from '../../utils/object/hasKey';\r\nimport arrayFrom from '../../utils/array/arrayFrom';\r\nimport isUndefined from '../../utils/isUndefined';\r\nimport KeyEventType from '../../const/KeyEventType';\r\nimport KeySequenceParser from '../shared/KeySequenceParser';\r\nimport KeyEventState from '../../const/KeyEventState';\r\nimport ComponentOptionsListIterator from './ComponentOptionsListIterator';\r\n/**\r\n * @typedef {Object} ComponentOptions a hotkeys component's options in a normalized\r\n *          format\r\n * @property {ActionDictionary} actions The dictionary of actions defined by the\r\n *           component\r\n */\r\n\r\n/**\r\n * A mapping between ActionName and ActionConfiguration\r\n * @typedef {Object.<ActionName,ActionConfiguration>} ActionDictionary\r\n */\r\n\r\n/**\r\n * Standardized format for defining an action\r\n * @typedef {Object} ActionConfiguration\r\n * @property {NormalizedKeySequenceId} prefix - String describing the sequence of key\r\n *          combinations, before the final key combination (an empty string for\r\n *          sequences that are a single key combination)\r\n * @property {ActionName} actionName - Name of the action\r\n * @property {number} sequenceLength - Number of combinations involved in the\r\n *           sequence\r\n * @property {KeyCombinationString} id - Serialized description of the key combinations\r\n *            that make up the sequence\r\n * @property {Object.<KeyName, Boolean>} keyDictionary - Dictionary of key names involved\r\n *           in the last key combination of the sequence\r\n * @property {KeyEventType} keyEventType - Record index for key event that\r\n *          the matcher should match on\r\n * @property {number} size - Number of keys involved in the final key combination\r\n */\r\n\r\n/**\r\n * List of component options that define the application's currently enabled key\r\n * maps and handlers, starting from the inner-most (most deeply nested) component,\r\n * that is closest to the DOM element currently in focus, and ending with the options\r\n * of the root hotkeys component.\r\n * @class\r\n */\r\n\r\nvar ComponentOptionsList =\r\n/*#__PURE__*/\r\nfunction () {\r\n  function ComponentOptionsList() {\r\n    _classCallCheck(this, ComponentOptionsList);\r\n\r\n    /**\r\n     * List of ComponentOptions for the actions registered by each hot keys component.\r\n     * @type {ComponentOptions[]}\r\n     */\r\n    this._list = [];\r\n    /**\r\n     * Dictionary mapping the ids of the components defining actions, and their\r\n     * position in the list.\r\n     * @type {Object.<ComponentId, Number>}\r\n     */\r\n\r\n    this._idToIndex = {};\r\n    /**\r\n     * Counter for the length of the longest sequence currently enabled.\r\n     * @type {number}\r\n     */\r\n\r\n    this._longestSequence = 1;\r\n    /**\r\n     * The id of the component with the longest key sequence\r\n     * @type {ComponentId}\r\n     */\r\n\r\n    this._longestSequenceComponentId = null;\r\n    /**\r\n     * Record of whether at least one keymap is bound to each event type (keydown,\r\n     * keypress or keyup)\r\n     * @type {KeyEvent}\r\n     */\r\n\r\n    this._keyMapEventRecord = KeyEventStateArrayManager.newRecord();\r\n  }\r\n  /**\r\n   * Return a new iterator that can be used to enumerate the list\r\n   * @returns {ComponentOptionsListIterator}\r\n   */\r\n\r\n\r\n  _createClass(ComponentOptionsList, [{\r\n    key: \"getNewIterator\",\r\n    value: function getNewIterator() {\r\n      return new ComponentOptionsListIterator(this);\r\n    }\r\n    /**\r\n     * Adds a new hot key component's options, to be parsed and standardised before being\r\n     * added to the list\r\n     * @param {ComponentId} componentId - Id of the component the options belong to\r\n     * @param {KeyMap} actionNameToKeyMap - Map of actions to key maps\r\n     * @param {HandlersMap} actionNameToHandlersMap - Map of actions to handlers\r\n     * @param {Object} options - Hash of options that configure how the key map is built.\r\n     * @param {string} options.defaultKeyEvent - The default key event to use for any\r\n     *        action that does not explicitly define one.\r\n     * @returns {number} The position the component options have in the list\r\n     */\r\n\r\n  }, {\r\n    key: \"add\",\r\n    value: function add(componentId, actionNameToKeyMap, actionNameToHandlersMap, options) {\r\n      if (this.containsId(componentId)) {\r\n        return this.update(componentId, actionNameToKeyMap, actionNameToHandlersMap, options);\r\n      }\r\n\r\n      var componentOptions = this._build(componentId, actionNameToKeyMap, actionNameToHandlersMap, options);\r\n\r\n      this._list.push(componentOptions);\r\n\r\n      var newIndex = this._getLastIndex();\r\n\r\n      return this._idToIndex[componentId] = newIndex;\r\n    }\r\n    /**\r\n     * Whether the list contains options for a component with the specified id\r\n     * @param {ComponentId} id Id of the component\r\n     * @returns {boolean} True if the list contains options for the component with the\r\n     *        specified id\r\n     */\r\n\r\n  }, {\r\n    key: \"containsId\",\r\n    value: function containsId(id) {\r\n      return !!this.get(id);\r\n    }\r\n    /**\r\n     * Retrieves options for a component from the list\r\n     * @param {ComponentId} id Id of the component to retrieve the options for\r\n     * @returns {ComponentOptions} Options for the component with the specified id\r\n     */\r\n\r\n  }, {\r\n    key: \"get\",\r\n    value: function get(id) {\r\n      return this.getAtPosition(this.getIndexById(id));\r\n    }\r\n    /**\r\n     * Returns the position of the options belonging to the component with the specified\r\n     * id.\r\n     * @param {ComponentId} id Id of the component to retrieve the options for\r\n     * @returns {number} The position of the component options in the list.\r\n     */\r\n\r\n  }, {\r\n    key: \"getIndexById\",\r\n    value: function getIndexById(id) {\r\n      return this._idToIndex[id];\r\n    }\r\n    /**\r\n     * Replaces the options of a component already in the list with new values\r\n     * @param {ComponentId} componentId - Id of the component to replace the options of\r\n     * @param {KeyMap} actionNameToKeyMap - Map of actions to key maps\r\n     * @param {HandlersMap} actionNameToHandlersMap - Map of actions to handlers\r\n     * @param {Object} options - Hash of options that configure how the key map is built.\r\n     * @param {string} options.defaultKeyEvent - The default key event to use for any\r\n     *        action that does not explicitly define one.\r\n     * @returns {number} The position the component options have in the list\r\n     */\r\n\r\n  }, {\r\n    key: \"update\",\r\n    value: function update(componentId, actionNameToKeyMap, actionNameToHandlersMap, options) {\r\n      /**\r\n       * We record whether we're building new options for the component that currently\r\n       * has the longest sequence, to decide whether we need to recalculate the longest\r\n       * sequence.\r\n       */\r\n      var isUpdatingLongestSequenceComponent = this._isUpdatingComponentWithLongestSequence(componentId);\r\n\r\n      var longestSequenceBefore = this.getLongestSequence();\r\n\r\n      var componentOptions = this._build(componentId, actionNameToKeyMap, actionNameToHandlersMap, options);\r\n\r\n      if (isUpdatingLongestSequenceComponent && componentOptions.sequenceLength !== longestSequenceBefore) {\r\n        /**\r\n         * Component with the longest sequence has just had new options registered\r\n         * so we need to reset the longest sequence\r\n         */\r\n        if (componentOptions.sequenceLength > longestSequenceBefore) {\r\n          /**\r\n           * The same component has registered a longer sequence, so we just\r\n           * need to update the sequence length to the new, larger number\r\n           */\r\n          this._longestSequence = componentOptions.sequenceLength;\r\n        } else {\r\n          /**\r\n           * The component may no longer have the longest sequence, so we need to\r\n           * recalculate\r\n           */\r\n          this._recalculateLongestSequence();\r\n        }\r\n      }\r\n\r\n      this._list[this.getIndexById(componentId)] = componentOptions;\r\n    }\r\n    /**\r\n     * Removes the options of a component from the list\r\n     * @param {ComponentId} id The id of the component whose options are removed\r\n     * @returns {void}\r\n     */\r\n\r\n  }, {\r\n    key: \"remove\",\r\n    value: function remove(id) {\r\n      var isUpdatingLongestSequenceComponent = this._isUpdatingComponentWithLongestSequence(id);\r\n\r\n      this.removeAtPosition(this.getIndexById(id));\r\n\r\n      if (isUpdatingLongestSequenceComponent) {\r\n        this._recalculateLongestSequence();\r\n      }\r\n    }\r\n    /**\r\n     * Whether the list has any options in it (non-empty)\r\n     * @returns {boolean} true if the list has one or more options in it\r\n     */\r\n\r\n  }, {\r\n    key: \"any\",\r\n    value: function any() {\r\n      return this.getLength() !== 0;\r\n    }\r\n    /**\r\n     * Whether a component is the root component (the last one in the list)\r\n     * @param {ComponentId} id Id of the component to query if it is the root\r\n     * @returns {boolean} true if the component is the last in the list\r\n     */\r\n\r\n  }, {\r\n    key: \"isRoot\",\r\n    value: function isRoot(id) {\r\n      return this.getIndexById(id) >= this.getLength() - 1;\r\n    }\r\n    /**\r\n     * The length of the longest sequence currently defined.\r\n     * @returns {number} The sequence length\r\n     */\r\n\r\n  }, {\r\n    key: \"getLongestSequence\",\r\n    value: function getLongestSequence() {\r\n      return this._longestSequence;\r\n    }\r\n    /**\r\n     * Whether the list contains at least one component with an action bound to a\r\n     * particular keyboard event type.\r\n     * @param {KeyEventType} keyEventType Index of the keyboard event type\r\n     * @returns {boolean} true when the list contains a component with an action bound\r\n     *          to the event type\r\n     */\r\n\r\n  }, {\r\n    key: \"anyActionsForEventType\",\r\n    value: function anyActionsForEventType(keyEventType) {\r\n      return !!this._keyMapEventRecord[keyEventType];\r\n    }\r\n    /**\r\n     * The number of components in the list\r\n     * @returns {number} Number of components in the list\r\n     */\r\n\r\n  }, {\r\n    key: \"getLength\",\r\n    value: function getLength() {\r\n      return this._list.length;\r\n    }\r\n    /**\r\n     * The component options at particular position in the list\r\n     * @param {number} position The position in the list\r\n     * @returns {ComponentOptions} The component options at the position in the list\r\n     */\r\n\r\n  }, {\r\n    key: \"getAtPosition\",\r\n    value: function getAtPosition(position) {\r\n      return this._list[position];\r\n    }\r\n    /**\r\n     * Remove the component options at a position in the list\r\n     * @param {number} position The position in the list to remove the options\r\n     * return {void}\r\n     */\r\n\r\n  }, {\r\n    key: \"removeAtPosition\",\r\n    value: function removeAtPosition(position) {\r\n      this._list = removeAtIndex(this._list, position);\r\n      var counter = position;\r\n\r\n      while (counter < this.getLength()) {\r\n        this._idToIndex[this.getAtPosition(counter).componentId] = counter;\r\n        counter++;\r\n      }\r\n    }\r\n    /**\r\n     * A plain JavaScript object representation of the component options list that can\r\n     * be used for serialization or debugging\r\n     * @returns {ComponentOptions[]} plain JavaScript object representation of the list\r\n     */\r\n\r\n  }, {\r\n    key: \"toJSON\",\r\n    value: function toJSON() {\r\n      return this._list;\r\n    }\r\n    /********************************************************************************\r\n     * Private methods\r\n     ********************************************************************************/\r\n\r\n  }, {\r\n    key: \"_getLastIndex\",\r\n    value: function _getLastIndex() {\r\n      return this.getLength() - 1;\r\n    }\r\n    /**\r\n     * Builds the internal representation that described the options passed to a hot keys\r\n     * component\r\n     * @param {ComponentId} componentId - Id of the component the options belong to\r\n     * @param {KeyMap} actionNameToKeyMap - Map of actions to key maps\r\n     * @param {HandlersMap} actionNameToHandlersMap - Map of actions to handlers\r\n     * @param {Object} options - Hash of options that configure how the key map is built.\r\n     * @returns {ComponentOptions} Options for the specified component\r\n     * @private\r\n     */\r\n\r\n  }, {\r\n    key: \"_build\",\r\n    value: function _build(componentId, actionNameToKeyMap, actionNameToHandlersMap, options) {\r\n      var _this$_applyHardSeque = this._applyHardSequences(actionNameToKeyMap, actionNameToHandlersMap),\r\n          hardSequenceKeyMap = _this$_applyHardSeque.keyMap,\r\n          includingHardSequenceHandlers = _this$_applyHardSeque.handlers;\r\n\r\n      var actions = this._buildActionDictionary(_objectSpread({}, actionNameToKeyMap, hardSequenceKeyMap), options, componentId);\r\n\r\n      return {\r\n        actions: actions,\r\n        handlers: includingHardSequenceHandlers,\r\n        componentId: componentId,\r\n        options: options\r\n      };\r\n    }\r\n  }, {\r\n    key: \"_isUpdatingComponentWithLongestSequence\",\r\n    value: function _isUpdatingComponentWithLongestSequence(componentId) {\r\n      return componentId === this._getLongestSequenceComponentId();\r\n    }\r\n  }, {\r\n    key: \"_getLongestSequenceComponentId\",\r\n    value: function _getLongestSequenceComponentId() {\r\n      return this._longestSequenceComponentId;\r\n    }\r\n  }, {\r\n    key: \"_recalculateLongestSequence\",\r\n    value: function _recalculateLongestSequence() {\r\n      var iterator = this.getNewIterator();\r\n\r\n      while (iterator.next()) {\r\n        var _iterator$getComponen = iterator.getComponent(),\r\n            longestSequence = _iterator$getComponen.longestSequence,\r\n            componentId = _iterator$getComponen.componentId;\r\n\r\n        if (longestSequence > this.getLongestSequence()) {\r\n          this._longestSequenceComponentId = componentId;\r\n          this._longestSequence = longestSequence;\r\n        }\r\n      }\r\n    }\r\n    /**\r\n     * Applies hard sequences (handlers attached to actions with names that are valid\r\n     * KeySequenceStrings) that implicitly define a corresponding action name.\r\n     * @param {KeyMap} actionNameToKeyMap - KeyMap specified by HotKeys component\r\n     * @param {HandlersMap} actionMap - HandlersMap specified by HotKeys component\r\n     * @returns {{keyMap: {}, handlers: {}}} Object containing keymap and handlers map\r\n     *        with the hard sequence actions applied\r\n     * @private\r\n     */\r\n\r\n  }, {\r\n    key: \"_applyHardSequences\",\r\n    value: function _applyHardSequences(actionNameToKeyMap, actionMap) {\r\n      if (Configuration.option('enableHardSequences')) {\r\n        return Object.keys(actionMap).reduce(function (memo, actionNameOrHardSequence) {\r\n          var actionNameIsInKeyMap = !!actionNameToKeyMap[actionNameOrHardSequence];\r\n\r\n          if (!actionNameIsInKeyMap && KeyCombinationSerializer.isValidKeySerialization(actionNameOrHardSequence)) {\r\n            memo.keyMap[actionNameOrHardSequence] = actionNameOrHardSequence;\r\n          }\r\n\r\n          memo.handlers[actionNameOrHardSequence] = actionMap[actionNameOrHardSequence];\r\n          return memo;\r\n        }, {\r\n          keyMap: {},\r\n          handlers: {}\r\n        });\r\n      } else {\r\n        return {\r\n          keyMap: actionNameToKeyMap,\r\n          handlers: actionMap\r\n        };\r\n      }\r\n    }\r\n    /**\r\n     * Returns a mapping between ActionNames and ActionConfiguration\r\n     * @param {KeyMap} actionNameToKeyMap - Mapping of ActionNames to key sequences.\r\n     * @param {Object} options - Hash of options that configure how the key map is built.\r\n     * @param {string} options.defaultKeyEvent - The default key event to use for any\r\n     *        action that does not explicitly define one.\r\n     * @param {ComponentId} componentId Index of the component the matcher belongs to\r\n     * @returns {ActionDictionary} Map from ActionNames to ActionConfiguration\r\n     * @private\r\n     */\r\n\r\n  }, {\r\n    key: \"_buildActionDictionary\",\r\n    value: function _buildActionDictionary(actionNameToKeyMap, options, componentId) {\r\n      var _this = this;\r\n\r\n      return Object.keys(actionNameToKeyMap).reduce(function (memo, actionName) {\r\n        var keyMapConfig = actionNameToKeyMap[actionName];\r\n\r\n        var keyMapOptions = function () {\r\n          if (isObject(keyMapConfig) && hasKey(keyMapConfig, 'sequences')) {\r\n            return arrayFrom(keyMapConfig.sequences);\r\n          } else {\r\n            return arrayFrom(keyMapConfig);\r\n          }\r\n        }();\r\n\r\n        keyMapOptions.forEach(function (keyMapOption) {\r\n          var _normalizeActionOptio = normalizeActionOptions(keyMapOption, options),\r\n              keySequence = _normalizeActionOptio.keySequence,\r\n              keyEventType = _normalizeActionOptio.keyEventType;\r\n\r\n          _this._addActionOptions(memo, componentId, actionName, keySequence, keyEventType);\r\n        });\r\n        return memo;\r\n      }, {});\r\n    }\r\n  }, {\r\n    key: \"_addActionOptions\",\r\n    value: function _addActionOptions(memo, componentId, actionName, keySequence, keyEventType) {\r\n      var _KeySequenceParser$pa = KeySequenceParser.parse(keySequence, {\r\n        keyEventType: keyEventType\r\n      }),\r\n          sequence = _KeySequenceParser$pa.sequence,\r\n          combination = _KeySequenceParser$pa.combination;\r\n\r\n      if (sequence.size > this.getLongestSequence()) {\r\n        this._longestSequence = sequence.size;\r\n        this._longestSequenceComponentId = componentId;\r\n      }\r\n      /**\r\n       * Record that there is at least one key sequence in the focus tree bound to\r\n       * the keyboard event\r\n       */\r\n\r\n\r\n      this._keyMapEventRecord[keyEventType] = KeyEventState.seen;\r\n\r\n      if (!memo[actionName]) {\r\n        memo[actionName] = [];\r\n      }\r\n\r\n      memo[actionName].push(_objectSpread({\r\n        prefix: sequence.prefix,\r\n        actionName: actionName,\r\n        sequenceLength: sequence.size\r\n      }, combination));\r\n    }\r\n  }]);\r\n\r\n  return ComponentOptionsList;\r\n}();\r\n\r\nfunction normalizeActionOptions(keyMapOption, options) {\r\n  if (isObject(keyMapOption)) {\r\n    var sequence = keyMapOption.sequence,\r\n        action = keyMapOption.action;\r\n    return {\r\n      keySequence: sequence,\r\n      keyEventType: isUndefined(action) ? KeyEventType[options.defaultKeyEvent] : KeyEventType[action]\r\n    };\r\n  } else {\r\n    return {\r\n      keySequence: keyMapOption,\r\n      keyEventType: KeyEventType[options.defaultKeyEvent]\r\n    };\r\n  }\r\n}\r\n\r\nexport default ComponentOptionsList;"]},"metadata":{},"sourceType":"module"}