{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport Logger from './logging/Logger';\nimport FocusOnlyKeyEventStrategy from './strategies/FocusOnlyKeyEventStrategy';\nimport GlobalKeyEventStrategy from './strategies/GlobalKeyEventStrategy';\nimport isFromFocusOnlyComponent from '../helpers/resolving-handlers/isFromFocusOnlyComponent';\nimport Configuration from './config/Configuration';\nimport EventResponse from '../const/EventResponse';\n/**\r\n * Provides a registry for keyboard sequences and events, and the handlers that should\r\n * be called when they are detected. Also contains the interface for processing and\r\n * matching keyboard events against its list of registered actions and handlers.\r\n * @class\r\n */\n\nvar KeyEventManager = /*#__PURE__*/function () {\n  _createClass(KeyEventManager, null, [{\n    key: \"getInstance\",\n\n    /**\r\n     * Creates a new KeyEventManager instance if one does not already exist or returns the\r\n     * instance that already exists.\r\n     * @param {Object} configuration Configuration object\r\n     * @param {Logger} configuration.logger Logger instance\r\n     * @returns {KeyEventManager} The key event manager instance\r\n     */\n    value: function getInstance() {\n      var configuration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (!this.instance) {\n        this.instance = new KeyEventManager(configuration);\n      }\n\n      return this.instance;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      delete this.instance;\n    }\n    /**\r\n     * Creates a new KeyEventManager instance. It is expected that only a single instance\r\n     * will be used with a render tree.\r\n     */\n\n  }]);\n\n  function KeyEventManager() {\n    var configuration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, KeyEventManager);\n\n    this.logger = configuration.logger || new Logger(Configuration.option('logLevel'));\n    this._focusOnlyEventStrategy = new FocusOnlyKeyEventStrategy({\n      configuration: configuration,\n      logger: this.logger\n    }, this);\n    this._globalEventStrategy = new GlobalKeyEventStrategy({\n      configuration: configuration,\n      logger: this.logger\n    }, this);\n    this.mountedComponentsCount = 0;\n  }\n  /********************************************************************************\r\n   * Generating key maps\r\n   ********************************************************************************/\n\n\n  _createClass(KeyEventManager, [{\n    key: \"getApplicationKeyMap\",\n    value: function getApplicationKeyMap() {\n      return Object.assign(this._globalEventStrategy.getApplicationKeyMap(), this._focusOnlyEventStrategy.getApplicationKeyMap());\n    }\n    /********************************************************************************\r\n     * Registering key maps\r\n     ********************************************************************************/\n\n    /**\r\n     * Registers a new mounted component's key map so that it can be included in the\r\n     * application's key map\r\n     * @param {KeyMap} keyMap - Map of actions to key expressions\r\n     * @returns {ComponentId} Unique component ID to assign to the focused HotKeys\r\n     *          component and passed back when handling a key event\r\n     */\n\n  }, {\n    key: \"registerKeyMap\",\n    value: function registerKeyMap() {\n      var keyMap = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return this._focusOnlyEventStrategy.registerKeyMap(keyMap);\n    }\n    /**\r\n     * Re-registers (updates) a mounted component's key map\r\n     * @param {ComponentId} componentId - Id of the component that the keyMap belongs to\r\n     * @param {KeyMap} keyMap - Map of actions to key expressions\r\n     */\n\n  }, {\n    key: \"reregisterKeyMap\",\n    value: function reregisterKeyMap(componentId) {\n      var keyMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      this._focusOnlyEventStrategy.reregisterKeyMap(componentId, keyMap);\n    }\n    /**\r\n     * De-registers (removes) a mounted component's key map from the registry\r\n     * @param {ComponentId} componentId - Id of the component that the keyMap belongs to\r\n     */\n\n  }, {\n    key: \"deregisterKeyMap\",\n    value: function deregisterKeyMap(componentId) {\n      this._focusOnlyEventStrategy.deregisterKeyMap(componentId);\n    }\n    /**\r\n     * Registers that a component has now mounted, and declares its parent HotKeys\r\n     * component id so that actions may be properly resolved\r\n     * @param {ComponentId} componentId - Id of the component that has mounted\r\n     * @param {ComponentId} parentId - Id of the parent HotKeys component\r\n     */\n\n  }, {\n    key: \"registerComponentMount\",\n    value: function registerComponentMount(componentId, parentId) {\n      this._incrementComponentCount();\n\n      return this._focusOnlyEventStrategy.registerComponentMount(componentId, parentId);\n    }\n  }, {\n    key: \"registerComponentUnmount\",\n    value: function registerComponentUnmount() {\n      this._decrementComponentCount();\n    }\n  }, {\n    key: \"_incrementComponentCount\",\n    value: function _incrementComponentCount() {\n      var _this = this;\n\n      var preMountedComponentCount = this.mountedComponentsCount;\n      this.mountedComponentsCount += 1;\n\n      if (preMountedComponentCount === 0 && this.mountedComponentsCount === 1) {\n        window.onblur = function () {\n          return _this._clearKeyHistory();\n        };\n      }\n    }\n  }, {\n    key: \"_decrementComponentCount\",\n    value: function _decrementComponentCount() {\n      var preMountedComponentCount = this.mountedComponentsCount;\n      this.mountedComponentsCount -= 1;\n\n      if (preMountedComponentCount === 1 && this.mountedComponentsCount === 0) {\n        delete window.onblur;\n      }\n    }\n  }, {\n    key: \"_clearKeyHistory\",\n    value: function _clearKeyHistory() {\n      this.logger.info('HotKeys: Window focused - clearing key history');\n\n      this._focusOnlyEventStrategy.resetKeyHistory({\n        force: true\n      });\n\n      this._globalEventStrategy.resetKeyHistory({\n        force: true\n      });\n    }\n    /**\r\n     * Registers a new mounted component's global key map so that it can be included in the\r\n     * application's key map\r\n     * @param {KeyMap} keyMap - Map of actions to key expressions\r\n     * @returns {ComponentId} Unique component ID to assign to the focused HotKeys\r\n     *          component and passed back when handling a key event\r\n     */\n\n  }, {\n    key: \"registerGlobalKeyMap\",\n    value: function registerGlobalKeyMap() {\n      var keyMap = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return this._globalEventStrategy.registerKeyMap(keyMap);\n    }\n  }, {\n    key: \"registerGlobalComponentUnmount\",\n    value: function registerGlobalComponentUnmount() {\n      this._decrementComponentCount();\n    }\n    /**\r\n     * Registers that a component has now mounted, and declares its parent GlobalHotKeys\r\n     * component id so that actions may be properly resolved\r\n     * @param {ComponentId} componentId - Id of the component that has mounted\r\n     * @param {ComponentId} parentId - Id of the parent GlobalHotKeys component\r\n     */\n\n  }, {\n    key: \"registerGlobalComponentMount\",\n    value: function registerGlobalComponentMount(componentId, parentId) {\n      this._incrementComponentCount();\n\n      return this._globalEventStrategy.registerComponentMount(componentId, parentId);\n    }\n    /**\r\n     * Re-registers (updates) a mounted component's global key map\r\n     * @param {ComponentId} componentId - Id of the component that the keyMap belongs to\r\n     * @param {KeyMap} keyMap - Map of actions to key expressions\r\n     */\n\n  }, {\n    key: \"reregisterGlobalKeyMap\",\n    value: function reregisterGlobalKeyMap(componentId, keyMap) {\n      this._globalEventStrategy.reregisterKeyMap(componentId, keyMap);\n    }\n    /**\r\n     * De-registers (removes) a mounted component's global key map from the registry\r\n     * @param {ComponentId} componentId - Id of the component that the keyMap belongs to\r\n     */\n\n  }, {\n    key: \"deregisterGlobalKeyMap\",\n    value: function deregisterGlobalKeyMap(componentId) {\n      this._globalEventStrategy.deregisterKeyMap(componentId);\n    }\n    /********************************************************************************\r\n     * Recording key combination\r\n     ********************************************************************************/\n\n    /**\r\n     * Adds a listener function that will be called the next time a key combination completes\r\n     * @param {keyCombinationListener} callbackFunction Listener function to be called\r\n     * @returns {function} Function to call to cancel listening to the next key combination\r\n     */\n\n  }, {\n    key: \"addKeyCombinationListener\",\n    value: function addKeyCombinationListener(callbackFunction) {\n      return this._globalEventStrategy.addKeyCombinationListener(callbackFunction);\n    }\n    /********************************************************************************\r\n     * Focus key events\r\n     ********************************************************************************/\n\n    /**\r\n     * Registers the actions and handlers of a HotKeys component that has gained focus\r\n     * @param {ComponentId} componentId - Id of the component that the keyMap belongs to\r\n     * @param {KeyMap} actionNameToKeyMap - Map of actions to key expressions\r\n     * @param {HandlersMap} actionNameToHandlersMap - Map of actions to handler functions\r\n     * @param {Object} options Hash of options that configure how the actions\r\n     *        and handlers are associated and called.\r\n     * @returns {FocusTreeId} The current focus tree's ID\r\n     */\n\n  }, {\n    key: \"enableHotKeys\",\n    value: function enableHotKeys(componentId) {\n      var actionNameToKeyMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var actionNameToHandlersMap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var options = arguments.length > 3 ? arguments[3] : undefined;\n      return this._focusOnlyEventStrategy.enableHotKeys(componentId, actionNameToKeyMap, actionNameToHandlersMap, options);\n    }\n    /**\r\n     * Handles when a HotKeys component that is in focus updates its props and changes\r\n     * either the keyMap or handlers prop value\r\n     * @param {FocusTreeId} focusTreeId - The ID of the focus tree the component is part of.\r\n     *        Used to identify (and ignore) stale updates.\r\n     * @param {ComponentId} componentId - The component index of the component to\r\n     *        update\r\n     * @param {KeyMap} actionNameToKeyMap - Map of key sequences to action names\r\n     * @param {HandlersMap} actionNameToHandlersMap - Map of action names to handler\r\n     *        functions\r\n     * @param {Object} options Hash of options that configure how the actions\r\n     *        and handlers are associated and called.\r\n     */\n\n  }, {\n    key: \"updateEnabledHotKeys\",\n    value: function updateEnabledHotKeys(focusTreeId, componentId) {\n      var actionNameToKeyMap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var actionNameToHandlersMap = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      var options = arguments.length > 4 ? arguments[4] : undefined;\n      return this._focusOnlyEventStrategy.updateEnabledHotKeys(focusTreeId, componentId, actionNameToKeyMap, actionNameToHandlersMap, options);\n    }\n    /**\r\n     * Handles when a component loses focus by resetting the internal state, ready to\r\n     * receive the next tree of focused HotKeys components\r\n     * @param {FocusTreeId} focusTreeId - Id of focus tree component thinks it's\r\n     *        apart of\r\n     * @param {ComponentId} componentId - Index of component that is blurring\r\n     * @returns {boolean} Whether the component still has event propagation yet to handle\r\n     */\n\n  }, {\n    key: \"disableHotKeys\",\n    value: function disableHotKeys(focusTreeId, componentId) {\n      return this._focusOnlyEventStrategy.disableHotKeys(focusTreeId, componentId);\n    }\n    /**\r\n     * Records a keydown keyboard event and matches it against the list of pre-registered\r\n     * event handlers, calling the first matching handler with the highest priority if\r\n     * one exists.\r\n     *\r\n     * This method is called many times as a keyboard event bubbles up through the React\r\n     * render tree. The event is only registered the first time it is seen and results\r\n     * of some calculations are cached. The event is matched against the handlers registered\r\n     * at each component level, to ensure the proper handler declaration scoping.\r\n     * @param {KeyboardEvent} event - Event containing the key name and state\r\n     * @param {FocusTreeId} focusTreeId - Id of focus tree component thinks it's apart of\r\n     * @param {ComponentId} componentId - The id of the component that is currently handling\r\n     *        the keyboard event as it bubbles towards the document root.\r\n     * @param {Object} options - Hash of options that configure how the event is handled.\r\n     * @returns Whether the event was discarded because it was part of an old focus tree\r\n     */\n\n  }, {\n    key: \"handleKeydown\",\n    value: function handleKeydown(event, focusTreeId, componentId, options) {\n      if (isFromFocusOnlyComponent(focusTreeId)) {\n        return this._focusOnlyEventStrategy.handleKeydown(event, focusTreeId, componentId, options);\n      }\n    }\n    /**\r\n     * Records a keypress keyboard event and matches it against the list of pre-registered\r\n     * event handlers, calling the first matching handler with the highest priority if\r\n     * one exists.\r\n     *\r\n     * This method is called many times as a keyboard event bubbles up through the React\r\n     * render tree. The event is only registered the first time it is seen and results\r\n     * of some calculations are cached. The event is matched against the handlers registered\r\n     * at each component level, to ensure the proper handler declaration scoping.\r\n     * @param {KeyboardEvent} event - Event containing the key name and state\r\n     * @param {FocusTreeId} focusTreeId Id - of focus tree component thinks it's apart of\r\n     * @param {ComponentId} componentId - The index of the component that is currently handling\r\n     *        the keyboard event as it bubbles towards the document root.\r\n     * @param {Object} options - Hash of options that configure how the event\r\n     *        is handled.\r\n     */\n\n  }, {\n    key: \"handleKeyPress\",\n    value: function handleKeyPress(event, focusTreeId, componentId, options) {\n      if (isFromFocusOnlyComponent(focusTreeId)) {\n        return this._focusOnlyEventStrategy.handleKeyPress(event, focusTreeId, componentId, options);\n      }\n    }\n    /**\r\n     * Records a keyup keyboard event and matches it against the list of pre-registered\r\n     * event handlers, calling the first matching handler with the highest priority if\r\n     * one exists.\r\n     *\r\n     * This method is called many times as a keyboard event bubbles up through the React\r\n     * render tree. The event is only registered the first time it is seen and results\r\n     * of some calculations are cached. The event is matched against the handlers registered\r\n     * at each component level, to ensure the proper handler declaration scoping.\r\n     * @param {KeyboardEvent} event Event containing the key name and state\r\n     * @param {FocusTreeId} focusTreeId Id of focus tree component thinks it's apart of\r\n     * @param {ComponentId} componentId The index of the component that is currently handling\r\n     *        the keyboard event as it bubbles towards the document root.\r\n     * @param {Object} options Hash of options that configure how the event\r\n     *        is handled.\r\n     */\n\n  }, {\n    key: \"handleKeyUp\",\n    value: function handleKeyUp(event, focusTreeId, componentId, options) {\n      if (isFromFocusOnlyComponent(focusTreeId)) {\n        return this._focusOnlyEventStrategy.handleKeyUp(event, focusTreeId, componentId, options);\n      }\n    }\n    /********************************************************************************\r\n     * Global key events\r\n     ********************************************************************************/\n\n    /**\r\n     * Registers the actions and handlers of a HotKeys component that has mounted\r\n     * @param {ComponentId} componentId - Id of the component that the keyMap belongs to\r\n     * @param {KeyMap} actionNameToKeyMap - Map of actions to key expressions\r\n     * @param {HandlersMap} actionNameToHandlersMap - Map of actions to handler functions\r\n     * @param {Object} options Hash of options that configure how the actions\r\n     *        and handlers are associated and called.\r\n     * @param {Object} eventOptions - Options for how the event should be handled\r\n     * @returns {ComponentId} A unique component ID to assign to the focused HotKeys\r\n     *        component and passed back when handling a key event\r\n     */\n\n  }, {\n    key: \"enableGlobalHotKeys\",\n    value: function enableGlobalHotKeys(componentId) {\n      var actionNameToKeyMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var actionNameToHandlersMap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var options = arguments.length > 3 ? arguments[3] : undefined;\n      var eventOptions = arguments.length > 4 ? arguments[4] : undefined;\n      return this._globalEventStrategy.enableHotKeys(componentId, actionNameToKeyMap, actionNameToHandlersMap, options, eventOptions);\n    }\n    /**\r\n     * Handles when a mounted global HotKeys component updates its props and changes\r\n     * either the keyMap or handlers prop value\r\n     * @param {ComponentId} componentId - The component index of the component to\r\n     *        update\r\n     * @param {KeyMap} actionNameToKeyMap - Map of actions to key expressions\r\n     * @param {HandlersMap} actionNameToHandlersMap - Map of actions to handler functions\r\n     * @param {Object} options Hash of options that configure how the actions\r\n     *        and handlers are associated and called.\r\n     * @param {Object} eventOptions - Options for how the event should be handled\r\n     */\n\n  }, {\n    key: \"updateEnabledGlobalHotKeys\",\n    value: function updateEnabledGlobalHotKeys(componentId) {\n      var actionNameToKeyMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var actionNameToHandlersMap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var options = arguments.length > 3 ? arguments[3] : undefined;\n      var eventOptions = arguments.length > 4 ? arguments[4] : undefined;\n      return this._globalEventStrategy.updateEnabledHotKeys(componentId, actionNameToKeyMap, actionNameToHandlersMap, options, eventOptions);\n    }\n    /**\r\n     * Handles when a component is unmounted\r\n     * @param {ComponentId} componentId - Index of component that is being unmounted\r\n     */\n\n  }, {\n    key: \"disableGlobalHotKeys\",\n    value: function disableGlobalHotKeys(componentId) {\n      return this._globalEventStrategy.disableHotKeys(componentId);\n    }\n    /**\r\n     * Records a keydown keyboard event and matches it against the list of pre-registered\r\n     * event handlers, calling the first matching handler with the highest priority if\r\n     * one exists.\r\n     *\r\n     * This method is called once when a keyboard event bubbles up to document, and checks\r\n     * the keymaps for all of the mounted global HotKey components.\r\n     * @param {KeyboardEvent} event - Event containing the key name and state\r\n     */\n\n  }, {\n    key: \"handleGlobalKeyDown\",\n    value: function handleGlobalKeyDown(event) {\n      return this._globalEventStrategy.handleKeydown(event);\n    }\n    /**\r\n     * Records a keypress keyboard event and matches it against the list of pre-registered\r\n     * event handlers, calling the first matching handler with the highest priority if\r\n     * one exists.\r\n     *\r\n     * This method is called once when a keyboard event bubbles up to document, and checks\r\n     * the keymaps for all of the mounted global HotKey components.\r\n     * @param {KeyboardEvent} event - Event containing the key name and state\r\n     */\n\n  }, {\n    key: \"handleGlobalKeyPress\",\n    value: function handleGlobalKeyPress(event) {\n      return this._globalEventStrategy.handleKeyPress(event);\n    }\n    /**\r\n     * Records a keyup keyboard event and matches it against the list of pre-registered\r\n     * event handlers, calling the first matching handler with the highest priority if\r\n     * one exists.\r\n     *\r\n     * This method is called once when a keyboard event bubbles up to document, and checks\r\n     * the keymaps for all of the mounted global HotKey components.\r\n     * @param {KeyboardEvent} event - Event containing the key name and state\r\n     */\n\n  }, {\n    key: \"handleGlobalKeyUp\",\n    value: function handleGlobalKeyUp(event) {\n      return this._globalEventStrategy.handleKeyUp(event);\n    }\n    /**\r\n     * Ignores the next keyboard event immediately, rather than waiting for it to\r\n     * match the ignoreEventsCondition\r\n     * @param {KeyboardEvent} event keyboard event to ignore\r\n     * @see Configuration.ignoreEventsCondition\r\n     */\n\n  }, {\n    key: \"ignoreEvent\",\n    value: function ignoreEvent(event) {\n      this._focusOnlyEventStrategy.getEventPropagator().ignoreEvent(event);\n    }\n    /**\r\n     * Forces the observation of the next keyboard event immediately, disregarding whether\r\n     * the event matches the ignoreKeyEventsCondition\r\n     * @param {KeyboardEvent} event keyboard event to force the observation of\r\n     * @see Configuration.ignoreEventsCondition\r\n     */\n\n  }, {\n    key: \"observeIgnoredEvents\",\n    value: function observeIgnoredEvents(event) {\n      this._focusOnlyEventStrategy.getEventPropagator().observeIgnoredEvents(event);\n    }\n    /**\r\n     * Closes any hanging key combinations that have not received the key event indicated\r\n     * by recordIndex.\r\n     * @param {KeyName} keyName The name of the key whose state should be updated if it\r\n     *        is currently set to keydown or keypress.\r\n     * @param {KeyEventType} recordIndex Index of key event to move the key state\r\n     *        up to.\r\n     */\n\n  }, {\n    key: \"closeHangingKeyCombination\",\n    value: function closeHangingKeyCombination(keyName, recordIndex) {\n      this._focusOnlyEventStrategy.closeHangingKeyCombination(keyName, recordIndex);\n    }\n  }, {\n    key: \"reactAppHistoryWithEvent\",\n    value: function reactAppHistoryWithEvent(key, type) {\n      var previousPropagation = this._focusOnlyEventStrategy.eventPropagator.getPreviousPropagation();\n\n      if (previousPropagation.isForKey(key) && previousPropagation.isForEventType(type)) {\n        if (previousPropagation.isHandled()) {\n          return EventResponse.handled;\n        } else if (previousPropagation.isIgnoringEvent()) {\n          return EventResponse.ignored;\n        } else {\n          return EventResponse.seen;\n        }\n      } else {\n        return EventResponse.unseen;\n      }\n    }\n  }, {\n    key: \"simulatePendingKeyPressEvents\",\n    value: function simulatePendingKeyPressEvents() {\n      this._focusOnlyEventStrategy.simulatePendingKeyPressEvents();\n    }\n  }, {\n    key: \"simulatePendingKeyUpEvents\",\n    value: function simulatePendingKeyUpEvents() {\n      this._focusOnlyEventStrategy.simulatePendingKeyUpEvents();\n    }\n  }, {\n    key: \"isGlobalListenersBound\",\n    value: function isGlobalListenersBound() {\n      return this._globalEventStrategy.listenersBound;\n    }\n  }]);\n\n  return KeyEventManager;\n}();\n\nexport default KeyEventManager;","map":{"version":3,"sources":["D:/GitHub/ML4GIS/client/node_modules/react-hotkeys/es/lib/KeyEventManager.js"],"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","Logger","FocusOnlyKeyEventStrategy","GlobalKeyEventStrategy","isFromFocusOnlyComponent","Configuration","EventResponse","KeyEventManager","value","getInstance","configuration","arguments","undefined","clear","logger","option","_focusOnlyEventStrategy","_globalEventStrategy","mountedComponentsCount","getApplicationKeyMap","assign","registerKeyMap","keyMap","reregisterKeyMap","componentId","deregisterKeyMap","registerComponentMount","parentId","_incrementComponentCount","registerComponentUnmount","_decrementComponentCount","_this","preMountedComponentCount","window","onblur","_clearKeyHistory","info","resetKeyHistory","force","registerGlobalKeyMap","registerGlobalComponentUnmount","registerGlobalComponentMount","reregisterGlobalKeyMap","deregisterGlobalKeyMap","addKeyCombinationListener","callbackFunction","enableHotKeys","actionNameToKeyMap","actionNameToHandlersMap","options","updateEnabledHotKeys","focusTreeId","disableHotKeys","handleKeydown","event","handleKeyPress","handleKeyUp","enableGlobalHotKeys","eventOptions","updateEnabledGlobalHotKeys","disableGlobalHotKeys","handleGlobalKeyDown","handleGlobalKeyPress","handleGlobalKeyUp","ignoreEvent","getEventPropagator","observeIgnoredEvents","closeHangingKeyCombination","keyName","recordIndex","reactAppHistoryWithEvent","type","previousPropagation","eventPropagator","getPreviousPropagation","isForKey","isForEventType","isHandled","handled","isIgnoringEvent","ignored","seen","unseen","simulatePendingKeyPressEvents","simulatePendingKeyUpEvents","isGlobalListenersBound","listenersBound"],"mappings":"AAAA,SAASA,eAAT,CAAyBC,QAAzB,EAAmCC,WAAnC,EAAgD;AAAE,MAAI,EAAED,QAAQ,YAAYC,WAAtB,CAAJ,EAAwC;AAAE,UAAM,IAAIC,SAAJ,CAAc,mCAAd,CAAN;AAA2D;AAAE;;AAEzJ,SAASC,iBAAT,CAA2BC,MAA3B,EAAmCC,KAAnC,EAA0C;AAAE,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,KAAK,CAACE,MAA1B,EAAkCD,CAAC,EAAnC,EAAuC;AAAE,QAAIE,UAAU,GAAGH,KAAK,CAACC,CAAD,CAAtB;AAA2BE,IAAAA,UAAU,CAACC,UAAX,GAAwBD,UAAU,CAACC,UAAX,IAAyB,KAAjD;AAAwDD,IAAAA,UAAU,CAACE,YAAX,GAA0B,IAA1B;AAAgC,QAAI,WAAWF,UAAf,EAA2BA,UAAU,CAACG,QAAX,GAAsB,IAAtB;AAA4BC,IAAAA,MAAM,CAACC,cAAP,CAAsBT,MAAtB,EAA8BI,UAAU,CAACM,GAAzC,EAA8CN,UAA9C;AAA4D;AAAE;;AAE7T,SAASO,YAAT,CAAsBd,WAAtB,EAAmCe,UAAnC,EAA+CC,WAA/C,EAA4D;AAAE,MAAID,UAAJ,EAAgBb,iBAAiB,CAACF,WAAW,CAACiB,SAAb,EAAwBF,UAAxB,CAAjB;AAAsD,MAAIC,WAAJ,EAAiBd,iBAAiB,CAACF,WAAD,EAAcgB,WAAd,CAAjB;AAA6C,SAAOhB,WAAP;AAAqB;;AAEvN,OAAOkB,MAAP,MAAmB,kBAAnB;AACA,OAAOC,yBAAP,MAAsC,wCAAtC;AACA,OAAOC,sBAAP,MAAmC,qCAAnC;AACA,OAAOC,wBAAP,MAAqC,wDAArC;AACA,OAAOC,aAAP,MAA0B,wBAA1B;AACA,OAAOC,aAAP,MAA0B,wBAA1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIC,eAAe,GACnB,aACA,YAAY;AACVV,EAAAA,YAAY,CAACU,eAAD,EAAkB,IAAlB,EAAwB,CAAC;AACnCX,IAAAA,GAAG,EAAE,aAD8B;;AAGnC;AACJ;AACA;AACA;AACA;AACA;AACA;AACIY,IAAAA,KAAK,EAAE,SAASC,WAAT,GAAuB;AAC5B,UAAIC,aAAa,GAAGC,SAAS,CAACtB,MAAV,GAAmB,CAAnB,IAAwBsB,SAAS,CAAC,CAAD,CAAT,KAAiBC,SAAzC,GAAqDD,SAAS,CAAC,CAAD,CAA9D,GAAoE,EAAxF;;AAEA,UAAI,CAAC,KAAK7B,QAAV,EAAoB;AAClB,aAAKA,QAAL,GAAgB,IAAIyB,eAAJ,CAAoBG,aAApB,CAAhB;AACD;;AAED,aAAO,KAAK5B,QAAZ;AACD;AAlBkC,GAAD,EAmBjC;AACDc,IAAAA,GAAG,EAAE,OADJ;AAEDY,IAAAA,KAAK,EAAE,SAASK,KAAT,GAAiB;AACtB,aAAO,KAAK/B,QAAZ;AACD;AACD;AACJ;AACA;AACA;;AARK,GAnBiC,CAAxB,CAAZ;;AA+BA,WAASyB,eAAT,GAA2B;AACzB,QAAIG,aAAa,GAAGC,SAAS,CAACtB,MAAV,GAAmB,CAAnB,IAAwBsB,SAAS,CAAC,CAAD,CAAT,KAAiBC,SAAzC,GAAqDD,SAAS,CAAC,CAAD,CAA9D,GAAoE,EAAxF;;AAEA9B,IAAAA,eAAe,CAAC,IAAD,EAAO0B,eAAP,CAAf;;AAEA,SAAKO,MAAL,GAAcJ,aAAa,CAACI,MAAd,IAAwB,IAAIb,MAAJ,CAAWI,aAAa,CAACU,MAAd,CAAqB,UAArB,CAAX,CAAtC;AACA,SAAKC,uBAAL,GAA+B,IAAId,yBAAJ,CAA8B;AAC3DQ,MAAAA,aAAa,EAAEA,aAD4C;AAE3DI,MAAAA,MAAM,EAAE,KAAKA;AAF8C,KAA9B,EAG5B,IAH4B,CAA/B;AAIA,SAAKG,oBAAL,GAA4B,IAAId,sBAAJ,CAA2B;AACrDO,MAAAA,aAAa,EAAEA,aADsC;AAErDI,MAAAA,MAAM,EAAE,KAAKA;AAFwC,KAA3B,EAGzB,IAHyB,CAA5B;AAIA,SAAKI,sBAAL,GAA8B,CAA9B;AACD;AACD;AACF;AACA;;;AAGErB,EAAAA,YAAY,CAACU,eAAD,EAAkB,CAAC;AAC7BX,IAAAA,GAAG,EAAE,sBADwB;AAE7BY,IAAAA,KAAK,EAAE,SAASW,oBAAT,GAAgC;AACrC,aAAOzB,MAAM,CAAC0B,MAAP,CAAc,KAAKH,oBAAL,CAA0BE,oBAA1B,EAAd,EAAgE,KAAKH,uBAAL,CAA6BG,oBAA7B,EAAhE,CAAP;AACD;AACD;AACJ;AACA;;AAEI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAfiC,GAAD,EAiB3B;AACDvB,IAAAA,GAAG,EAAE,gBADJ;AAEDY,IAAAA,KAAK,EAAE,SAASa,cAAT,GAA0B;AAC/B,UAAIC,MAAM,GAAGX,SAAS,CAACtB,MAAV,GAAmB,CAAnB,IAAwBsB,SAAS,CAAC,CAAD,CAAT,KAAiBC,SAAzC,GAAqDD,SAAS,CAAC,CAAD,CAA9D,GAAoE,EAAjF;AACA,aAAO,KAAKK,uBAAL,CAA6BK,cAA7B,CAA4CC,MAA5C,CAAP;AACD;AACD;AACJ;AACA;AACA;AACA;;AAVK,GAjB2B,EA6B3B;AACD1B,IAAAA,GAAG,EAAE,kBADJ;AAEDY,IAAAA,KAAK,EAAE,SAASe,gBAAT,CAA0BC,WAA1B,EAAuC;AAC5C,UAAIF,MAAM,GAAGX,SAAS,CAACtB,MAAV,GAAmB,CAAnB,IAAwBsB,SAAS,CAAC,CAAD,CAAT,KAAiBC,SAAzC,GAAqDD,SAAS,CAAC,CAAD,CAA9D,GAAoE,EAAjF;;AAEA,WAAKK,uBAAL,CAA6BO,gBAA7B,CAA8CC,WAA9C,EAA2DF,MAA3D;AACD;AACD;AACJ;AACA;AACA;;AAVK,GA7B2B,EAyC3B;AACD1B,IAAAA,GAAG,EAAE,kBADJ;AAEDY,IAAAA,KAAK,EAAE,SAASiB,gBAAT,CAA0BD,WAA1B,EAAuC;AAC5C,WAAKR,uBAAL,CAA6BS,gBAA7B,CAA8CD,WAA9C;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;;AAVK,GAzC2B,EAqD3B;AACD5B,IAAAA,GAAG,EAAE,wBADJ;AAEDY,IAAAA,KAAK,EAAE,SAASkB,sBAAT,CAAgCF,WAAhC,EAA6CG,QAA7C,EAAuD;AAC5D,WAAKC,wBAAL;;AAEA,aAAO,KAAKZ,uBAAL,CAA6BU,sBAA7B,CAAoDF,WAApD,EAAiEG,QAAjE,CAAP;AACD;AANA,GArD2B,EA4D3B;AACD/B,IAAAA,GAAG,EAAE,0BADJ;AAEDY,IAAAA,KAAK,EAAE,SAASqB,wBAAT,GAAoC;AACzC,WAAKC,wBAAL;AACD;AAJA,GA5D2B,EAiE3B;AACDlC,IAAAA,GAAG,EAAE,0BADJ;AAEDY,IAAAA,KAAK,EAAE,SAASoB,wBAAT,GAAoC;AACzC,UAAIG,KAAK,GAAG,IAAZ;;AAEA,UAAIC,wBAAwB,GAAG,KAAKd,sBAApC;AACA,WAAKA,sBAAL,IAA+B,CAA/B;;AAEA,UAAIc,wBAAwB,KAAK,CAA7B,IAAkC,KAAKd,sBAAL,KAAgC,CAAtE,EAAyE;AACvEe,QAAAA,MAAM,CAACC,MAAP,GAAgB,YAAY;AAC1B,iBAAOH,KAAK,CAACI,gBAAN,EAAP;AACD,SAFD;AAGD;AACF;AAbA,GAjE2B,EA+E3B;AACDvC,IAAAA,GAAG,EAAE,0BADJ;AAEDY,IAAAA,KAAK,EAAE,SAASsB,wBAAT,GAAoC;AACzC,UAAIE,wBAAwB,GAAG,KAAKd,sBAApC;AACA,WAAKA,sBAAL,IAA+B,CAA/B;;AAEA,UAAIc,wBAAwB,KAAK,CAA7B,IAAkC,KAAKd,sBAAL,KAAgC,CAAtE,EAAyE;AACvE,eAAOe,MAAM,CAACC,MAAd;AACD;AACF;AATA,GA/E2B,EAyF3B;AACDtC,IAAAA,GAAG,EAAE,kBADJ;AAEDY,IAAAA,KAAK,EAAE,SAAS2B,gBAAT,GAA4B;AACjC,WAAKrB,MAAL,CAAYsB,IAAZ,CAAiB,gDAAjB;;AAEA,WAAKpB,uBAAL,CAA6BqB,eAA7B,CAA6C;AAC3CC,QAAAA,KAAK,EAAE;AADoC,OAA7C;;AAIA,WAAKrB,oBAAL,CAA0BoB,eAA1B,CAA0C;AACxCC,QAAAA,KAAK,EAAE;AADiC,OAA1C;AAGD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;;AAnBK,GAzF2B,EA8G3B;AACD1C,IAAAA,GAAG,EAAE,sBADJ;AAEDY,IAAAA,KAAK,EAAE,SAAS+B,oBAAT,GAAgC;AACrC,UAAIjB,MAAM,GAAGX,SAAS,CAACtB,MAAV,GAAmB,CAAnB,IAAwBsB,SAAS,CAAC,CAAD,CAAT,KAAiBC,SAAzC,GAAqDD,SAAS,CAAC,CAAD,CAA9D,GAAoE,EAAjF;AACA,aAAO,KAAKM,oBAAL,CAA0BI,cAA1B,CAAyCC,MAAzC,CAAP;AACD;AALA,GA9G2B,EAoH3B;AACD1B,IAAAA,GAAG,EAAE,gCADJ;AAEDY,IAAAA,KAAK,EAAE,SAASgC,8BAAT,GAA0C;AAC/C,WAAKV,wBAAL;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;;AAVK,GApH2B,EAgI3B;AACDlC,IAAAA,GAAG,EAAE,8BADJ;AAEDY,IAAAA,KAAK,EAAE,SAASiC,4BAAT,CAAsCjB,WAAtC,EAAmDG,QAAnD,EAA6D;AAClE,WAAKC,wBAAL;;AAEA,aAAO,KAAKX,oBAAL,CAA0BS,sBAA1B,CAAiDF,WAAjD,EAA8DG,QAA9D,CAAP;AACD;AACD;AACJ;AACA;AACA;AACA;;AAXK,GAhI2B,EA6I3B;AACD/B,IAAAA,GAAG,EAAE,wBADJ;AAEDY,IAAAA,KAAK,EAAE,SAASkC,sBAAT,CAAgClB,WAAhC,EAA6CF,MAA7C,EAAqD;AAC1D,WAAKL,oBAAL,CAA0BM,gBAA1B,CAA2CC,WAA3C,EAAwDF,MAAxD;AACD;AACD;AACJ;AACA;AACA;;AARK,GA7I2B,EAuJ3B;AACD1B,IAAAA,GAAG,EAAE,wBADJ;AAEDY,IAAAA,KAAK,EAAE,SAASmC,sBAAT,CAAgCnB,WAAhC,EAA6C;AAClD,WAAKP,oBAAL,CAA0BQ,gBAA1B,CAA2CD,WAA3C;AACD;AACD;AACJ;AACA;;AAEI;AACJ;AACA;AACA;AACA;;AAbK,GAvJ2B,EAsK3B;AACD5B,IAAAA,GAAG,EAAE,2BADJ;AAEDY,IAAAA,KAAK,EAAE,SAASoC,yBAAT,CAAmCC,gBAAnC,EAAqD;AAC1D,aAAO,KAAK5B,oBAAL,CAA0B2B,yBAA1B,CAAoDC,gBAApD,CAAP;AACD;AACD;AACJ;AACA;;AAEI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAjBK,GAtK2B,EAyL3B;AACDjD,IAAAA,GAAG,EAAE,eADJ;AAEDY,IAAAA,KAAK,EAAE,SAASsC,aAAT,CAAuBtB,WAAvB,EAAoC;AACzC,UAAIuB,kBAAkB,GAAGpC,SAAS,CAACtB,MAAV,GAAmB,CAAnB,IAAwBsB,SAAS,CAAC,CAAD,CAAT,KAAiBC,SAAzC,GAAqDD,SAAS,CAAC,CAAD,CAA9D,GAAoE,EAA7F;AACA,UAAIqC,uBAAuB,GAAGrC,SAAS,CAACtB,MAAV,GAAmB,CAAnB,IAAwBsB,SAAS,CAAC,CAAD,CAAT,KAAiBC,SAAzC,GAAqDD,SAAS,CAAC,CAAD,CAA9D,GAAoE,EAAlG;AACA,UAAIsC,OAAO,GAAGtC,SAAS,CAACtB,MAAV,GAAmB,CAAnB,GAAuBsB,SAAS,CAAC,CAAD,CAAhC,GAAsCC,SAApD;AACA,aAAO,KAAKI,uBAAL,CAA6B8B,aAA7B,CAA2CtB,WAA3C,EAAwDuB,kBAAxD,EAA4EC,uBAA5E,EAAqGC,OAArG,CAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AApBK,GAzL2B,EA+M3B;AACDrD,IAAAA,GAAG,EAAE,sBADJ;AAEDY,IAAAA,KAAK,EAAE,SAAS0C,oBAAT,CAA8BC,WAA9B,EAA2C3B,WAA3C,EAAwD;AAC7D,UAAIuB,kBAAkB,GAAGpC,SAAS,CAACtB,MAAV,GAAmB,CAAnB,IAAwBsB,SAAS,CAAC,CAAD,CAAT,KAAiBC,SAAzC,GAAqDD,SAAS,CAAC,CAAD,CAA9D,GAAoE,EAA7F;AACA,UAAIqC,uBAAuB,GAAGrC,SAAS,CAACtB,MAAV,GAAmB,CAAnB,IAAwBsB,SAAS,CAAC,CAAD,CAAT,KAAiBC,SAAzC,GAAqDD,SAAS,CAAC,CAAD,CAA9D,GAAoE,EAAlG;AACA,UAAIsC,OAAO,GAAGtC,SAAS,CAACtB,MAAV,GAAmB,CAAnB,GAAuBsB,SAAS,CAAC,CAAD,CAAhC,GAAsCC,SAApD;AACA,aAAO,KAAKI,uBAAL,CAA6BkC,oBAA7B,CAAkDC,WAAlD,EAA+D3B,WAA/D,EAA4EuB,kBAA5E,EAAgGC,uBAAhG,EAAyHC,OAAzH,CAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAfK,GA/M2B,EAgO3B;AACDrD,IAAAA,GAAG,EAAE,gBADJ;AAEDY,IAAAA,KAAK,EAAE,SAAS4C,cAAT,CAAwBD,WAAxB,EAAqC3B,WAArC,EAAkD;AACvD,aAAO,KAAKR,uBAAL,CAA6BoC,cAA7B,CAA4CD,WAA5C,EAAyD3B,WAAzD,CAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AApBK,GAhO2B,EAsP3B;AACD5B,IAAAA,GAAG,EAAE,eADJ;AAEDY,IAAAA,KAAK,EAAE,SAAS6C,aAAT,CAAuBC,KAAvB,EAA8BH,WAA9B,EAA2C3B,WAA3C,EAAwDyB,OAAxD,EAAiE;AACtE,UAAI7C,wBAAwB,CAAC+C,WAAD,CAA5B,EAA2C;AACzC,eAAO,KAAKnC,uBAAL,CAA6BqC,aAA7B,CAA2CC,KAA3C,EAAkDH,WAAlD,EAA+D3B,WAA/D,EAA4EyB,OAA5E,CAAP;AACD;AACF;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAtBK,GAtP2B,EA8Q3B;AACDrD,IAAAA,GAAG,EAAE,gBADJ;AAEDY,IAAAA,KAAK,EAAE,SAAS+C,cAAT,CAAwBD,KAAxB,EAA+BH,WAA/B,EAA4C3B,WAA5C,EAAyDyB,OAAzD,EAAkE;AACvE,UAAI7C,wBAAwB,CAAC+C,WAAD,CAA5B,EAA2C;AACzC,eAAO,KAAKnC,uBAAL,CAA6BuC,cAA7B,CAA4CD,KAA5C,EAAmDH,WAAnD,EAAgE3B,WAAhE,EAA6EyB,OAA7E,CAAP;AACD;AACF;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAtBK,GA9Q2B,EAsS3B;AACDrD,IAAAA,GAAG,EAAE,aADJ;AAEDY,IAAAA,KAAK,EAAE,SAASgD,WAAT,CAAqBF,KAArB,EAA4BH,WAA5B,EAAyC3B,WAAzC,EAAsDyB,OAAtD,EAA+D;AACpE,UAAI7C,wBAAwB,CAAC+C,WAAD,CAA5B,EAA2C;AACzC,eAAO,KAAKnC,uBAAL,CAA6BwC,WAA7B,CAAyCF,KAAzC,EAAgDH,WAAhD,EAA6D3B,WAA7D,EAA0EyB,OAA1E,CAAP;AACD;AACF;AACD;AACJ;AACA;;AAEI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AArBK,GAtS2B,EA6T3B;AACDrD,IAAAA,GAAG,EAAE,qBADJ;AAEDY,IAAAA,KAAK,EAAE,SAASiD,mBAAT,CAA6BjC,WAA7B,EAA0C;AAC/C,UAAIuB,kBAAkB,GAAGpC,SAAS,CAACtB,MAAV,GAAmB,CAAnB,IAAwBsB,SAAS,CAAC,CAAD,CAAT,KAAiBC,SAAzC,GAAqDD,SAAS,CAAC,CAAD,CAA9D,GAAoE,EAA7F;AACA,UAAIqC,uBAAuB,GAAGrC,SAAS,CAACtB,MAAV,GAAmB,CAAnB,IAAwBsB,SAAS,CAAC,CAAD,CAAT,KAAiBC,SAAzC,GAAqDD,SAAS,CAAC,CAAD,CAA9D,GAAoE,EAAlG;AACA,UAAIsC,OAAO,GAAGtC,SAAS,CAACtB,MAAV,GAAmB,CAAnB,GAAuBsB,SAAS,CAAC,CAAD,CAAhC,GAAsCC,SAApD;AACA,UAAI8C,YAAY,GAAG/C,SAAS,CAACtB,MAAV,GAAmB,CAAnB,GAAuBsB,SAAS,CAAC,CAAD,CAAhC,GAAsCC,SAAzD;AACA,aAAO,KAAKK,oBAAL,CAA0B6B,aAA1B,CAAwCtB,WAAxC,EAAqDuB,kBAArD,EAAyEC,uBAAzE,EAAkGC,OAAlG,EAA2GS,YAA3G,CAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAnBK,GA7T2B,EAkV3B;AACD9D,IAAAA,GAAG,EAAE,4BADJ;AAEDY,IAAAA,KAAK,EAAE,SAASmD,0BAAT,CAAoCnC,WAApC,EAAiD;AACtD,UAAIuB,kBAAkB,GAAGpC,SAAS,CAACtB,MAAV,GAAmB,CAAnB,IAAwBsB,SAAS,CAAC,CAAD,CAAT,KAAiBC,SAAzC,GAAqDD,SAAS,CAAC,CAAD,CAA9D,GAAoE,EAA7F;AACA,UAAIqC,uBAAuB,GAAGrC,SAAS,CAACtB,MAAV,GAAmB,CAAnB,IAAwBsB,SAAS,CAAC,CAAD,CAAT,KAAiBC,SAAzC,GAAqDD,SAAS,CAAC,CAAD,CAA9D,GAAoE,EAAlG;AACA,UAAIsC,OAAO,GAAGtC,SAAS,CAACtB,MAAV,GAAmB,CAAnB,GAAuBsB,SAAS,CAAC,CAAD,CAAhC,GAAsCC,SAApD;AACA,UAAI8C,YAAY,GAAG/C,SAAS,CAACtB,MAAV,GAAmB,CAAnB,GAAuBsB,SAAS,CAAC,CAAD,CAAhC,GAAsCC,SAAzD;AACA,aAAO,KAAKK,oBAAL,CAA0BiC,oBAA1B,CAA+C1B,WAA/C,EAA4DuB,kBAA5D,EAAgFC,uBAAhF,EAAyGC,OAAzG,EAAkHS,YAAlH,CAAP;AACD;AACD;AACJ;AACA;AACA;;AAZK,GAlV2B,EAgW3B;AACD9D,IAAAA,GAAG,EAAE,sBADJ;AAEDY,IAAAA,KAAK,EAAE,SAASoD,oBAAT,CAA8BpC,WAA9B,EAA2C;AAChD,aAAO,KAAKP,oBAAL,CAA0BmC,cAA1B,CAAyC5B,WAAzC,CAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAbK,GAhW2B,EA+W3B;AACD5B,IAAAA,GAAG,EAAE,qBADJ;AAEDY,IAAAA,KAAK,EAAE,SAASqD,mBAAT,CAA6BP,KAA7B,EAAoC;AACzC,aAAO,KAAKrC,oBAAL,CAA0BoC,aAA1B,CAAwCC,KAAxC,CAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAbK,GA/W2B,EA8X3B;AACD1D,IAAAA,GAAG,EAAE,sBADJ;AAEDY,IAAAA,KAAK,EAAE,SAASsD,oBAAT,CAA8BR,KAA9B,EAAqC;AAC1C,aAAO,KAAKrC,oBAAL,CAA0BsC,cAA1B,CAAyCD,KAAzC,CAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAbK,GA9X2B,EA6Y3B;AACD1D,IAAAA,GAAG,EAAE,mBADJ;AAEDY,IAAAA,KAAK,EAAE,SAASuD,iBAAT,CAA2BT,KAA3B,EAAkC;AACvC,aAAO,KAAKrC,oBAAL,CAA0BuC,WAA1B,CAAsCF,KAAtC,CAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;;AAVK,GA7Y2B,EAyZ3B;AACD1D,IAAAA,GAAG,EAAE,aADJ;AAEDY,IAAAA,KAAK,EAAE,SAASwD,WAAT,CAAqBV,KAArB,EAA4B;AACjC,WAAKtC,uBAAL,CAA6BiD,kBAA7B,GAAkDD,WAAlD,CAA8DV,KAA9D;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;;AAVK,GAzZ2B,EAqa3B;AACD1D,IAAAA,GAAG,EAAE,sBADJ;AAEDY,IAAAA,KAAK,EAAE,SAAS0D,oBAAT,CAA8BZ,KAA9B,EAAqC;AAC1C,WAAKtC,uBAAL,CAA6BiD,kBAA7B,GAAkDC,oBAAlD,CAAuEZ,KAAvE;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAZK,GAra2B,EAmb3B;AACD1D,IAAAA,GAAG,EAAE,4BADJ;AAEDY,IAAAA,KAAK,EAAE,SAAS2D,0BAAT,CAAoCC,OAApC,EAA6CC,WAA7C,EAA0D;AAC/D,WAAKrD,uBAAL,CAA6BmD,0BAA7B,CAAwDC,OAAxD,EAAiEC,WAAjE;AACD;AAJA,GAnb2B,EAwb3B;AACDzE,IAAAA,GAAG,EAAE,0BADJ;AAEDY,IAAAA,KAAK,EAAE,SAAS8D,wBAAT,CAAkC1E,GAAlC,EAAuC2E,IAAvC,EAA6C;AAClD,UAAIC,mBAAmB,GAAG,KAAKxD,uBAAL,CAA6ByD,eAA7B,CAA6CC,sBAA7C,EAA1B;;AAEA,UAAIF,mBAAmB,CAACG,QAApB,CAA6B/E,GAA7B,KAAqC4E,mBAAmB,CAACI,cAApB,CAAmCL,IAAnC,CAAzC,EAAmF;AACjF,YAAIC,mBAAmB,CAACK,SAApB,EAAJ,EAAqC;AACnC,iBAAOvE,aAAa,CAACwE,OAArB;AACD,SAFD,MAEO,IAAIN,mBAAmB,CAACO,eAApB,EAAJ,EAA2C;AAChD,iBAAOzE,aAAa,CAAC0E,OAArB;AACD,SAFM,MAEA;AACL,iBAAO1E,aAAa,CAAC2E,IAArB;AACD;AACF,OARD,MAQO;AACL,eAAO3E,aAAa,CAAC4E,MAArB;AACD;AACF;AAhBA,GAxb2B,EAyc3B;AACDtF,IAAAA,GAAG,EAAE,+BADJ;AAEDY,IAAAA,KAAK,EAAE,SAAS2E,6BAAT,GAAyC;AAC9C,WAAKnE,uBAAL,CAA6BmE,6BAA7B;AACD;AAJA,GAzc2B,EA8c3B;AACDvF,IAAAA,GAAG,EAAE,4BADJ;AAEDY,IAAAA,KAAK,EAAE,SAAS4E,0BAAT,GAAsC;AAC3C,WAAKpE,uBAAL,CAA6BoE,0BAA7B;AACD;AAJA,GA9c2B,EAmd3B;AACDxF,IAAAA,GAAG,EAAE,wBADJ;AAEDY,IAAAA,KAAK,EAAE,SAAS6E,sBAAT,GAAkC;AACvC,aAAO,KAAKpE,oBAAL,CAA0BqE,cAAjC;AACD;AAJA,GAnd2B,CAAlB,CAAZ;;AA0dA,SAAO/E,eAAP;AACD,CAhhBD,EAFA;;AAohBA,eAAeA,eAAf","sourcesContent":["function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\r\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\r\n\r\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\r\n\r\nimport Logger from './logging/Logger';\r\nimport FocusOnlyKeyEventStrategy from './strategies/FocusOnlyKeyEventStrategy';\r\nimport GlobalKeyEventStrategy from './strategies/GlobalKeyEventStrategy';\r\nimport isFromFocusOnlyComponent from '../helpers/resolving-handlers/isFromFocusOnlyComponent';\r\nimport Configuration from './config/Configuration';\r\nimport EventResponse from '../const/EventResponse';\r\n/**\r\n * Provides a registry for keyboard sequences and events, and the handlers that should\r\n * be called when they are detected. Also contains the interface for processing and\r\n * matching keyboard events against its list of registered actions and handlers.\r\n * @class\r\n */\r\n\r\nvar KeyEventManager =\r\n/*#__PURE__*/\r\nfunction () {\r\n  _createClass(KeyEventManager, null, [{\r\n    key: \"getInstance\",\r\n\r\n    /**\r\n     * Creates a new KeyEventManager instance if one does not already exist or returns the\r\n     * instance that already exists.\r\n     * @param {Object} configuration Configuration object\r\n     * @param {Logger} configuration.logger Logger instance\r\n     * @returns {KeyEventManager} The key event manager instance\r\n     */\r\n    value: function getInstance() {\r\n      var configuration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\r\n\r\n      if (!this.instance) {\r\n        this.instance = new KeyEventManager(configuration);\r\n      }\r\n\r\n      return this.instance;\r\n    }\r\n  }, {\r\n    key: \"clear\",\r\n    value: function clear() {\r\n      delete this.instance;\r\n    }\r\n    /**\r\n     * Creates a new KeyEventManager instance. It is expected that only a single instance\r\n     * will be used with a render tree.\r\n     */\r\n\r\n  }]);\r\n\r\n  function KeyEventManager() {\r\n    var configuration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\r\n\r\n    _classCallCheck(this, KeyEventManager);\r\n\r\n    this.logger = configuration.logger || new Logger(Configuration.option('logLevel'));\r\n    this._focusOnlyEventStrategy = new FocusOnlyKeyEventStrategy({\r\n      configuration: configuration,\r\n      logger: this.logger\r\n    }, this);\r\n    this._globalEventStrategy = new GlobalKeyEventStrategy({\r\n      configuration: configuration,\r\n      logger: this.logger\r\n    }, this);\r\n    this.mountedComponentsCount = 0;\r\n  }\r\n  /********************************************************************************\r\n   * Generating key maps\r\n   ********************************************************************************/\r\n\r\n\r\n  _createClass(KeyEventManager, [{\r\n    key: \"getApplicationKeyMap\",\r\n    value: function getApplicationKeyMap() {\r\n      return Object.assign(this._globalEventStrategy.getApplicationKeyMap(), this._focusOnlyEventStrategy.getApplicationKeyMap());\r\n    }\r\n    /********************************************************************************\r\n     * Registering key maps\r\n     ********************************************************************************/\r\n\r\n    /**\r\n     * Registers a new mounted component's key map so that it can be included in the\r\n     * application's key map\r\n     * @param {KeyMap} keyMap - Map of actions to key expressions\r\n     * @returns {ComponentId} Unique component ID to assign to the focused HotKeys\r\n     *          component and passed back when handling a key event\r\n     */\r\n\r\n  }, {\r\n    key: \"registerKeyMap\",\r\n    value: function registerKeyMap() {\r\n      var keyMap = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\r\n      return this._focusOnlyEventStrategy.registerKeyMap(keyMap);\r\n    }\r\n    /**\r\n     * Re-registers (updates) a mounted component's key map\r\n     * @param {ComponentId} componentId - Id of the component that the keyMap belongs to\r\n     * @param {KeyMap} keyMap - Map of actions to key expressions\r\n     */\r\n\r\n  }, {\r\n    key: \"reregisterKeyMap\",\r\n    value: function reregisterKeyMap(componentId) {\r\n      var keyMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\r\n\r\n      this._focusOnlyEventStrategy.reregisterKeyMap(componentId, keyMap);\r\n    }\r\n    /**\r\n     * De-registers (removes) a mounted component's key map from the registry\r\n     * @param {ComponentId} componentId - Id of the component that the keyMap belongs to\r\n     */\r\n\r\n  }, {\r\n    key: \"deregisterKeyMap\",\r\n    value: function deregisterKeyMap(componentId) {\r\n      this._focusOnlyEventStrategy.deregisterKeyMap(componentId);\r\n    }\r\n    /**\r\n     * Registers that a component has now mounted, and declares its parent HotKeys\r\n     * component id so that actions may be properly resolved\r\n     * @param {ComponentId} componentId - Id of the component that has mounted\r\n     * @param {ComponentId} parentId - Id of the parent HotKeys component\r\n     */\r\n\r\n  }, {\r\n    key: \"registerComponentMount\",\r\n    value: function registerComponentMount(componentId, parentId) {\r\n      this._incrementComponentCount();\r\n\r\n      return this._focusOnlyEventStrategy.registerComponentMount(componentId, parentId);\r\n    }\r\n  }, {\r\n    key: \"registerComponentUnmount\",\r\n    value: function registerComponentUnmount() {\r\n      this._decrementComponentCount();\r\n    }\r\n  }, {\r\n    key: \"_incrementComponentCount\",\r\n    value: function _incrementComponentCount() {\r\n      var _this = this;\r\n\r\n      var preMountedComponentCount = this.mountedComponentsCount;\r\n      this.mountedComponentsCount += 1;\r\n\r\n      if (preMountedComponentCount === 0 && this.mountedComponentsCount === 1) {\r\n        window.onblur = function () {\r\n          return _this._clearKeyHistory();\r\n        };\r\n      }\r\n    }\r\n  }, {\r\n    key: \"_decrementComponentCount\",\r\n    value: function _decrementComponentCount() {\r\n      var preMountedComponentCount = this.mountedComponentsCount;\r\n      this.mountedComponentsCount -= 1;\r\n\r\n      if (preMountedComponentCount === 1 && this.mountedComponentsCount === 0) {\r\n        delete window.onblur;\r\n      }\r\n    }\r\n  }, {\r\n    key: \"_clearKeyHistory\",\r\n    value: function _clearKeyHistory() {\r\n      this.logger.info('HotKeys: Window focused - clearing key history');\r\n\r\n      this._focusOnlyEventStrategy.resetKeyHistory({\r\n        force: true\r\n      });\r\n\r\n      this._globalEventStrategy.resetKeyHistory({\r\n        force: true\r\n      });\r\n    }\r\n    /**\r\n     * Registers a new mounted component's global key map so that it can be included in the\r\n     * application's key map\r\n     * @param {KeyMap} keyMap - Map of actions to key expressions\r\n     * @returns {ComponentId} Unique component ID to assign to the focused HotKeys\r\n     *          component and passed back when handling a key event\r\n     */\r\n\r\n  }, {\r\n    key: \"registerGlobalKeyMap\",\r\n    value: function registerGlobalKeyMap() {\r\n      var keyMap = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\r\n      return this._globalEventStrategy.registerKeyMap(keyMap);\r\n    }\r\n  }, {\r\n    key: \"registerGlobalComponentUnmount\",\r\n    value: function registerGlobalComponentUnmount() {\r\n      this._decrementComponentCount();\r\n    }\r\n    /**\r\n     * Registers that a component has now mounted, and declares its parent GlobalHotKeys\r\n     * component id so that actions may be properly resolved\r\n     * @param {ComponentId} componentId - Id of the component that has mounted\r\n     * @param {ComponentId} parentId - Id of the parent GlobalHotKeys component\r\n     */\r\n\r\n  }, {\r\n    key: \"registerGlobalComponentMount\",\r\n    value: function registerGlobalComponentMount(componentId, parentId) {\r\n      this._incrementComponentCount();\r\n\r\n      return this._globalEventStrategy.registerComponentMount(componentId, parentId);\r\n    }\r\n    /**\r\n     * Re-registers (updates) a mounted component's global key map\r\n     * @param {ComponentId} componentId - Id of the component that the keyMap belongs to\r\n     * @param {KeyMap} keyMap - Map of actions to key expressions\r\n     */\r\n\r\n  }, {\r\n    key: \"reregisterGlobalKeyMap\",\r\n    value: function reregisterGlobalKeyMap(componentId, keyMap) {\r\n      this._globalEventStrategy.reregisterKeyMap(componentId, keyMap);\r\n    }\r\n    /**\r\n     * De-registers (removes) a mounted component's global key map from the registry\r\n     * @param {ComponentId} componentId - Id of the component that the keyMap belongs to\r\n     */\r\n\r\n  }, {\r\n    key: \"deregisterGlobalKeyMap\",\r\n    value: function deregisterGlobalKeyMap(componentId) {\r\n      this._globalEventStrategy.deregisterKeyMap(componentId);\r\n    }\r\n    /********************************************************************************\r\n     * Recording key combination\r\n     ********************************************************************************/\r\n\r\n    /**\r\n     * Adds a listener function that will be called the next time a key combination completes\r\n     * @param {keyCombinationListener} callbackFunction Listener function to be called\r\n     * @returns {function} Function to call to cancel listening to the next key combination\r\n     */\r\n\r\n  }, {\r\n    key: \"addKeyCombinationListener\",\r\n    value: function addKeyCombinationListener(callbackFunction) {\r\n      return this._globalEventStrategy.addKeyCombinationListener(callbackFunction);\r\n    }\r\n    /********************************************************************************\r\n     * Focus key events\r\n     ********************************************************************************/\r\n\r\n    /**\r\n     * Registers the actions and handlers of a HotKeys component that has gained focus\r\n     * @param {ComponentId} componentId - Id of the component that the keyMap belongs to\r\n     * @param {KeyMap} actionNameToKeyMap - Map of actions to key expressions\r\n     * @param {HandlersMap} actionNameToHandlersMap - Map of actions to handler functions\r\n     * @param {Object} options Hash of options that configure how the actions\r\n     *        and handlers are associated and called.\r\n     * @returns {FocusTreeId} The current focus tree's ID\r\n     */\r\n\r\n  }, {\r\n    key: \"enableHotKeys\",\r\n    value: function enableHotKeys(componentId) {\r\n      var actionNameToKeyMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\r\n      var actionNameToHandlersMap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\r\n      var options = arguments.length > 3 ? arguments[3] : undefined;\r\n      return this._focusOnlyEventStrategy.enableHotKeys(componentId, actionNameToKeyMap, actionNameToHandlersMap, options);\r\n    }\r\n    /**\r\n     * Handles when a HotKeys component that is in focus updates its props and changes\r\n     * either the keyMap or handlers prop value\r\n     * @param {FocusTreeId} focusTreeId - The ID of the focus tree the component is part of.\r\n     *        Used to identify (and ignore) stale updates.\r\n     * @param {ComponentId} componentId - The component index of the component to\r\n     *        update\r\n     * @param {KeyMap} actionNameToKeyMap - Map of key sequences to action names\r\n     * @param {HandlersMap} actionNameToHandlersMap - Map of action names to handler\r\n     *        functions\r\n     * @param {Object} options Hash of options that configure how the actions\r\n     *        and handlers are associated and called.\r\n     */\r\n\r\n  }, {\r\n    key: \"updateEnabledHotKeys\",\r\n    value: function updateEnabledHotKeys(focusTreeId, componentId) {\r\n      var actionNameToKeyMap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\r\n      var actionNameToHandlersMap = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\r\n      var options = arguments.length > 4 ? arguments[4] : undefined;\r\n      return this._focusOnlyEventStrategy.updateEnabledHotKeys(focusTreeId, componentId, actionNameToKeyMap, actionNameToHandlersMap, options);\r\n    }\r\n    /**\r\n     * Handles when a component loses focus by resetting the internal state, ready to\r\n     * receive the next tree of focused HotKeys components\r\n     * @param {FocusTreeId} focusTreeId - Id of focus tree component thinks it's\r\n     *        apart of\r\n     * @param {ComponentId} componentId - Index of component that is blurring\r\n     * @returns {boolean} Whether the component still has event propagation yet to handle\r\n     */\r\n\r\n  }, {\r\n    key: \"disableHotKeys\",\r\n    value: function disableHotKeys(focusTreeId, componentId) {\r\n      return this._focusOnlyEventStrategy.disableHotKeys(focusTreeId, componentId);\r\n    }\r\n    /**\r\n     * Records a keydown keyboard event and matches it against the list of pre-registered\r\n     * event handlers, calling the first matching handler with the highest priority if\r\n     * one exists.\r\n     *\r\n     * This method is called many times as a keyboard event bubbles up through the React\r\n     * render tree. The event is only registered the first time it is seen and results\r\n     * of some calculations are cached. The event is matched against the handlers registered\r\n     * at each component level, to ensure the proper handler declaration scoping.\r\n     * @param {KeyboardEvent} event - Event containing the key name and state\r\n     * @param {FocusTreeId} focusTreeId - Id of focus tree component thinks it's apart of\r\n     * @param {ComponentId} componentId - The id of the component that is currently handling\r\n     *        the keyboard event as it bubbles towards the document root.\r\n     * @param {Object} options - Hash of options that configure how the event is handled.\r\n     * @returns Whether the event was discarded because it was part of an old focus tree\r\n     */\r\n\r\n  }, {\r\n    key: \"handleKeydown\",\r\n    value: function handleKeydown(event, focusTreeId, componentId, options) {\r\n      if (isFromFocusOnlyComponent(focusTreeId)) {\r\n        return this._focusOnlyEventStrategy.handleKeydown(event, focusTreeId, componentId, options);\r\n      }\r\n    }\r\n    /**\r\n     * Records a keypress keyboard event and matches it against the list of pre-registered\r\n     * event handlers, calling the first matching handler with the highest priority if\r\n     * one exists.\r\n     *\r\n     * This method is called many times as a keyboard event bubbles up through the React\r\n     * render tree. The event is only registered the first time it is seen and results\r\n     * of some calculations are cached. The event is matched against the handlers registered\r\n     * at each component level, to ensure the proper handler declaration scoping.\r\n     * @param {KeyboardEvent} event - Event containing the key name and state\r\n     * @param {FocusTreeId} focusTreeId Id - of focus tree component thinks it's apart of\r\n     * @param {ComponentId} componentId - The index of the component that is currently handling\r\n     *        the keyboard event as it bubbles towards the document root.\r\n     * @param {Object} options - Hash of options that configure how the event\r\n     *        is handled.\r\n     */\r\n\r\n  }, {\r\n    key: \"handleKeyPress\",\r\n    value: function handleKeyPress(event, focusTreeId, componentId, options) {\r\n      if (isFromFocusOnlyComponent(focusTreeId)) {\r\n        return this._focusOnlyEventStrategy.handleKeyPress(event, focusTreeId, componentId, options);\r\n      }\r\n    }\r\n    /**\r\n     * Records a keyup keyboard event and matches it against the list of pre-registered\r\n     * event handlers, calling the first matching handler with the highest priority if\r\n     * one exists.\r\n     *\r\n     * This method is called many times as a keyboard event bubbles up through the React\r\n     * render tree. The event is only registered the first time it is seen and results\r\n     * of some calculations are cached. The event is matched against the handlers registered\r\n     * at each component level, to ensure the proper handler declaration scoping.\r\n     * @param {KeyboardEvent} event Event containing the key name and state\r\n     * @param {FocusTreeId} focusTreeId Id of focus tree component thinks it's apart of\r\n     * @param {ComponentId} componentId The index of the component that is currently handling\r\n     *        the keyboard event as it bubbles towards the document root.\r\n     * @param {Object} options Hash of options that configure how the event\r\n     *        is handled.\r\n     */\r\n\r\n  }, {\r\n    key: \"handleKeyUp\",\r\n    value: function handleKeyUp(event, focusTreeId, componentId, options) {\r\n      if (isFromFocusOnlyComponent(focusTreeId)) {\r\n        return this._focusOnlyEventStrategy.handleKeyUp(event, focusTreeId, componentId, options);\r\n      }\r\n    }\r\n    /********************************************************************************\r\n     * Global key events\r\n     ********************************************************************************/\r\n\r\n    /**\r\n     * Registers the actions and handlers of a HotKeys component that has mounted\r\n     * @param {ComponentId} componentId - Id of the component that the keyMap belongs to\r\n     * @param {KeyMap} actionNameToKeyMap - Map of actions to key expressions\r\n     * @param {HandlersMap} actionNameToHandlersMap - Map of actions to handler functions\r\n     * @param {Object} options Hash of options that configure how the actions\r\n     *        and handlers are associated and called.\r\n     * @param {Object} eventOptions - Options for how the event should be handled\r\n     * @returns {ComponentId} A unique component ID to assign to the focused HotKeys\r\n     *        component and passed back when handling a key event\r\n     */\r\n\r\n  }, {\r\n    key: \"enableGlobalHotKeys\",\r\n    value: function enableGlobalHotKeys(componentId) {\r\n      var actionNameToKeyMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\r\n      var actionNameToHandlersMap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\r\n      var options = arguments.length > 3 ? arguments[3] : undefined;\r\n      var eventOptions = arguments.length > 4 ? arguments[4] : undefined;\r\n      return this._globalEventStrategy.enableHotKeys(componentId, actionNameToKeyMap, actionNameToHandlersMap, options, eventOptions);\r\n    }\r\n    /**\r\n     * Handles when a mounted global HotKeys component updates its props and changes\r\n     * either the keyMap or handlers prop value\r\n     * @param {ComponentId} componentId - The component index of the component to\r\n     *        update\r\n     * @param {KeyMap} actionNameToKeyMap - Map of actions to key expressions\r\n     * @param {HandlersMap} actionNameToHandlersMap - Map of actions to handler functions\r\n     * @param {Object} options Hash of options that configure how the actions\r\n     *        and handlers are associated and called.\r\n     * @param {Object} eventOptions - Options for how the event should be handled\r\n     */\r\n\r\n  }, {\r\n    key: \"updateEnabledGlobalHotKeys\",\r\n    value: function updateEnabledGlobalHotKeys(componentId) {\r\n      var actionNameToKeyMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\r\n      var actionNameToHandlersMap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\r\n      var options = arguments.length > 3 ? arguments[3] : undefined;\r\n      var eventOptions = arguments.length > 4 ? arguments[4] : undefined;\r\n      return this._globalEventStrategy.updateEnabledHotKeys(componentId, actionNameToKeyMap, actionNameToHandlersMap, options, eventOptions);\r\n    }\r\n    /**\r\n     * Handles when a component is unmounted\r\n     * @param {ComponentId} componentId - Index of component that is being unmounted\r\n     */\r\n\r\n  }, {\r\n    key: \"disableGlobalHotKeys\",\r\n    value: function disableGlobalHotKeys(componentId) {\r\n      return this._globalEventStrategy.disableHotKeys(componentId);\r\n    }\r\n    /**\r\n     * Records a keydown keyboard event and matches it against the list of pre-registered\r\n     * event handlers, calling the first matching handler with the highest priority if\r\n     * one exists.\r\n     *\r\n     * This method is called once when a keyboard event bubbles up to document, and checks\r\n     * the keymaps for all of the mounted global HotKey components.\r\n     * @param {KeyboardEvent} event - Event containing the key name and state\r\n     */\r\n\r\n  }, {\r\n    key: \"handleGlobalKeyDown\",\r\n    value: function handleGlobalKeyDown(event) {\r\n      return this._globalEventStrategy.handleKeydown(event);\r\n    }\r\n    /**\r\n     * Records a keypress keyboard event and matches it against the list of pre-registered\r\n     * event handlers, calling the first matching handler with the highest priority if\r\n     * one exists.\r\n     *\r\n     * This method is called once when a keyboard event bubbles up to document, and checks\r\n     * the keymaps for all of the mounted global HotKey components.\r\n     * @param {KeyboardEvent} event - Event containing the key name and state\r\n     */\r\n\r\n  }, {\r\n    key: \"handleGlobalKeyPress\",\r\n    value: function handleGlobalKeyPress(event) {\r\n      return this._globalEventStrategy.handleKeyPress(event);\r\n    }\r\n    /**\r\n     * Records a keyup keyboard event and matches it against the list of pre-registered\r\n     * event handlers, calling the first matching handler with the highest priority if\r\n     * one exists.\r\n     *\r\n     * This method is called once when a keyboard event bubbles up to document, and checks\r\n     * the keymaps for all of the mounted global HotKey components.\r\n     * @param {KeyboardEvent} event - Event containing the key name and state\r\n     */\r\n\r\n  }, {\r\n    key: \"handleGlobalKeyUp\",\r\n    value: function handleGlobalKeyUp(event) {\r\n      return this._globalEventStrategy.handleKeyUp(event);\r\n    }\r\n    /**\r\n     * Ignores the next keyboard event immediately, rather than waiting for it to\r\n     * match the ignoreEventsCondition\r\n     * @param {KeyboardEvent} event keyboard event to ignore\r\n     * @see Configuration.ignoreEventsCondition\r\n     */\r\n\r\n  }, {\r\n    key: \"ignoreEvent\",\r\n    value: function ignoreEvent(event) {\r\n      this._focusOnlyEventStrategy.getEventPropagator().ignoreEvent(event);\r\n    }\r\n    /**\r\n     * Forces the observation of the next keyboard event immediately, disregarding whether\r\n     * the event matches the ignoreKeyEventsCondition\r\n     * @param {KeyboardEvent} event keyboard event to force the observation of\r\n     * @see Configuration.ignoreEventsCondition\r\n     */\r\n\r\n  }, {\r\n    key: \"observeIgnoredEvents\",\r\n    value: function observeIgnoredEvents(event) {\r\n      this._focusOnlyEventStrategy.getEventPropagator().observeIgnoredEvents(event);\r\n    }\r\n    /**\r\n     * Closes any hanging key combinations that have not received the key event indicated\r\n     * by recordIndex.\r\n     * @param {KeyName} keyName The name of the key whose state should be updated if it\r\n     *        is currently set to keydown or keypress.\r\n     * @param {KeyEventType} recordIndex Index of key event to move the key state\r\n     *        up to.\r\n     */\r\n\r\n  }, {\r\n    key: \"closeHangingKeyCombination\",\r\n    value: function closeHangingKeyCombination(keyName, recordIndex) {\r\n      this._focusOnlyEventStrategy.closeHangingKeyCombination(keyName, recordIndex);\r\n    }\r\n  }, {\r\n    key: \"reactAppHistoryWithEvent\",\r\n    value: function reactAppHistoryWithEvent(key, type) {\r\n      var previousPropagation = this._focusOnlyEventStrategy.eventPropagator.getPreviousPropagation();\r\n\r\n      if (previousPropagation.isForKey(key) && previousPropagation.isForEventType(type)) {\r\n        if (previousPropagation.isHandled()) {\r\n          return EventResponse.handled;\r\n        } else if (previousPropagation.isIgnoringEvent()) {\r\n          return EventResponse.ignored;\r\n        } else {\r\n          return EventResponse.seen;\r\n        }\r\n      } else {\r\n        return EventResponse.unseen;\r\n      }\r\n    }\r\n  }, {\r\n    key: \"simulatePendingKeyPressEvents\",\r\n    value: function simulatePendingKeyPressEvents() {\r\n      this._focusOnlyEventStrategy.simulatePendingKeyPressEvents();\r\n    }\r\n  }, {\r\n    key: \"simulatePendingKeyUpEvents\",\r\n    value: function simulatePendingKeyUpEvents() {\r\n      this._focusOnlyEventStrategy.simulatePendingKeyUpEvents();\r\n    }\r\n  }, {\r\n    key: \"isGlobalListenersBound\",\r\n    value: function isGlobalListenersBound() {\r\n      return this._globalEventStrategy.listenersBound;\r\n    }\r\n  }]);\r\n\r\n  return KeyEventManager;\r\n}();\r\n\r\nexport default KeyEventManager;"]},"metadata":{},"sourceType":"module"}