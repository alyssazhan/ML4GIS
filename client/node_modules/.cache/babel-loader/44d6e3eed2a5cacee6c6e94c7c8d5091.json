{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport KeyCombination from './KeyCombination';\n/**\n * List of key combinations seen by hot key components\n * @class\n */\n\nvar KeyHistory = /*#__PURE__*/function () {\n  /**\n   * Creates a new KeyHistory instance\n   * @param {Number} maxLength Maximum length of the list.\n   * @param {KeyCombination} startingPoint Initial state of first combination\n   * @returns {KeyHistory}\n   */\n  function KeyHistory(_ref) {\n    var maxLength = _ref.maxLength;\n    var startingPoint = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    _classCallCheck(this, KeyHistory);\n\n    this._records = [];\n    this._maxLength = maxLength;\n\n    if (startingPoint) {\n      this._push(startingPoint);\n    } else {\n      this._push(new KeyCombination());\n    }\n  }\n  /**\n   * A subset of the most recently press key combinations\n   * @param {Number} numberOfCombinations The number of most recent key combinations\n   * @returns {KeyCombination[]} List of key combinations\n   */\n\n\n  _createClass(KeyHistory, [{\n    key: \"getMostRecentCombinations\",\n    value: function getMostRecentCombinations(numberOfCombinations) {\n      return this._records.slice(-numberOfCombinations, -1);\n    }\n    /**\n     * Whether any keys have been stored in the key history\n     * @returns {boolean} true if there is at least one key combination, else false\n     */\n\n  }, {\n    key: \"any\",\n    value: function any() {\n      return this._records.some(function (keyCombination) {\n        return keyCombination.any();\n      });\n    }\n    /**\n     * The number of key combinations in the history (limited by the max length)\n     * @returns {number} Number of key combinations\n     */\n\n  }, {\n    key: \"getLength\",\n    value: function getLength() {\n      return this._records.length;\n    }\n    /**\n     * Most recent or current key combination\n     * @returns {KeyCombination} Key combination record\n     */\n\n  }, {\n    key: \"getCurrentCombination\",\n    value: function getCurrentCombination() {\n      return this._records[this.getLength() - 1];\n    }\n    /**\n     * Adds a key event to the current key combination (as opposed to starting a new\n     * keyboard combination).\n     * @param {ReactKeyName} keyName - Name of the key to add to the current combination\n     * @param {KeyEventType} recordIndex - Index in record to set to true\n     * @param {KeyEventState} keyEventState The state to set the key event to\n     */\n\n  }, {\n    key: \"addKeyToCurrentCombination\",\n    value: function addKeyToCurrentCombination(keyName, recordIndex, keyEventState) {\n      this._ensureInitialKeyCombination();\n\n      this.getCurrentCombination().setKeyState(keyName, recordIndex, keyEventState);\n    }\n    /**\n     * Sets a new maximum length for the key combination history. Once the number of\n     * key combinations exceeds this length, the oldest is dropped.\n     * @param {Number} length New maximum length of the key history\n     */\n\n  }, {\n    key: \"setMaxLength\",\n    value: function setMaxLength(length) {\n      this._maxLength = length;\n\n      this._trimHistory();\n    }\n    /**\n     * Adds a new KeyCombination to the event history.\n     * @param {ReactKeyName} keyName - Name of the keyboard key to add to the new\n     *        KeyCombination\n     * @param {KeyEventState} keyEventState The state to set the key event to\n     */\n\n  }, {\n    key: \"startNewKeyCombination\",\n    value: function startNewKeyCombination(keyName, keyEventState) {\n      this._ensureInitialKeyCombination();\n\n      var newCombinationRecord = new KeyCombination(this.getCurrentCombination().keysStillPressedDict());\n      newCombinationRecord.addKey(keyName, keyEventState);\n\n      this._push(newCombinationRecord);\n    }\n    /**\n     * A plain JavaScript representation of the key combination history, useful for\n     * serialization or debugging\n     * @returns {Object[]} Serialized representation of the registry\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return this._records.map(function (keyCombination) {\n        return keyCombination.toJSON();\n      });\n    }\n    /********************************************************************************\n     * Private methods\n     ********************************************************************************/\n\n  }, {\n    key: \"_ensureInitialKeyCombination\",\n    value: function _ensureInitialKeyCombination() {\n      if (this.getLength() === 0) {\n        this._push(new KeyCombination());\n      }\n    }\n  }, {\n    key: \"_push\",\n    value: function _push(record) {\n      this._trimHistory();\n\n      this._records.push(record);\n    }\n  }, {\n    key: \"_trimHistory\",\n    value: function _trimHistory() {\n      while (this.getLength() > this._maxLength) {\n        /**\n         * We know the longest key sequence registered for the currently focused\n         * components, so we don't need to keep a record of history longer than\n         * that\n         */\n        this._shift();\n      }\n    }\n  }, {\n    key: \"_shift\",\n    value: function _shift() {\n      this._records.shift();\n    }\n  }]);\n\n  return KeyHistory;\n}();\n\nexport default KeyHistory;","map":{"version":3,"sources":["/Users/yan/Documents/proj/ML4GIS/client/node_modules/react-hotkeys/es/lib/listening/KeyHistory.js"],"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","KeyCombination","KeyHistory","_ref","maxLength","startingPoint","arguments","undefined","_records","_maxLength","_push","value","getMostRecentCombinations","numberOfCombinations","slice","any","some","keyCombination","getLength","getCurrentCombination","addKeyToCurrentCombination","keyName","recordIndex","keyEventState","_ensureInitialKeyCombination","setKeyState","setMaxLength","_trimHistory","startNewKeyCombination","newCombinationRecord","keysStillPressedDict","addKey","toJSON","map","record","push","_shift","shift"],"mappings":"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","sourcesContent":["function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nimport KeyCombination from './KeyCombination';\n/**\n * List of key combinations seen by hot key components\n * @class\n */\n\nvar KeyHistory =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Creates a new KeyHistory instance\n   * @param {Number} maxLength Maximum length of the list.\n   * @param {KeyCombination} startingPoint Initial state of first combination\n   * @returns {KeyHistory}\n   */\n  function KeyHistory(_ref) {\n    var maxLength = _ref.maxLength;\n    var startingPoint = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    _classCallCheck(this, KeyHistory);\n\n    this._records = [];\n    this._maxLength = maxLength;\n\n    if (startingPoint) {\n      this._push(startingPoint);\n    } else {\n      this._push(new KeyCombination());\n    }\n  }\n  /**\n   * A subset of the most recently press key combinations\n   * @param {Number} numberOfCombinations The number of most recent key combinations\n   * @returns {KeyCombination[]} List of key combinations\n   */\n\n\n  _createClass(KeyHistory, [{\n    key: \"getMostRecentCombinations\",\n    value: function getMostRecentCombinations(numberOfCombinations) {\n      return this._records.slice(-numberOfCombinations, -1);\n    }\n    /**\n     * Whether any keys have been stored in the key history\n     * @returns {boolean} true if there is at least one key combination, else false\n     */\n\n  }, {\n    key: \"any\",\n    value: function any() {\n      return this._records.some(function (keyCombination) {\n        return keyCombination.any();\n      });\n    }\n    /**\n     * The number of key combinations in the history (limited by the max length)\n     * @returns {number} Number of key combinations\n     */\n\n  }, {\n    key: \"getLength\",\n    value: function getLength() {\n      return this._records.length;\n    }\n    /**\n     * Most recent or current key combination\n     * @returns {KeyCombination} Key combination record\n     */\n\n  }, {\n    key: \"getCurrentCombination\",\n    value: function getCurrentCombination() {\n      return this._records[this.getLength() - 1];\n    }\n    /**\n     * Adds a key event to the current key combination (as opposed to starting a new\n     * keyboard combination).\n     * @param {ReactKeyName} keyName - Name of the key to add to the current combination\n     * @param {KeyEventType} recordIndex - Index in record to set to true\n     * @param {KeyEventState} keyEventState The state to set the key event to\n     */\n\n  }, {\n    key: \"addKeyToCurrentCombination\",\n    value: function addKeyToCurrentCombination(keyName, recordIndex, keyEventState) {\n      this._ensureInitialKeyCombination();\n\n      this.getCurrentCombination().setKeyState(keyName, recordIndex, keyEventState);\n    }\n    /**\n     * Sets a new maximum length for the key combination history. Once the number of\n     * key combinations exceeds this length, the oldest is dropped.\n     * @param {Number} length New maximum length of the key history\n     */\n\n  }, {\n    key: \"setMaxLength\",\n    value: function setMaxLength(length) {\n      this._maxLength = length;\n\n      this._trimHistory();\n    }\n    /**\n     * Adds a new KeyCombination to the event history.\n     * @param {ReactKeyName} keyName - Name of the keyboard key to add to the new\n     *        KeyCombination\n     * @param {KeyEventState} keyEventState The state to set the key event to\n     */\n\n  }, {\n    key: \"startNewKeyCombination\",\n    value: function startNewKeyCombination(keyName, keyEventState) {\n      this._ensureInitialKeyCombination();\n\n      var newCombinationRecord = new KeyCombination(this.getCurrentCombination().keysStillPressedDict());\n      newCombinationRecord.addKey(keyName, keyEventState);\n\n      this._push(newCombinationRecord);\n    }\n    /**\n     * A plain JavaScript representation of the key combination history, useful for\n     * serialization or debugging\n     * @returns {Object[]} Serialized representation of the registry\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return this._records.map(function (keyCombination) {\n        return keyCombination.toJSON();\n      });\n    }\n    /********************************************************************************\n     * Private methods\n     ********************************************************************************/\n\n  }, {\n    key: \"_ensureInitialKeyCombination\",\n    value: function _ensureInitialKeyCombination() {\n      if (this.getLength() === 0) {\n        this._push(new KeyCombination());\n      }\n    }\n  }, {\n    key: \"_push\",\n    value: function _push(record) {\n      this._trimHistory();\n\n      this._records.push(record);\n    }\n  }, {\n    key: \"_trimHistory\",\n    value: function _trimHistory() {\n      while (this.getLength() > this._maxLength) {\n        /**\n         * We know the longest key sequence registered for the currently focused\n         * components, so we don't need to keep a record of history longer than\n         * that\n         */\n        this._shift();\n      }\n    }\n  }, {\n    key: \"_shift\",\n    value: function _shift() {\n      this._records.shift();\n    }\n  }]);\n\n  return KeyHistory;\n}();\n\nexport default KeyHistory;"]},"metadata":{},"sourceType":"module"}