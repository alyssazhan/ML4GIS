{"ast":null,"code":"/*!\r\n  2D Transformation Matrix v2.7.5\r\n  (c) Epistemex.com 2014-2018\r\n  License: MIT\r\n*/\n\n/**\r\n * 2D transformation matrix object initialized with identity matrix.\r\n *\r\n * The matrix can synchronize a canvas 2D context by supplying the context\r\n * as an argument, or later apply current absolute transform to an\r\n * existing context.\r\n *\r\n * To synchronize a DOM element you can use [`toCSS()`]{@link Matrix#toCSS} or [`toCSS3D()`]{@link Matrix#toCSS3D}.\r\n * together with for example the `style.transform` property.\r\n *\r\n * @param {CanvasRenderingContext2D} [context] - Optional context to sync with Matrix\r\n * @param {HTMLElement} [element=null] - DOM Element to synchronize\r\n * @prop {number} a - scale x\r\n * @prop {number} b - shear y\r\n * @prop {number} c - shear x\r\n * @prop {number} d - scale y\r\n * @prop {number} e - translate x\r\n * @prop {number} f - translate y\r\n * @prop {CanvasRenderingContext2D} [context] - set or get current synchronized 2D context\r\n * @prop {HTMLElement} [element] - get current synchronized DOM element\r\n * @prop {boolean} [useCSS3D=false] - is a DOM element is defined for sync., choose whether to use 2D (false) or 3D (true) matrix to sync it.\r\n * @constructor\r\n * @license MIT license\r\n * @copyright Epistemex.com 2014-2018\r\n */\nfunction Matrix(context, element) {\n  var me = this,\n      _el;\n\n  me._t = me.transform;\n  me.a = me.d = 1;\n  me.b = me.c = me.e = me.f = 0; // sync context\n\n  if (context) (me.context = context).setTransform(1, 0, 0, 1, 0, 0); // sync DOM element\n\n  Object.defineProperty(me, \"element\", {\n    get: function get() {\n      return _el;\n    },\n    set: function set(el) {\n      if (!_el) {\n        me._px = me._getPX();\n        me.useCSS3D = false;\n      }\n\n      _el = el;\n      (me._st = _el.style)[me._px] = me.toCSS();\n    }\n  });\n  if (element) me.element = element;\n}\n/**\r\n * Returns a new matrix that transforms a triangle `t1` into another triangle\r\n * `t2`, or throws an exception if it is impossible.\r\n *\r\n * Note: the method can take both arrays as well as literal objects.\r\n * Just make sure that both arguments (`t1`, `t2`) are of the same type.\r\n *\r\n * @param {{px: number, py: number, qx: number, qy: number, rx: number, ry: number}|Array} t1 - Object or array containing the three points for the triangle.\r\n * For object use obj.px, obj.py, obj.qx, obj.qy, obj.rx and obj.ry. For arrays provide the points in the order [px, py, qx, qy, rx, ry], or as point array [{x:,y:}, {x:,y:}, {x:,y:}]\r\n * @param {{px: number, py: number, qx: number, qy: number, rx: number, ry: number}|Array} t2 - See description for t1.\r\n * @param {CanvasRenderingContext2D} [context] - optional canvas 2D context to use for the matrix\r\n * @returns {Matrix}\r\n * @throws Exception is matrix becomes not invertible\r\n * @static\r\n */\n\n\nMatrix.fromTriangles = function (t1, t2, context) {\n  var m1 = new Matrix(),\n      m2 = new Matrix(context),\n      r1,\n      r2,\n      rx1,\n      ry1,\n      rx2,\n      ry2;\n\n  if (Array.isArray(t1)) {\n    if (typeof t1[0] === \"number\") {\n      rx1 = t1[4];\n      ry1 = t1[5];\n      rx2 = t2[4];\n      ry2 = t2[5];\n      r1 = [t1[0] - rx1, t1[1] - ry1, t1[2] - rx1, t1[3] - ry1, rx1, ry1];\n      r2 = [t2[0] - rx2, t2[1] - ry2, t2[2] - rx2, t2[3] - ry2, rx2, ry2];\n    } else {\n      rx1 = t1[2].x;\n      ry1 = t1[2].y;\n      rx2 = t2[2].x;\n      ry2 = t2[2].y;\n      r1 = [t1[0].x - rx1, t1[0].y - ry1, t1[1].x - rx1, t1[1].y - ry1, rx1, ry1];\n      r2 = [t2[0].x - rx2, t2[0].y - ry2, t2[1].x - rx2, t2[1].y - ry2, rx2, ry2];\n    }\n  } else {\n    r1 = [t1.px - t1.rx, t1.py - t1.ry, t1.qx - t1.rx, t1.qy - t1.ry, t1.rx, t1.ry];\n    r2 = [t2.px - t2.rx, t2.py - t2.ry, t2.qx - t2.rx, t2.qy - t2.ry, t2.rx, t2.ry];\n  }\n\n  m1.setTransform.apply(m1, r1);\n  m2.setTransform.apply(m2, r2);\n  return m2.multiply(m1.inverse());\n};\n/**\r\n * Create a matrix from a transform list from an SVG shape. The list\r\n * can be for example baseVal (i.e. `shape.transform.baseVal`).\r\n *\r\n * The resulting matrix has all transformations from that list applied\r\n * in the same order as the list.\r\n *\r\n * @param {SVGTransformList} tList - transform list from an SVG shape.\r\n * @param {CanvasRenderingContext2D} [context] - optional canvas 2D context to use for the matrix\r\n * @param {HTMLElement} [dom] - optional DOM element to use for the matrix\r\n * @returns {Matrix}\r\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/SVGTransformList|MDN / SVGTransformList}\r\n */\n\n\nMatrix.fromSVGTransformList = function (tList, context, dom) {\n  var m = new Matrix(context, dom),\n      i = 0;\n\n  while (i < tList.length) m.multiply(tList[i++].matrix);\n\n  return m;\n};\n/**\r\n * Create and transform a new matrix based on given matrix values, or\r\n * provide SVGMatrix or a (2D) DOMMatrix, WebKitCSSMatrix or another\r\n * instance of a generic Matrix.\r\n *\r\n * @example\r\n *\r\n * var m = Matrix.from(1, 0.2, 0, 2, 120, 97);\r\n * var m = Matrix.from(domMatrix, ctx);\r\n * var m = Matrix.from(svgMatrix);\r\n * var m = Matrix.from(cssMatrix);\r\n * var m = Matrix.from(matrix);\r\n * var m = Matrix.from(vector [,pre-x] [,pre-y] [,doScale]);\r\n *\r\n * @param {*} a - number representing a in [a-f], or a Matrix object containing properties a-f. Vector is given as an object with properties x and y.\r\n * @param {*} [b] - b property if a is not a matrix object, or optional canvas 2D context.\r\n * If vector is input this will be pre-translate for x.\r\n * @param {number} [c] - If vector is input this will be pre-translate for y.\r\n * @param {number} [d] - If vector is input, set this to true to use scale and translate of 1,\r\n * false to use hypotenuse as translate distance instead and no scale.\r\n * @param {number} [e]\r\n * @param {number} [f]\r\n * @param {CanvasRenderingContext2D} [context] - optional canvas context to synchronize\r\n * @param {HTMLElement} [dom] - optional DOM element to use for the matrix\r\n * @returns {Matrix}\r\n * @static\r\n */\n\n\nMatrix.from = function (a, b, c, d, e, f, context, dom) {\n  var m = new Matrix(context, dom),\n      scale,\n      dist,\n      q;\n  if (typeof a === \"number\") m.setTransform(a, b, c, d, e, f);else if (typeof a.x === \"number\") {\n    // vector\n    q = Math.sqrt(a.x * a.x + a.y * a.y);\n    scale = dist = 1;\n    if (d) scale = q;else dist = q;\n    m.translate(b || 0, c || 0).rotateFromVector(a).scaleU(scale).translate(dist, 0);\n  } else {\n    if (typeof a.is2D === \"boolean\" && !a.is2D) throw \"Cannot use 3D DOMMatrix.\";\n    if (b) m.context = b;\n    if (c) m.element = c;\n    m.multiply(a);\n  }\n  return m;\n};\n\nMatrix.prototype = {\n  _getPX: function _getPX() {\n    var lst = [\"t\", \"oT\", \"msT\", \"mozT\", \"webkitT\", \"khtmlT\"],\n        i = 0,\n        p,\n        style = document.createElement(\"div\").style;\n\n    while (p = lst[i++]) if (typeof style[p + \"ransform\"] !== \"undefined\") return p + \"ransform\";\n  },\n\n  /**\r\n   * Concatenates transforms of this matrix onto the given child matrix and\r\n   * returns a new matrix. This instance is used on left side.\r\n   *\r\n   * @param {Matrix|SVGMatrix} cm - child matrix to apply concatenation to\r\n   * @returns {Matrix} - new Matrix instance\r\n   */\n  concat: function concat(cm) {\n    return this.clone().multiply(cm);\n  },\n\n  /**\r\n   * Flips the horizontal values.\r\n   * @returns {Matrix}\r\n   */\n  flipX: function flipX() {\n    return this._t(-1, 0, 0, 1, 0, 0);\n  },\n\n  /**\r\n   * Flips the vertical values.\r\n   * @returns {Matrix}\r\n   */\n  flipY: function flipY() {\n    return this._t(1, 0, 0, -1, 0, 0);\n  },\n\n  /**\r\n   * Reflects incoming (velocity) vector on the normal which will be the\r\n   * current transformed x axis. Call when a trigger condition is met.\r\n   *\r\n   * @param {number} x - vector end point for x (start = 0)\r\n   * @param {number} y - vector end point for y (start = 0)\r\n   * @returns {{x: number, y: number}}\r\n   */\n  reflectVector: function reflectVector(x, y) {\n    var v = this.applyToPoint(0, 1),\n        d = (v.x * x + v.y * y) * 2;\n    x -= d * v.x;\n    y -= d * v.y;\n    return {\n      x: x,\n      y: y\n    };\n  },\n\n  /**\r\n   * Short-hand to reset current matrix to an identity matrix.\r\n   * @returns {Matrix}\r\n   */\n  reset: function reset() {\n    return this.setTransform(1, 0, 0, 1, 0, 0);\n  },\n\n  /**\r\n   * Rotates current matrix by angle (accumulative).\r\n   * @param {number} angle - angle in radians\r\n   * @returns {Matrix}\r\n   */\n  rotate: function rotate(angle) {\n    var cos = Math.cos(angle),\n        sin = Math.sin(angle);\n    return this._t(cos, sin, -sin, cos, 0, 0);\n  },\n\n  /**\r\n   * Converts a vector given as `x` and `y` to angle, and\r\n   * rotates (accumulative). x can instead contain an object with\r\n   * properties x and y and if so, y parameter will be ignored.\r\n   * @param {number|*} x\r\n   * @param {number} [y]\r\n   * @returns {Matrix}\r\n   */\n  rotateFromVector: function rotateFromVector(x, y) {\n    return this.rotate(typeof x === \"number\" ? Math.atan2(y, x) : Math.atan2(x.y, x.x));\n  },\n\n  /**\r\n   * Helper method to make a rotation based on an angle in degrees.\r\n   * @param {number} angle - angle in degrees\r\n   * @returns {Matrix}\r\n   */\n  rotateDeg: function rotateDeg(angle) {\n    return this.rotate(angle * Math.PI / 180);\n  },\n\n  /**\r\n   * Scales current matrix uniformly and accumulative.\r\n   * @param {number} f - scale factor for both x and y (1 does nothing)\r\n   * @returns {Matrix}\r\n   */\n  scaleU: function scaleU(f) {\n    return this._t(f, 0, 0, f, 0, 0);\n  },\n\n  /**\r\n   * Scales current matrix accumulative.\r\n   * @param {number} sx - scale factor x (1 does nothing)\r\n   * @param {number} sy - scale factor y (1 does nothing)\r\n   * @returns {Matrix}\r\n   */\n  scale: function scale(sx, sy) {\n    return this._t(sx, 0, 0, sy, 0, 0);\n  },\n\n  /**\r\n   * Scales current matrix on x axis accumulative.\r\n   * @param {number} sx - scale factor x (1 does nothing)\r\n   * @returns {Matrix}\r\n   */\n  scaleX: function scaleX(sx) {\n    return this._t(sx, 0, 0, 1, 0, 0);\n  },\n\n  /**\r\n   * Scales current matrix on y axis accumulative.\r\n   * @param {number} sy - scale factor y (1 does nothing)\r\n   * @returns {Matrix}\r\n   */\n  scaleY: function scaleY(sy) {\n    return this._t(1, 0, 0, sy, 0, 0);\n  },\n\n  /**\r\n   * Converts a vector given as `x` and `y` to normalized scale.\r\n   * @param x\r\n   * @param y\r\n   * @returns {Matrix}\r\n   */\n  scaleFromVector: function scaleFromVector(x, y) {\n    return this.scaleU(Math.sqrt(x * x + y * y));\n  },\n\n  /**\r\n   * Apply shear to the current matrix accumulative.\r\n   * @param {number} sx - amount of shear for x\r\n   * @param {number} sy - amount of shear for y\r\n   * @returns {Matrix}\r\n   */\n  shear: function shear(sx, sy) {\n    return this._t(1, sy, sx, 1, 0, 0);\n  },\n\n  /**\r\n   * Apply shear for x to the current matrix accumulative.\r\n   * @param {number} sx - amount of shear for x\r\n   * @returns {Matrix}\r\n   */\n  shearX: function shearX(sx) {\n    return this._t(1, 0, sx, 1, 0, 0);\n  },\n\n  /**\r\n   * Apply shear for y to the current matrix accumulative.\r\n   * @param {number} sy - amount of shear for y\r\n   * @returns {Matrix}\r\n   */\n  shearY: function shearY(sy) {\n    return this._t(1, sy, 0, 1, 0, 0);\n  },\n\n  /**\r\n   * Apply skew to the current matrix accumulative. Angles in radians.\r\n   * Also see [`skewDeg()`]{@link Matrix#skewDeg}.\r\n   * @param {number} ax - angle of skew for x\r\n   * @param {number} ay - angle of skew for y\r\n   * @returns {Matrix}\r\n   */\n  skew: function skew(ax, ay) {\n    return this.shear(Math.tan(ax), Math.tan(ay));\n  },\n\n  /**\r\n   * Apply skew to the current matrix accumulative. Angles in degrees.\r\n   * Also see [`skew()`]{@link Matrix#skew}.\r\n   * @param {number} ax - angle of skew for x\r\n   * @param {number} ay - angle of skew for y\r\n   * @returns {Matrix}\r\n   */\n  skewDeg: function skewDeg(ax, ay) {\n    return this.shear(Math.tan(ax / 180 * Math.PI), Math.tan(ay / 180 * Math.PI));\n  },\n\n  /**\r\n   * Apply skew for x to the current matrix accumulative. Angles in radians.\r\n   * Also see [`skewDeg()`]{@link Matrix#skewDeg}.\r\n   * @param {number} ax - angle of skew for x\r\n   * @returns {Matrix}\r\n   */\n  skewX: function skewX(ax) {\n    return this.shearX(Math.tan(ax));\n  },\n\n  /**\r\n   * Apply skew for y to the current matrix accumulative. Angles in radians.\r\n   * Also see [`skewDeg()`]{@link Matrix#skewDeg}.\r\n   * @param {number} ay - angle of skew for y\r\n   * @returns {Matrix}\r\n   */\n  skewY: function skewY(ay) {\n    return this.shearY(Math.tan(ay));\n  },\n\n  /**\r\n   * Set current matrix to new absolute matrix.\r\n   * @param {number} a - scale x\r\n   * @param {number} b - shear y\r\n   * @param {number} c - shear x\r\n   * @param {number} d - scale y\r\n   * @param {number} e - translate x\r\n   * @param {number} f - translate y\r\n   * @returns {Matrix}\r\n   */\n  setTransform: function setTransform(a, b, c, d, e, f) {\n    var me = this;\n    me.a = a;\n    me.b = b;\n    me.c = c;\n    me.d = d;\n    me.e = e;\n    me.f = f;\n    return me._x();\n  },\n\n  /**\r\n   * Translate current matrix accumulative.\r\n   * @param {number} tx - translation for x\r\n   * @param {number} ty - translation for y\r\n   * @returns {Matrix}\r\n   */\n  translate: function translate(tx, ty) {\n    return this._t(1, 0, 0, 1, tx, ty);\n  },\n\n  /**\r\n   * Translate current matrix on x axis accumulative.\r\n   * @param {number} tx - translation for x\r\n   * @returns {Matrix}\r\n   */\n  translateX: function translateX(tx) {\n    return this._t(1, 0, 0, 1, tx, 0);\n  },\n\n  /**\r\n   * Translate current matrix on y axis accumulative.\r\n   * @param {number} ty - translation for y\r\n   * @returns {Matrix}\r\n   */\n  translateY: function translateY(ty) {\n    return this._t(1, 0, 0, 1, 0, ty);\n  },\n\n  /**\r\n   * Multiplies current matrix with new matrix values. Also see [`multiply()`]{@link Matrix#multiply}.\r\n   *\r\n   * @param {number} a2 - scale x\r\n   * @param {number} b2 - skew y\r\n   * @param {number} c2 - skew x\r\n   * @param {number} d2 - scale y\r\n   * @param {number} e2 - translate x\r\n   * @param {number} f2 - translate y\r\n   * @returns {Matrix}\r\n   */\n  transform: function transform(a2, b2, c2, d2, e2, f2) {\n    var me = this,\n        a1 = me.a,\n        b1 = me.b,\n        c1 = me.c,\n        d1 = me.d,\n        e1 = me.e,\n        f1 = me.f;\n    /* matrix column order is:\r\n     *   a c e\r\n     *   b d f\r\n     *   0 0 1\r\n     */\n\n    me.a = a1 * a2 + c1 * b2;\n    me.b = b1 * a2 + d1 * b2;\n    me.c = a1 * c2 + c1 * d2;\n    me.d = b1 * c2 + d1 * d2;\n    me.e = a1 * e2 + c1 * f2 + e1;\n    me.f = b1 * e2 + d1 * f2 + f1;\n    return me._x();\n  },\n\n  /**\r\n   * Multiplies current matrix with source matrix.\r\n   * @param {Matrix|DOMMatrix|SVGMatrix} m - source matrix to multiply with.\r\n   * @returns {Matrix}\r\n   */\n  multiply: function multiply(m) {\n    return this._t(m.a, m.b, m.c, m.d, m.e, m.f);\n  },\n\n  /**\r\n   * Divide this matrix on input matrix which must be invertible.\r\n   * @param {Matrix} m - matrix to divide on (divisor)\r\n   * @throws Exception if input matrix is not invertible\r\n   * @returns {Matrix}\r\n   */\n  divide: function divide(m) {\n    return this.multiply(m.inverse());\n  },\n\n  /**\r\n   * Divide current matrix on scalar value != 0.\r\n   * @param {number} d - divisor\r\n   * @throws Exception if divisor is zero\r\n   * @returns {Matrix}\r\n   */\n  divideScalar: function divideScalar(d) {\n    var me = this;\n    if (!d) throw \"Division on zero\";\n    me.a /= d;\n    me.b /= d;\n    me.c /= d;\n    me.d /= d;\n    me.e /= d;\n    me.f /= d;\n    return me._x();\n  },\n\n  /**\r\n   * Get an inverse matrix of current matrix. The method returns a new\r\n   * matrix with values you need to use to get to an identity matrix.\r\n   * Context from parent matrix is not applied to the returned matrix.\r\n   *\r\n   * @param {boolean} [cloneContext=false] - clone current context to resulting matrix\r\n   * @param {boolean} [cloneDOM=false] - clone current DOM element to resulting matrix\r\n   * @throws Exception is input matrix is not invertible\r\n   * @returns {Matrix} - new Matrix instance\r\n   */\n  inverse: function inverse(cloneContext, cloneDOM) {\n    var me = this,\n        m = new Matrix(cloneContext ? me.context : null, cloneDOM ? me.element : null),\n        dt = me.determinant();\n    if (!dt) throw \"Matrix not invertible.\";\n    m.a = me.d / dt;\n    m.b = -me.b / dt;\n    m.c = -me.c / dt;\n    m.d = me.a / dt;\n    m.e = (me.c * me.f - me.d * me.e) / dt;\n    m.f = -(me.a * me.f - me.b * me.e) / dt;\n    return m;\n  },\n\n  /**\r\n   * Interpolate this matrix with another and produce a new matrix.\r\n   * `t` is a value in the range [0.0, 1.0] where 0 is this instance and\r\n   * 1 is equal to the second matrix. The `t` value is not clamped.\r\n   *\r\n   * Context from parent matrix is not applied to the returned matrix.\r\n   *\r\n   * Note: this interpolation is naive. For animation containing rotation,\r\n   * shear or skew use the [`interpolateAnim()`]{@link Matrix#interpolateAnim} method instead\r\n   * to avoid unintended flipping.\r\n   *\r\n   * @param {Matrix|SVGMatrix} m2 - the matrix to interpolate with.\r\n   * @param {number} t - interpolation [0.0, 1.0]\r\n   * @param {CanvasRenderingContext2D} [context] - optional context to affect\r\n   * @param {HTMLElement} [dom] - optional DOM element to use for the matrix\r\n   * @returns {Matrix} - new Matrix instance with the interpolated result\r\n   */\n  interpolate: function interpolate(m2, t, context, dom) {\n    var me = this,\n        m = new Matrix(context, dom);\n    m.a = me.a + (m2.a - me.a) * t;\n    m.b = me.b + (m2.b - me.b) * t;\n    m.c = me.c + (m2.c - me.c) * t;\n    m.d = me.d + (m2.d - me.d) * t;\n    m.e = me.e + (m2.e - me.e) * t;\n    m.f = me.f + (m2.f - me.f) * t;\n    return m._x();\n  },\n\n  /**\r\n   * Interpolate this matrix with another and produce a new matrix.\r\n   * `t` is a value in the range [0.0, 1.0] where 0 is this instance and\r\n   * 1 is equal to the second matrix. The `t` value is not constrained.\r\n   *\r\n   * Context from parent matrix is not applied to the returned matrix.\r\n   *\r\n   * To obtain easing `t` can be preprocessed using easing-functions\r\n   * before being passed to this method.\r\n   *\r\n   * Note: this interpolation method uses decomposition which makes\r\n   * it suitable for animations (in particular where rotation takes\r\n   * places).\r\n   *\r\n   * @param {Matrix} m2 - the matrix to interpolate with.\r\n   * @param {number} t - interpolation [0.0, 1.0]\r\n   * @param {CanvasRenderingContext2D} [context] - optional context to affect\r\n   * @param {HTMLElement} [dom] - optional DOM element to use for the matrix\r\n   * @returns {Matrix} - new Matrix instance with the interpolated result\r\n   */\n  interpolateAnim: function interpolateAnim(m2, t, context, dom) {\n    var m = new Matrix(context, dom),\n        d1 = this.decompose(),\n        d2 = m2.decompose(),\n        t1 = d1.translate,\n        t2 = d2.translate,\n        s1 = d1.scale; // QR order (t-r-s-sk)\n\n    m.translate(t1.x + (t2.x - t1.x) * t, t1.y + (t2.y - t1.y) * t);\n    m.rotate(d1.rotation + (d2.rotation - d1.rotation) * t);\n    m.scale(s1.x + (d2.scale.x - s1.x) * t, s1.y + (d2.scale.y - s1.y) * t); //todo test skew scenarios\n\n    return m._x();\n  },\n\n  /**\r\n   * Decompose the current matrix into simple transforms using either\r\n   * QR (default) or LU decomposition.\r\n   *\r\n   * @param {boolean} [useLU=false] - set to true to use LU rather than QR decomposition\r\n   * @returns {*} - an object containing current decomposed values (translate, rotation, scale, skew)\r\n   * @see {@link https://en.wikipedia.org/wiki/QR_decomposition|More on QR decomposition}\r\n   * @see {@link https://en.wikipedia.org/wiki/LU_decomposition|More on LU decomposition}\r\n   */\n  decompose: function decompose(useLU) {\n    var me = this,\n        a = me.a,\n        b = me.b,\n        c = me.c,\n        d = me.d,\n        acos = Math.acos,\n        atan = Math.atan,\n        sqrt = Math.sqrt,\n        pi = Math.PI,\n        translate = {\n      x: me.e,\n      y: me.f\n    },\n        rotation = 0,\n        scale = {\n      x: 1,\n      y: 1\n    },\n        skew = {\n      x: 0,\n      y: 0\n    },\n        determ = a * d - b * c,\n        // determinant(), skip DRY here...\n    r,\n        s;\n\n    if (useLU) {\n      if (a) {\n        skew = {\n          x: atan(c / a),\n          y: atan(b / a)\n        };\n        scale = {\n          x: a,\n          y: determ / a\n        };\n      } else if (b) {\n        rotation = pi * 0.5;\n        scale = {\n          x: b,\n          y: determ / b\n        };\n        skew.x = atan(d / b);\n      } else {\n        // a = b = 0\n        scale = {\n          x: c,\n          y: d\n        };\n        skew.x = pi * 0.25;\n      }\n    } else {\n      // Apply the QR-like decomposition.\n      if (a || b) {\n        r = sqrt(a * a + b * b);\n        rotation = b > 0 ? acos(a / r) : -acos(a / r);\n        scale = {\n          x: r,\n          y: determ / r\n        };\n        skew.x = atan((a * c + b * d) / (r * r));\n      } else if (c || d) {\n        s = sqrt(c * c + d * d);\n        rotation = pi * 0.5 - (d > 0 ? acos(-c / s) : -acos(c / s));\n        scale = {\n          x: determ / s,\n          y: s\n        };\n        skew.y = atan((a * c + b * d) / (s * s));\n      } else {\n        // a = b = c = d = 0\n        scale = {\n          x: 0,\n          y: 0\n        };\n      }\n    }\n\n    return {\n      translate: translate,\n      rotation: rotation,\n      scale: scale,\n      skew: skew\n    };\n  },\n\n  /**\r\n   * Returns the determinant of the current matrix.\r\n   * @returns {number}\r\n   */\n  determinant: function determinant() {\n    return this.a * this.d - this.b * this.c;\n  },\n\n  /**\r\n   * Apply current matrix to `x` and `y` of a point.\r\n   * Returns a point object.\r\n   *\r\n   * @param {number} x - value for x\r\n   * @param {number} y - value for y\r\n   * @returns {{x: number, y: number}} A new transformed point object\r\n   */\n  applyToPoint: function applyToPoint(x, y) {\n    var me = this;\n    return {\n      x: x * me.a + y * me.c + me.e,\n      y: x * me.b + y * me.d + me.f\n    };\n  },\n\n  /**\r\n   * Apply current matrix to array with point objects or point pairs.\r\n   * Returns a new array with points in the same format as the input array.\r\n   *\r\n   * A point object is an object literal:\r\n   *\r\n   *     {x: x, y: y}\r\n   *\r\n   * so an array would contain either:\r\n   *\r\n   *     [{x: x1, y: y1}, {x: x2, y: y2}, ... {x: xn, y: yn}]\r\n   *\r\n   * or\r\n   *\r\n   *     [x1, y1, x2, y2, ... xn, yn]\r\n   *\r\n   * @param {Array} points - array with point objects or pairs\r\n   * @returns {Array} A new array with transformed points\r\n   */\n  applyToArray: function applyToArray(points) {\n    var i = 0,\n        p,\n        l,\n        mxPoints = [];\n\n    if (typeof points[0] === 'number') {\n      l = points.length;\n\n      while (i < l) {\n        p = this.applyToPoint(points[i++], points[i++]);\n        mxPoints.push(p.x, p.y);\n      }\n    } else {\n      while (p = points[i++]) {\n        mxPoints.push(this.applyToPoint(p.x, p.y));\n      }\n    }\n\n    return mxPoints;\n  },\n\n  /**\r\n   * Apply current matrix to a typed array with point pairs. Although\r\n   * the input array may be an ordinary array, this method is intended\r\n   * for more performant use where typed arrays are used. The returned\r\n   * array is regardless always returned as a `Float32Array`.\r\n   *\r\n   * @param {*} points - (typed) array with point pairs [x1, y1, ..., xn, yn]\r\n   * @param {boolean} [use64=false] - use Float64Array instead of Float32Array\r\n   * @returns {*} A new typed array with transformed points\r\n   */\n  applyToTypedArray: function applyToTypedArray(points, use64) {\n    var i = 0,\n        p,\n        l = points.length,\n        mxPoints = use64 ? new Float64Array(l) : new Float32Array(l);\n\n    while (i < l) {\n      p = this.applyToPoint(points[i], points[i + 1]);\n      mxPoints[i++] = p.x;\n      mxPoints[i++] = p.y;\n    }\n\n    return mxPoints;\n  },\n\n  /**\r\n   * Apply to any canvas 2D context object. This does not affect the\r\n   * context that optionally was referenced in constructor unless it is\r\n   * the same context.\r\n   *\r\n   * @param {CanvasRenderingContext2D} context - target context\r\n   * @returns {Matrix}\r\n   */\n  applyToContext: function applyToContext(context) {\n    var me = this;\n    context.setTransform(me.a, me.b, me.c, me.d, me.e, me.f);\n    return me;\n  },\n\n  /**\r\n   * Apply to any DOM element. This does not affect the DOM element\r\n   * that optionally was referenced in constructor unless it is\r\n   * the same element.\r\n   *\r\n   * The method will auto-detect the correct browser prefix if any.\r\n   *\r\n   * @param {HTMLElement} element - target DOM element\r\n   * @param {boolean} [use3D=false] - use 3D transformation matrix instead of 2D\r\n   * @returns {Matrix}\r\n   */\n  applyToElement: function applyToElement(element, use3D) {\n    var me = this;\n    if (!me._px) me._px = me._getPX();\n    element.style[me._px] = use3D ? me.toCSS3D() : me.toCSS();\n    return me;\n  },\n\n  /**\r\n   * Instead of creating a new instance of a Matrix, DOMMatrix or SVGMatrix\r\n   * the current settings of this instance can be applied to an external\r\n   * object of a different (or same) type. You can also pass in an\r\n   * empty literal object.\r\n   *\r\n   * Note that the properties a-f will be set regardless of if they\r\n   * already exist or not.\r\n   *\r\n   * @param {*} obj - target object.\r\n   * @returns {Matrix}\r\n   */\n  applyToObject: function applyToObject(obj) {\n    var me = this;\n    obj.a = me.a;\n    obj.b = me.b;\n    obj.c = me.c;\n    obj.d = me.d;\n    obj.e = me.e;\n    obj.f = me.f;\n    return me;\n  },\n\n  /**\r\n   * Returns true if matrix is an identity matrix (no transforms applied).\r\n   * @returns {boolean}\r\n   */\n  isIdentity: function isIdentity() {\n    var me = this;\n    return me.a === 1 && !me.b && !me.c && me.d === 1 && !me.e && !me.f;\n  },\n\n  /**\r\n   * Returns true if matrix is invertible\r\n   * @returns {boolean}\r\n   */\n  isInvertible: function isInvertible() {\n    return !this._q(this.determinant(), 0);\n  },\n\n  /**\r\n   * The method is intended for situations where scale is accumulated\r\n   * via multiplications, to detect situations where scale becomes\r\n   * \"trapped\" with a value of zero. And in which case scale must be\r\n   * set explicitly to a non-zero value.\r\n   *\r\n   * @returns {boolean}\r\n   */\n  isValid: function isValid() {\n    return !(this.a * this.d);\n  },\n\n  /**\r\n   * Compares current matrix with another matrix. Returns true if equal\r\n   * (within epsilon tolerance).\r\n   * @param {Matrix|SVGMatrix} m - matrix to compare this matrix with\r\n   * @returns {boolean}\r\n   */\n  isEqual: function isEqual(m) {\n    var me = this,\n        q = me._q;\n    return q(me.a, m.a) && q(me.b, m.b) && q(me.c, m.c) && q(me.d, m.d) && q(me.e, m.e) && q(me.f, m.f);\n  },\n\n  /**\r\n   * Clones current instance and returning a new matrix.\r\n   * @param {boolean} [noContext=false] don't clone context reference if true\r\n   * @returns {Matrix} - a new Matrix instance with identical transformations as this instance\r\n   */\n  clone: function clone(noContext) {\n    return new Matrix(noContext ? null : this.context).multiply(this);\n  },\n\n  /**\r\n   * Returns an array with current matrix values.\r\n   * @returns {Array}\r\n   */\n  toArray: function toArray() {\n    var me = this;\n    return [me.a, me.b, me.c, me.d, me.e, me.f];\n  },\n\n  /**\r\n   * Returns a binary 32-bit floating point typed array.\r\n   * @returns {*}\r\n   */\n  toTypedArray: function toTypedArray() {\n    var me = this;\n    return new Float32Array([me.a, me.b, me.c, me.d, me.e, me.f]);\n  },\n\n  /**\r\n   * Generates a string that can be used with CSS `transform`.\r\n   * @example\r\n   *     element.style.transform = m.toCSS();\r\n   * @returns {string}\r\n   */\n  toCSS: function toCSS() {\n    return \"matrix(\" + this.toArray() + \")\";\n  },\n\n  /**\r\n   * Generates a `matrix3d()` string that can be used with CSS `transform`.\r\n   * Although the matrix is for 2D use you may see performance benefits\r\n   * on some devices using a 3D CSS transform instead of a 2D.\r\n   * @example\r\n   *     element.style.transform = m.toCSS3D();\r\n   * @returns {string}\r\n   */\n  toCSS3D: function toCSS3D() {\n    var me = this,\n        n2 = \",0,0,\";\n    return \"matrix3d(\" + me.a + \",\" + me.b + n2 + me.c + \",\" + me.d + n2 + n2 + \",1,0,\" + me.e + \",\" + me.f + \",0,1)\";\n  },\n\n  /**\r\n   * Returns a JSON compatible string of current matrix.\r\n   * @returns {string}\r\n   */\n  toJSON: function toJSON() {\n    var me = this;\n    return '{\"a\":' + me.a + ',\"b\":' + me.b + ',\"c\":' + me.c + ',\"d\":' + me.d + ',\"e\":' + me.e + ',\"f\":' + me.f + '}';\n  },\n\n  /**\r\n   * Returns a string with current matrix as comma-separated list.\r\n   * @param {number} [fixLen=4] - truncate decimal values to number of digits\r\n   * @returns {string}\r\n   */\n  toString: function toString(fixLen) {\n    var me = this;\n    fixLen = fixLen || 4;\n    return \"a=\" + me.a.toFixed(fixLen) + \" b=\" + me.b.toFixed(fixLen) + \" c=\" + me.c.toFixed(fixLen) + \" d=\" + me.d.toFixed(fixLen) + \" e=\" + me.e.toFixed(fixLen) + \" f=\" + me.f.toFixed(fixLen);\n  },\n\n  /**\r\n   * Returns a string with current matrix as comma-separated values\r\n   * string with line-end (CR+LF).\r\n   * @returns {string}\r\n   */\n  toCSV: function toCSV() {\n    return this.toArray().join() + \"\\r\\n\";\n  },\n\n  /**\r\n   * Convert current matrix into a `DOMMatrix`. If `DOMMatrix` is not\r\n   * supported, a `null` is returned.\r\n   *\r\n   * @returns {DOMMatrix}\r\n   * @see {@link https://drafts.fxtf.org/geometry/#dommatrix|MDN / SVGMatrix}\r\n   */\n  toDOMMatrix: function toDOMMatrix() {\n    var m = null;\n\n    if (\"DOMMatrix\" in window) {\n      m = new DOMMatrix();\n      m.a = this.a;\n      m.b = this.b;\n      m.c = this.c;\n      m.d = this.d;\n      m.e = this.e;\n      m.f = this.f;\n    }\n\n    return m;\n  },\n\n  /**\r\n   * Convert current matrix into a `SVGMatrix`. If `SVGMatrix` is not\r\n   * supported, a `null` is returned.\r\n   *\r\n   * @returns {SVGMatrix}\r\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/SVGMatrix|MDN / SVGMatrix}\r\n   */\n  toSVGMatrix: function toSVGMatrix() {\n    var me = this,\n        svg = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\"),\n        svgMatrix = null;\n\n    if (svg) {\n      svgMatrix = svg.createSVGMatrix();\n      svgMatrix.a = me.a;\n      svgMatrix.b = me.b;\n      svgMatrix.c = me.c;\n      svgMatrix.d = me.d;\n      svgMatrix.e = me.e;\n      svgMatrix.f = me.f;\n    }\n\n    return svgMatrix;\n  },\n\n  /**\r\n   * Compares floating point values with some tolerance (epsilon)\r\n   * @param {number} f1 - float 1\r\n   * @param {number} f2 - float 2\r\n   * @returns {boolean}\r\n   * @private\r\n   */\n  _q: function _q(f1, f2) {\n    return Math.abs(f1 - f2) < 1e-14;\n  },\n\n  /**\r\n   * Apply current absolute matrix to context if defined, to sync it.\r\n   * Apply current absolute matrix to element if defined, to sync it.\r\n   * @returns {Matrix}\r\n   * @private\r\n   */\n  _x: function _x() {\n    var me = this;\n    if (me.context) me.context.setTransform(me.a, me.b, me.c, me.d, me.e, me.f);\n    if (me._st) me._st[me._px] = me.useCSS3D ? me.toCSS3D() : me.toCSS(); // can be optimized pre-storing func ref.\n\n    return me;\n  }\n}; // Node support\n\nif (typeof exports !== \"undefined\") exports.Matrix = Matrix;","map":{"version":3,"sources":["/Users/yan/Documents/proj/ML4GIS/client/node_modules/transformation-matrix-js/matrix.js"],"names":["Matrix","context","element","me","_el","_t","transform","a","d","b","c","e","f","setTransform","Object","defineProperty","get","set","el","_px","_getPX","useCSS3D","_st","style","toCSS","fromTriangles","t1","t2","m1","m2","r1","r2","rx1","ry1","rx2","ry2","Array","isArray","x","y","px","rx","py","ry","qx","qy","apply","multiply","inverse","fromSVGTransformList","tList","dom","m","i","length","matrix","from","scale","dist","q","Math","sqrt","translate","rotateFromVector","scaleU","is2D","prototype","lst","p","document","createElement","concat","cm","clone","flipX","flipY","reflectVector","v","applyToPoint","reset","rotate","angle","cos","sin","atan2","rotateDeg","PI","sx","sy","scaleX","scaleY","scaleFromVector","shear","shearX","shearY","skew","ax","ay","tan","skewDeg","skewX","skewY","_x","tx","ty","translateX","translateY","a2","b2","c2","d2","e2","f2","a1","b1","c1","d1","e1","f1","divide","divideScalar","cloneContext","cloneDOM","dt","determinant","interpolate","t","interpolateAnim","decompose","s1","rotation","useLU","acos","atan","pi","determ","r","s","applyToArray","points","l","mxPoints","push","applyToTypedArray","use64","Float64Array","Float32Array","applyToContext","applyToElement","use3D","toCSS3D","applyToObject","obj","isIdentity","isInvertible","_q","isValid","isEqual","noContext","toArray","toTypedArray","n2","toJSON","toString","fixLen","toFixed","toCSV","join","toDOMMatrix","window","DOMMatrix","toSVGMatrix","svg","createElementNS","svgMatrix","createSVGMatrix","abs","exports"],"mappings":"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","sourcesContent":["/*!\r\n  2D Transformation Matrix v2.7.5\r\n  (c) Epistemex.com 2014-2018\r\n  License: MIT\r\n*/\r\n\r\n/**\r\n * 2D transformation matrix object initialized with identity matrix.\r\n *\r\n * The matrix can synchronize a canvas 2D context by supplying the context\r\n * as an argument, or later apply current absolute transform to an\r\n * existing context.\r\n *\r\n * To synchronize a DOM element you can use [`toCSS()`]{@link Matrix#toCSS} or [`toCSS3D()`]{@link Matrix#toCSS3D}.\r\n * together with for example the `style.transform` property.\r\n *\r\n * @param {CanvasRenderingContext2D} [context] - Optional context to sync with Matrix\r\n * @param {HTMLElement} [element=null] - DOM Element to synchronize\r\n * @prop {number} a - scale x\r\n * @prop {number} b - shear y\r\n * @prop {number} c - shear x\r\n * @prop {number} d - scale y\r\n * @prop {number} e - translate x\r\n * @prop {number} f - translate y\r\n * @prop {CanvasRenderingContext2D} [context] - set or get current synchronized 2D context\r\n * @prop {HTMLElement} [element] - get current synchronized DOM element\r\n * @prop {boolean} [useCSS3D=false] - is a DOM element is defined for sync., choose whether to use 2D (false) or 3D (true) matrix to sync it.\r\n * @constructor\r\n * @license MIT license\r\n * @copyright Epistemex.com 2014-2018\r\n */\r\nfunction Matrix(context, element) {\r\n\r\n  var me = this, _el;\r\n  me._t = me.transform;\r\n\r\n  me.a = me.d = 1;\r\n  me.b = me.c = me.e = me.f = 0;\r\n\r\n  // sync context\r\n  if (context)\r\n    (me.context = context).setTransform(1, 0, 0, 1, 0, 0);\r\n\r\n  // sync DOM element\r\n  Object.defineProperty(me, \"element\", {\r\n    get: function() {return _el},\r\n    set: function(el) {\r\n      if (!_el) {\r\n        me._px = me._getPX();\r\n        me.useCSS3D = false\r\n      }\r\n      _el = el;\r\n      (me._st = _el.style)[me._px] = me.toCSS();\r\n    }\r\n  });\r\n\r\n  if (element) me.element = element\r\n}\r\n\r\n/**\r\n * Returns a new matrix that transforms a triangle `t1` into another triangle\r\n * `t2`, or throws an exception if it is impossible.\r\n *\r\n * Note: the method can take both arrays as well as literal objects.\r\n * Just make sure that both arguments (`t1`, `t2`) are of the same type.\r\n *\r\n * @param {{px: number, py: number, qx: number, qy: number, rx: number, ry: number}|Array} t1 - Object or array containing the three points for the triangle.\r\n * For object use obj.px, obj.py, obj.qx, obj.qy, obj.rx and obj.ry. For arrays provide the points in the order [px, py, qx, qy, rx, ry], or as point array [{x:,y:}, {x:,y:}, {x:,y:}]\r\n * @param {{px: number, py: number, qx: number, qy: number, rx: number, ry: number}|Array} t2 - See description for t1.\r\n * @param {CanvasRenderingContext2D} [context] - optional canvas 2D context to use for the matrix\r\n * @returns {Matrix}\r\n * @throws Exception is matrix becomes not invertible\r\n * @static\r\n */\r\nMatrix.fromTriangles = function(t1, t2, context) {\r\n\r\n  var\r\n    m1 = new Matrix(),\r\n    m2 = new Matrix(context),\r\n    r1, r2, rx1, ry1, rx2, ry2;\r\n\r\n  if (Array.isArray(t1)) {\r\n    if (typeof t1[0] === \"number\") {\r\n      rx1 = t1[4]; ry1 = t1[5]; rx2 = t2[4]; ry2 = t2[5];\r\n      r1 = [t1[0] - rx1, t1[1] - ry1, t1[2] - rx1, t1[3] - ry1, rx1, ry1];\r\n      r2 = [t2[0] - rx2, t2[1] - ry2, t2[2] - rx2, t2[3] - ry2, rx2, ry2]\r\n    }\r\n    else {\r\n      rx1 = t1[2].x; ry1 = t1[2].y; rx2 = t2[2].x; ry2 = t2[2].y;\r\n      r1 = [t1[0].x - rx1, t1[0].y - ry1, t1[1].x - rx1, t1[1].y - ry1, rx1, ry1];\r\n      r2 = [t2[0].x - rx2, t2[0].y - ry2, t2[1].x - rx2, t2[1].y - ry2, rx2, ry2]\r\n    }\r\n  }\r\n  else {\r\n    r1 = [t1.px - t1.rx, t1.py - t1.ry, t1.qx - t1.rx, t1.qy - t1.ry, t1.rx, t1.ry];\r\n    r2 = [t2.px - t2.rx, t2.py - t2.ry, t2.qx - t2.rx, t2.qy - t2.ry, t2.rx, t2.ry]\r\n  }\r\n\r\n  m1.setTransform.apply(m1, r1);\r\n  m2.setTransform.apply(m2, r2);\r\n\r\n  return m2.multiply(m1.inverse())\r\n};\r\n\r\n/**\r\n * Create a matrix from a transform list from an SVG shape. The list\r\n * can be for example baseVal (i.e. `shape.transform.baseVal`).\r\n *\r\n * The resulting matrix has all transformations from that list applied\r\n * in the same order as the list.\r\n *\r\n * @param {SVGTransformList} tList - transform list from an SVG shape.\r\n * @param {CanvasRenderingContext2D} [context] - optional canvas 2D context to use for the matrix\r\n * @param {HTMLElement} [dom] - optional DOM element to use for the matrix\r\n * @returns {Matrix}\r\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/SVGTransformList|MDN / SVGTransformList}\r\n */\r\nMatrix.fromSVGTransformList = function(tList, context, dom) {\r\n\r\n  var\r\n    m = new Matrix(context, dom),\r\n    i = 0;\r\n\r\n  while(i < tList.length)\r\n    m.multiply(tList[i++].matrix);\r\n\r\n  return m\r\n};\r\n\r\n/**\r\n * Create and transform a new matrix based on given matrix values, or\r\n * provide SVGMatrix or a (2D) DOMMatrix, WebKitCSSMatrix or another\r\n * instance of a generic Matrix.\r\n *\r\n * @example\r\n *\r\n * var m = Matrix.from(1, 0.2, 0, 2, 120, 97);\r\n * var m = Matrix.from(domMatrix, ctx);\r\n * var m = Matrix.from(svgMatrix);\r\n * var m = Matrix.from(cssMatrix);\r\n * var m = Matrix.from(matrix);\r\n * var m = Matrix.from(vector [,pre-x] [,pre-y] [,doScale]);\r\n *\r\n * @param {*} a - number representing a in [a-f], or a Matrix object containing properties a-f. Vector is given as an object with properties x and y.\r\n * @param {*} [b] - b property if a is not a matrix object, or optional canvas 2D context.\r\n * If vector is input this will be pre-translate for x.\r\n * @param {number} [c] - If vector is input this will be pre-translate for y.\r\n * @param {number} [d] - If vector is input, set this to true to use scale and translate of 1,\r\n * false to use hypotenuse as translate distance instead and no scale.\r\n * @param {number} [e]\r\n * @param {number} [f]\r\n * @param {CanvasRenderingContext2D} [context] - optional canvas context to synchronize\r\n * @param {HTMLElement} [dom] - optional DOM element to use for the matrix\r\n * @returns {Matrix}\r\n * @static\r\n */\r\nMatrix.from = function(a, b, c, d, e, f, context, dom) {\r\n\r\n  var m = new Matrix(context, dom), scale, dist, q;\r\n\r\n  if (typeof a === \"number\")\r\n    m.setTransform(a, b, c, d, e, f);\r\n\r\n  else if (typeof a.x === \"number\") {\t\t// vector\r\n\r\n    q = Math.sqrt(a.x*a.x + a.y*a.y);\r\n    scale = dist = 1;\r\n\r\n    if (d) scale = q;\r\n    else dist = q;\r\n\r\n    m\r\n      .translate(b || 0, c || 0)\r\n      .rotateFromVector(a)\r\n      .scaleU(scale)\r\n      .translate(dist, 0);\r\n\r\n  }\r\n  else {\r\n    if (typeof a.is2D === \"boolean\" && !a.is2D) throw \"Cannot use 3D DOMMatrix.\";\r\n    if (b) m.context = b;\r\n    if (c) m.element = c;\r\n    m.multiply(a)\r\n  }\r\n\r\n  return m\r\n};\r\n\r\nMatrix.prototype = {\r\n\r\n  _getPX: function() {\r\n\r\n    var\r\n      lst   = [\"t\", \"oT\", \"msT\", \"mozT\", \"webkitT\", \"khtmlT\"], i = 0, p,\r\n      style = document.createElement(\"div\").style;\r\n\r\n    while(p = lst[i++])\r\n      if (typeof style[p + \"ransform\"] !== \"undefined\") return p + \"ransform\";\r\n  },\r\n\r\n  /**\r\n   * Concatenates transforms of this matrix onto the given child matrix and\r\n   * returns a new matrix. This instance is used on left side.\r\n   *\r\n   * @param {Matrix|SVGMatrix} cm - child matrix to apply concatenation to\r\n   * @returns {Matrix} - new Matrix instance\r\n   */\r\n  concat: function(cm) {\r\n    return this.clone().multiply(cm)\r\n  },\r\n\r\n  /**\r\n   * Flips the horizontal values.\r\n   * @returns {Matrix}\r\n   */\r\n  flipX: function() {\r\n    return this._t(-1, 0, 0, 1, 0, 0)\r\n  },\r\n\r\n  /**\r\n   * Flips the vertical values.\r\n   * @returns {Matrix}\r\n   */\r\n  flipY: function() {\r\n    return this._t(1, 0, 0, -1, 0, 0)\r\n  },\r\n\r\n  /**\r\n   * Reflects incoming (velocity) vector on the normal which will be the\r\n   * current transformed x axis. Call when a trigger condition is met.\r\n   *\r\n   * @param {number} x - vector end point for x (start = 0)\r\n   * @param {number} y - vector end point for y (start = 0)\r\n   * @returns {{x: number, y: number}}\r\n   */\r\n  reflectVector: function(x, y) {\r\n\r\n    var\r\n      v = this.applyToPoint(0, 1),\r\n      d = (v.x * x + v.y * y) * 2;\r\n\r\n    x -= d * v.x;\r\n    y -= d * v.y;\r\n\r\n    return {x: x, y: y}\r\n  },\r\n\r\n  /**\r\n   * Short-hand to reset current matrix to an identity matrix.\r\n   * @returns {Matrix}\r\n   */\r\n  reset: function() {\r\n    return this.setTransform(1, 0, 0, 1, 0, 0)\r\n  },\r\n\r\n  /**\r\n   * Rotates current matrix by angle (accumulative).\r\n   * @param {number} angle - angle in radians\r\n   * @returns {Matrix}\r\n   */\r\n  rotate: function(angle) {\r\n    var\r\n      cos = Math.cos(angle),\r\n      sin = Math.sin(angle);\r\n    return this._t(cos, sin, -sin, cos, 0, 0)\r\n  },\r\n\r\n  /**\r\n   * Converts a vector given as `x` and `y` to angle, and\r\n   * rotates (accumulative). x can instead contain an object with\r\n   * properties x and y and if so, y parameter will be ignored.\r\n   * @param {number|*} x\r\n   * @param {number} [y]\r\n   * @returns {Matrix}\r\n   */\r\n  rotateFromVector: function(x, y) {\r\n    return this.rotate(typeof x === \"number\" ? Math.atan2(y, x) : Math.atan2(x.y, x.x))\r\n  },\r\n\r\n  /**\r\n   * Helper method to make a rotation based on an angle in degrees.\r\n   * @param {number} angle - angle in degrees\r\n   * @returns {Matrix}\r\n   */\r\n  rotateDeg: function(angle) {\r\n    return this.rotate(angle * Math.PI / 180)\r\n  },\r\n\r\n  /**\r\n   * Scales current matrix uniformly and accumulative.\r\n   * @param {number} f - scale factor for both x and y (1 does nothing)\r\n   * @returns {Matrix}\r\n   */\r\n  scaleU: function(f) {\r\n    return this._t(f, 0, 0, f, 0, 0)\r\n  },\r\n\r\n  /**\r\n   * Scales current matrix accumulative.\r\n   * @param {number} sx - scale factor x (1 does nothing)\r\n   * @param {number} sy - scale factor y (1 does nothing)\r\n   * @returns {Matrix}\r\n   */\r\n  scale: function(sx, sy) {\r\n    return this._t(sx, 0, 0, sy, 0, 0)\r\n  },\r\n\r\n  /**\r\n   * Scales current matrix on x axis accumulative.\r\n   * @param {number} sx - scale factor x (1 does nothing)\r\n   * @returns {Matrix}\r\n   */\r\n  scaleX: function(sx) {\r\n    return this._t(sx, 0, 0, 1, 0, 0)\r\n  },\r\n\r\n  /**\r\n   * Scales current matrix on y axis accumulative.\r\n   * @param {number} sy - scale factor y (1 does nothing)\r\n   * @returns {Matrix}\r\n   */\r\n  scaleY: function(sy) {\r\n    return this._t(1, 0, 0, sy, 0, 0)\r\n  },\r\n\r\n  /**\r\n   * Converts a vector given as `x` and `y` to normalized scale.\r\n   * @param x\r\n   * @param y\r\n   * @returns {Matrix}\r\n   */\r\n  scaleFromVector: function(x, y) {\r\n    return this.scaleU(Math.sqrt(x*x + y*y))\r\n  },\r\n\r\n  /**\r\n   * Apply shear to the current matrix accumulative.\r\n   * @param {number} sx - amount of shear for x\r\n   * @param {number} sy - amount of shear for y\r\n   * @returns {Matrix}\r\n   */\r\n  shear: function(sx, sy) {\r\n    return this._t(1, sy, sx, 1, 0, 0)\r\n  },\r\n\r\n  /**\r\n   * Apply shear for x to the current matrix accumulative.\r\n   * @param {number} sx - amount of shear for x\r\n   * @returns {Matrix}\r\n   */\r\n  shearX: function(sx) {\r\n    return this._t(1, 0, sx, 1, 0, 0)\r\n  },\r\n\r\n  /**\r\n   * Apply shear for y to the current matrix accumulative.\r\n   * @param {number} sy - amount of shear for y\r\n   * @returns {Matrix}\r\n   */\r\n  shearY: function(sy) {\r\n    return this._t(1, sy, 0, 1, 0, 0)\r\n  },\r\n\r\n  /**\r\n   * Apply skew to the current matrix accumulative. Angles in radians.\r\n   * Also see [`skewDeg()`]{@link Matrix#skewDeg}.\r\n   * @param {number} ax - angle of skew for x\r\n   * @param {number} ay - angle of skew for y\r\n   * @returns {Matrix}\r\n   */\r\n  skew: function(ax, ay) {\r\n    return this.shear(Math.tan(ax), Math.tan(ay))\r\n  },\r\n\r\n  /**\r\n   * Apply skew to the current matrix accumulative. Angles in degrees.\r\n   * Also see [`skew()`]{@link Matrix#skew}.\r\n   * @param {number} ax - angle of skew for x\r\n   * @param {number} ay - angle of skew for y\r\n   * @returns {Matrix}\r\n   */\r\n  skewDeg: function(ax, ay) {\r\n    return this.shear(Math.tan(ax / 180 * Math.PI), Math.tan(ay / 180 * Math.PI))\r\n  },\r\n\r\n  /**\r\n   * Apply skew for x to the current matrix accumulative. Angles in radians.\r\n   * Also see [`skewDeg()`]{@link Matrix#skewDeg}.\r\n   * @param {number} ax - angle of skew for x\r\n   * @returns {Matrix}\r\n   */\r\n  skewX: function(ax) {\r\n    return this.shearX(Math.tan(ax))\r\n  },\r\n\r\n  /**\r\n   * Apply skew for y to the current matrix accumulative. Angles in radians.\r\n   * Also see [`skewDeg()`]{@link Matrix#skewDeg}.\r\n   * @param {number} ay - angle of skew for y\r\n   * @returns {Matrix}\r\n   */\r\n  skewY: function(ay) {\r\n    return this.shearY(Math.tan(ay))\r\n  },\r\n\r\n  /**\r\n   * Set current matrix to new absolute matrix.\r\n   * @param {number} a - scale x\r\n   * @param {number} b - shear y\r\n   * @param {number} c - shear x\r\n   * @param {number} d - scale y\r\n   * @param {number} e - translate x\r\n   * @param {number} f - translate y\r\n   * @returns {Matrix}\r\n   */\r\n  setTransform: function(a, b, c, d, e, f) {\r\n    var me = this;\r\n    me.a = a;\r\n    me.b = b;\r\n    me.c = c;\r\n    me.d = d;\r\n    me.e = e;\r\n    me.f = f;\r\n    return me._x()\r\n  },\r\n\r\n  /**\r\n   * Translate current matrix accumulative.\r\n   * @param {number} tx - translation for x\r\n   * @param {number} ty - translation for y\r\n   * @returns {Matrix}\r\n   */\r\n  translate: function(tx, ty) {\r\n    return this._t(1, 0, 0, 1, tx, ty)\r\n  },\r\n\r\n  /**\r\n   * Translate current matrix on x axis accumulative.\r\n   * @param {number} tx - translation for x\r\n   * @returns {Matrix}\r\n   */\r\n  translateX: function(tx) {\r\n    return this._t(1, 0, 0, 1, tx, 0)\r\n  },\r\n\r\n  /**\r\n   * Translate current matrix on y axis accumulative.\r\n   * @param {number} ty - translation for y\r\n   * @returns {Matrix}\r\n   */\r\n  translateY: function(ty) {\r\n    return this._t(1, 0, 0, 1, 0, ty)\r\n  },\r\n\r\n  /**\r\n   * Multiplies current matrix with new matrix values. Also see [`multiply()`]{@link Matrix#multiply}.\r\n   *\r\n   * @param {number} a2 - scale x\r\n   * @param {number} b2 - skew y\r\n   * @param {number} c2 - skew x\r\n   * @param {number} d2 - scale y\r\n   * @param {number} e2 - translate x\r\n   * @param {number} f2 - translate y\r\n   * @returns {Matrix}\r\n   */\r\n  transform: function(a2, b2, c2, d2, e2, f2) {\r\n\r\n    var\r\n      me = this,\r\n      a1 = me.a,\r\n      b1 = me.b,\r\n      c1 = me.c,\r\n      d1 = me.d,\r\n      e1 = me.e,\r\n      f1 = me.f;\r\n\r\n    /* matrix column order is:\r\n     *   a c e\r\n     *   b d f\r\n     *   0 0 1\r\n     */\r\n    me.a = a1 * a2 + c1 * b2;\r\n    me.b = b1 * a2 + d1 * b2;\r\n    me.c = a1 * c2 + c1 * d2;\r\n    me.d = b1 * c2 + d1 * d2;\r\n    me.e = a1 * e2 + c1 * f2 + e1;\r\n    me.f = b1 * e2 + d1 * f2 + f1;\r\n\r\n    return me._x()\r\n  },\r\n\r\n  /**\r\n   * Multiplies current matrix with source matrix.\r\n   * @param {Matrix|DOMMatrix|SVGMatrix} m - source matrix to multiply with.\r\n   * @returns {Matrix}\r\n   */\r\n  multiply: function(m) {\r\n    return this._t(m.a, m.b, m.c, m.d, m.e, m.f)\r\n  },\r\n\r\n  /**\r\n   * Divide this matrix on input matrix which must be invertible.\r\n   * @param {Matrix} m - matrix to divide on (divisor)\r\n   * @throws Exception if input matrix is not invertible\r\n   * @returns {Matrix}\r\n   */\r\n  divide: function(m) {\r\n    return this.multiply(m.inverse())\r\n  },\r\n\r\n  /**\r\n   * Divide current matrix on scalar value != 0.\r\n   * @param {number} d - divisor\r\n   * @throws Exception if divisor is zero\r\n   * @returns {Matrix}\r\n   */\r\n  divideScalar: function(d) {\r\n\r\n    var me = this;\r\n\r\n    if (!d) throw \"Division on zero\";\r\n\r\n    me.a /= d;\r\n    me.b /= d;\r\n    me.c /= d;\r\n    me.d /= d;\r\n    me.e /= d;\r\n    me.f /= d;\r\n\r\n    return me._x()\r\n  },\r\n\r\n  /**\r\n   * Get an inverse matrix of current matrix. The method returns a new\r\n   * matrix with values you need to use to get to an identity matrix.\r\n   * Context from parent matrix is not applied to the returned matrix.\r\n   *\r\n   * @param {boolean} [cloneContext=false] - clone current context to resulting matrix\r\n   * @param {boolean} [cloneDOM=false] - clone current DOM element to resulting matrix\r\n   * @throws Exception is input matrix is not invertible\r\n   * @returns {Matrix} - new Matrix instance\r\n   */\r\n  inverse: function(cloneContext, cloneDOM) {\r\n\r\n    var\r\n      me = this,\r\n      m  = new Matrix(cloneContext ? me.context : null, cloneDOM ? me.element : null),\r\n      dt = me.determinant();\r\n\r\n    if (!dt) throw \"Matrix not invertible.\";\r\n\r\n    m.a = me.d / dt;\r\n    m.b = -me.b / dt;\r\n    m.c = -me.c / dt;\r\n    m.d = me.a / dt;\r\n    m.e = (me.c * me.f - me.d * me.e) / dt;\r\n    m.f = -(me.a * me.f - me.b * me.e) / dt;\r\n\r\n    return m\r\n  },\r\n\r\n  /**\r\n   * Interpolate this matrix with another and produce a new matrix.\r\n   * `t` is a value in the range [0.0, 1.0] where 0 is this instance and\r\n   * 1 is equal to the second matrix. The `t` value is not clamped.\r\n   *\r\n   * Context from parent matrix is not applied to the returned matrix.\r\n   *\r\n   * Note: this interpolation is naive. For animation containing rotation,\r\n   * shear or skew use the [`interpolateAnim()`]{@link Matrix#interpolateAnim} method instead\r\n   * to avoid unintended flipping.\r\n   *\r\n   * @param {Matrix|SVGMatrix} m2 - the matrix to interpolate with.\r\n   * @param {number} t - interpolation [0.0, 1.0]\r\n   * @param {CanvasRenderingContext2D} [context] - optional context to affect\r\n   * @param {HTMLElement} [dom] - optional DOM element to use for the matrix\r\n   * @returns {Matrix} - new Matrix instance with the interpolated result\r\n   */\r\n  interpolate: function(m2, t, context, dom) {\r\n\r\n    var\r\n      me = this,\r\n      m  = new Matrix(context, dom);\r\n\r\n    m.a = me.a + (m2.a - me.a) * t;\r\n    m.b = me.b + (m2.b - me.b) * t;\r\n    m.c = me.c + (m2.c - me.c) * t;\r\n    m.d = me.d + (m2.d - me.d) * t;\r\n    m.e = me.e + (m2.e - me.e) * t;\r\n    m.f = me.f + (m2.f - me.f) * t;\r\n\r\n    return m._x()\r\n  },\r\n\r\n  /**\r\n   * Interpolate this matrix with another and produce a new matrix.\r\n   * `t` is a value in the range [0.0, 1.0] where 0 is this instance and\r\n   * 1 is equal to the second matrix. The `t` value is not constrained.\r\n   *\r\n   * Context from parent matrix is not applied to the returned matrix.\r\n   *\r\n   * To obtain easing `t` can be preprocessed using easing-functions\r\n   * before being passed to this method.\r\n   *\r\n   * Note: this interpolation method uses decomposition which makes\r\n   * it suitable for animations (in particular where rotation takes\r\n   * places).\r\n   *\r\n   * @param {Matrix} m2 - the matrix to interpolate with.\r\n   * @param {number} t - interpolation [0.0, 1.0]\r\n   * @param {CanvasRenderingContext2D} [context] - optional context to affect\r\n   * @param {HTMLElement} [dom] - optional DOM element to use for the matrix\r\n   * @returns {Matrix} - new Matrix instance with the interpolated result\r\n   */\r\n  interpolateAnim: function(m2, t, context, dom) {\r\n\r\n    var\r\n      m  = new Matrix(context, dom),\r\n      d1 = this.decompose(),\r\n      d2 = m2.decompose(),\r\n      t1 = d1.translate,\r\n      t2 = d2.translate,\r\n      s1 = d1.scale;\r\n\r\n    // QR order (t-r-s-sk)\r\n    m.translate(t1.x + (t2.x - t1.x) * t, t1.y + (t2.y - t1.y) * t);\r\n    m.rotate(d1.rotation + (d2.rotation - d1.rotation) * t);\r\n    m.scale(s1.x + (d2.scale.x - s1.x) * t, s1.y + (d2.scale.y - s1.y) * t);\r\n    //todo test skew scenarios\r\n\r\n    return m._x()\r\n  },\r\n\r\n  /**\r\n   * Decompose the current matrix into simple transforms using either\r\n   * QR (default) or LU decomposition.\r\n   *\r\n   * @param {boolean} [useLU=false] - set to true to use LU rather than QR decomposition\r\n   * @returns {*} - an object containing current decomposed values (translate, rotation, scale, skew)\r\n   * @see {@link https://en.wikipedia.org/wiki/QR_decomposition|More on QR decomposition}\r\n   * @see {@link https://en.wikipedia.org/wiki/LU_decomposition|More on LU decomposition}\r\n   */\r\n  decompose: function(useLU) {\r\n\r\n    var\r\n      me        = this,\r\n      a         = me.a,\r\n      b         = me.b,\r\n      c         = me.c,\r\n      d         = me.d,\r\n      acos      = Math.acos,\r\n      atan      = Math.atan,\r\n      sqrt      = Math.sqrt,\r\n      pi        = Math.PI,\r\n\r\n      translate = {x: me.e, y: me.f},\r\n      rotation  = 0,\r\n      scale     = {x: 1, y: 1},\r\n      skew      = {x: 0, y: 0},\r\n\r\n      determ    = a * d - b * c,\t// determinant(), skip DRY here...\r\n      r, s;\r\n\r\n    if (useLU) {\r\n      if (a) {\r\n        skew = {x: atan(c / a), y: atan(b / a)};\r\n        scale = {x: a, y: determ / a};\r\n      }\r\n      else if (b) {\r\n        rotation = pi * 0.5;\r\n        scale = {x: b, y: determ / b};\r\n        skew.x = atan(d / b);\r\n      }\r\n      else { // a = b = 0\r\n        scale = {x: c, y: d};\r\n        skew.x = pi * 0.25;\r\n      }\r\n    }\r\n    else {\r\n      // Apply the QR-like decomposition.\r\n      if (a || b) {\r\n        r = sqrt(a * a + b * b);\r\n        rotation = b > 0 ? acos(a / r) : -acos(a / r);\r\n        scale = {x: r, y: determ / r};\r\n        skew.x = atan((a * c + b * d) / (r * r));\r\n      }\r\n      else if (c || d) {\r\n        s = sqrt(c * c + d * d);\r\n        rotation = pi * 0.5 - (d > 0 ? acos(-c / s) : -acos(c / s));\r\n        scale = {x: determ / s, y: s};\r\n        skew.y = atan((a * c + b * d) / (s * s));\r\n      }\r\n      else { // a = b = c = d = 0\r\n        scale = {x: 0, y: 0};\r\n      }\r\n    }\r\n\r\n    return {\r\n      translate: translate,\r\n      rotation : rotation,\r\n      scale    : scale,\r\n      skew     : skew\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Returns the determinant of the current matrix.\r\n   * @returns {number}\r\n   */\r\n  determinant: function() {\r\n    return this.a * this.d - this.b * this.c\r\n  },\r\n\r\n  /**\r\n   * Apply current matrix to `x` and `y` of a point.\r\n   * Returns a point object.\r\n   *\r\n   * @param {number} x - value for x\r\n   * @param {number} y - value for y\r\n   * @returns {{x: number, y: number}} A new transformed point object\r\n   */\r\n  applyToPoint: function(x, y) {\r\n    var me = this;\r\n    return {\r\n      x: x * me.a + y * me.c + me.e,\r\n      y: x * me.b + y * me.d + me.f\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Apply current matrix to array with point objects or point pairs.\r\n   * Returns a new array with points in the same format as the input array.\r\n   *\r\n   * A point object is an object literal:\r\n   *\r\n   *     {x: x, y: y}\r\n   *\r\n   * so an array would contain either:\r\n   *\r\n   *     [{x: x1, y: y1}, {x: x2, y: y2}, ... {x: xn, y: yn}]\r\n   *\r\n   * or\r\n   *\r\n   *     [x1, y1, x2, y2, ... xn, yn]\r\n   *\r\n   * @param {Array} points - array with point objects or pairs\r\n   * @returns {Array} A new array with transformed points\r\n   */\r\n  applyToArray: function(points) {\r\n\r\n    var\r\n      i = 0, p, l,\r\n      mxPoints = [];\r\n\r\n    if (typeof points[0] === 'number') {\r\n\r\n      l = points.length;\r\n\r\n      while(i < l) {\r\n        p = this.applyToPoint(points[i++], points[i++]);\r\n        mxPoints.push(p.x, p.y);\r\n      }\r\n    }\r\n    else {\r\n      while(p = points[i++]) {\r\n        mxPoints.push(this.applyToPoint(p.x, p.y));\r\n      }\r\n    }\r\n\r\n    return mxPoints\r\n  },\r\n\r\n  /**\r\n   * Apply current matrix to a typed array with point pairs. Although\r\n   * the input array may be an ordinary array, this method is intended\r\n   * for more performant use where typed arrays are used. The returned\r\n   * array is regardless always returned as a `Float32Array`.\r\n   *\r\n   * @param {*} points - (typed) array with point pairs [x1, y1, ..., xn, yn]\r\n   * @param {boolean} [use64=false] - use Float64Array instead of Float32Array\r\n   * @returns {*} A new typed array with transformed points\r\n   */\r\n  applyToTypedArray: function(points, use64) {\r\n\r\n    var\r\n      i = 0, p,\r\n      l = points.length,\r\n      mxPoints = use64 ? new Float64Array(l) : new Float32Array(l);\r\n\r\n    while(i < l) {\r\n      p = this.applyToPoint(points[i], points[i + 1]);\r\n      mxPoints[i++] = p.x;\r\n      mxPoints[i++] = p.y;\r\n    }\r\n\r\n    return mxPoints\r\n  },\r\n\r\n  /**\r\n   * Apply to any canvas 2D context object. This does not affect the\r\n   * context that optionally was referenced in constructor unless it is\r\n   * the same context.\r\n   *\r\n   * @param {CanvasRenderingContext2D} context - target context\r\n   * @returns {Matrix}\r\n   */\r\n  applyToContext: function(context) {\r\n    var me = this;\r\n    context.setTransform(me.a, me.b, me.c, me.d, me.e, me.f);\r\n    return me\r\n  },\r\n\r\n  /**\r\n   * Apply to any DOM element. This does not affect the DOM element\r\n   * that optionally was referenced in constructor unless it is\r\n   * the same element.\r\n   *\r\n   * The method will auto-detect the correct browser prefix if any.\r\n   *\r\n   * @param {HTMLElement} element - target DOM element\r\n   * @param {boolean} [use3D=false] - use 3D transformation matrix instead of 2D\r\n   * @returns {Matrix}\r\n   */\r\n  applyToElement: function(element, use3D) {\r\n    var me = this;\r\n    if (!me._px) me._px = me._getPX();\r\n    element.style[me._px] = use3D ? me.toCSS3D() : me.toCSS();\r\n    return me\r\n  },\r\n\r\n  /**\r\n   * Instead of creating a new instance of a Matrix, DOMMatrix or SVGMatrix\r\n   * the current settings of this instance can be applied to an external\r\n   * object of a different (or same) type. You can also pass in an\r\n   * empty literal object.\r\n   *\r\n   * Note that the properties a-f will be set regardless of if they\r\n   * already exist or not.\r\n   *\r\n   * @param {*} obj - target object.\r\n   * @returns {Matrix}\r\n   */\r\n  applyToObject: function(obj) {\r\n    var me = this;\r\n    obj.a = me.a;\r\n    obj.b = me.b;\r\n    obj.c = me.c;\r\n    obj.d = me.d;\r\n    obj.e = me.e;\r\n    obj.f = me.f;\r\n    return me\r\n  },\r\n\r\n  /**\r\n   * Returns true if matrix is an identity matrix (no transforms applied).\r\n   * @returns {boolean}\r\n   */\r\n  isIdentity: function() {\r\n    var me = this;\r\n    return me.a === 1 && !me.b && !me.c && me.d === 1 && !me.e && !me.f\r\n  },\r\n\r\n  /**\r\n   * Returns true if matrix is invertible\r\n   * @returns {boolean}\r\n   */\r\n  isInvertible: function() {\r\n    return !this._q(this.determinant(), 0)\r\n  },\r\n\r\n  /**\r\n   * The method is intended for situations where scale is accumulated\r\n   * via multiplications, to detect situations where scale becomes\r\n   * \"trapped\" with a value of zero. And in which case scale must be\r\n   * set explicitly to a non-zero value.\r\n   *\r\n   * @returns {boolean}\r\n   */\r\n  isValid: function() {\r\n    return !(this.a * this.d)\r\n  },\r\n\r\n  /**\r\n   * Compares current matrix with another matrix. Returns true if equal\r\n   * (within epsilon tolerance).\r\n   * @param {Matrix|SVGMatrix} m - matrix to compare this matrix with\r\n   * @returns {boolean}\r\n   */\r\n  isEqual: function(m) {\r\n\r\n    var\r\n      me = this,\r\n      q = me._q;\r\n\r\n    return q(me.a, m.a) &&\r\n           q(me.b, m.b) &&\r\n           q(me.c, m.c) &&\r\n           q(me.d, m.d) &&\r\n           q(me.e, m.e) &&\r\n           q(me.f, m.f)\r\n  },\r\n\r\n  /**\r\n   * Clones current instance and returning a new matrix.\r\n   * @param {boolean} [noContext=false] don't clone context reference if true\r\n   * @returns {Matrix} - a new Matrix instance with identical transformations as this instance\r\n   */\r\n  clone: function(noContext) {\r\n    return new Matrix(noContext ? null : this.context).multiply(this)\r\n  },\r\n\r\n  /**\r\n   * Returns an array with current matrix values.\r\n   * @returns {Array}\r\n   */\r\n  toArray: function() {\r\n    var me = this;\r\n    return [me.a, me.b, me.c, me.d, me.e, me.f]\r\n  },\r\n\r\n  /**\r\n   * Returns a binary 32-bit floating point typed array.\r\n   * @returns {*}\r\n   */\r\n  toTypedArray: function() {\r\n    var me = this;\r\n    return new Float32Array([me.a, me.b, me.c, me.d, me.e, me.f]);\r\n  },\r\n\r\n  /**\r\n   * Generates a string that can be used with CSS `transform`.\r\n   * @example\r\n   *     element.style.transform = m.toCSS();\r\n   * @returns {string}\r\n   */\r\n  toCSS: function() {\r\n    return \"matrix(\" + this.toArray() + \")\"\r\n  },\r\n\r\n  /**\r\n   * Generates a `matrix3d()` string that can be used with CSS `transform`.\r\n   * Although the matrix is for 2D use you may see performance benefits\r\n   * on some devices using a 3D CSS transform instead of a 2D.\r\n   * @example\r\n   *     element.style.transform = m.toCSS3D();\r\n   * @returns {string}\r\n   */\r\n  toCSS3D: function() {\r\n    var me = this, n2 = \",0,0,\";\r\n    return \"matrix3d(\" + me.a + \",\" + me.b + n2 + me.c + \",\" + me.d + n2 + n2 + \",1,0,\" + me.e + \",\" + me.f + \",0,1)\"\r\n  },\r\n\r\n  /**\r\n   * Returns a JSON compatible string of current matrix.\r\n   * @returns {string}\r\n   */\r\n  toJSON: function() {\r\n    var me = this;\r\n    return '{\"a\":' + me.a + ',\"b\":' + me.b + ',\"c\":' + me.c + ',\"d\":' + me.d + ',\"e\":' + me.e + ',\"f\":' + me.f + '}'\r\n  },\r\n\r\n  /**\r\n   * Returns a string with current matrix as comma-separated list.\r\n   * @param {number} [fixLen=4] - truncate decimal values to number of digits\r\n   * @returns {string}\r\n   */\r\n  toString: function(fixLen) {\r\n    var me = this;\r\n    fixLen = fixLen || 4;\r\n    return \"a=\" + me.a.toFixed(fixLen) +\r\n           \" b=\" + me.b.toFixed(fixLen) +\r\n           \" c=\" + me.c.toFixed(fixLen) +\r\n           \" d=\" + me.d.toFixed(fixLen) +\r\n           \" e=\" + me.e.toFixed(fixLen) +\r\n           \" f=\" + me.f.toFixed(fixLen)\r\n  },\r\n\r\n  /**\r\n   * Returns a string with current matrix as comma-separated values\r\n   * string with line-end (CR+LF).\r\n   * @returns {string}\r\n   */\r\n  toCSV: function() {\r\n    return this.toArray().join() + \"\\r\\n\"\r\n  },\r\n\r\n  /**\r\n   * Convert current matrix into a `DOMMatrix`. If `DOMMatrix` is not\r\n   * supported, a `null` is returned.\r\n   *\r\n   * @returns {DOMMatrix}\r\n   * @see {@link https://drafts.fxtf.org/geometry/#dommatrix|MDN / SVGMatrix}\r\n   */\r\n  toDOMMatrix: function() {\r\n    var m = null;\r\n    if (\"DOMMatrix\" in window) {\r\n      m = new DOMMatrix();\r\n      m.a = this.a;\r\n      m.b = this.b;\r\n      m.c = this.c;\r\n      m.d = this.d;\r\n      m.e = this.e;\r\n      m.f = this.f;\r\n    }\r\n    return m\r\n  },\r\n\r\n  /**\r\n   * Convert current matrix into a `SVGMatrix`. If `SVGMatrix` is not\r\n   * supported, a `null` is returned.\r\n   *\r\n   * @returns {SVGMatrix}\r\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/SVGMatrix|MDN / SVGMatrix}\r\n   */\r\n  toSVGMatrix: function() {\r\n\r\n    var\r\n      me = this,\r\n      svg = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\"),\r\n      svgMatrix = null;\r\n\r\n    if (svg) {\r\n      svgMatrix = svg.createSVGMatrix();\r\n      svgMatrix.a = me.a;\r\n      svgMatrix.b = me.b;\r\n      svgMatrix.c = me.c;\r\n      svgMatrix.d = me.d;\r\n      svgMatrix.e = me.e;\r\n      svgMatrix.f = me.f;\r\n    }\r\n\r\n    return svgMatrix\r\n  },\r\n\r\n  /**\r\n   * Compares floating point values with some tolerance (epsilon)\r\n   * @param {number} f1 - float 1\r\n   * @param {number} f2 - float 2\r\n   * @returns {boolean}\r\n   * @private\r\n   */\r\n  _q: function(f1, f2) {\r\n    return Math.abs(f1 - f2) < 1e-14\r\n  },\r\n\r\n  /**\r\n   * Apply current absolute matrix to context if defined, to sync it.\r\n   * Apply current absolute matrix to element if defined, to sync it.\r\n   * @returns {Matrix}\r\n   * @private\r\n   */\r\n  _x: function() {\r\n\r\n    var me = this;\r\n\r\n    if (me.context)\r\n      me.context.setTransform(me.a, me.b, me.c, me.d, me.e, me.f);\r\n\r\n    if (me._st)\r\n      me._st[me._px] = me.useCSS3D ? me.toCSS3D() : me.toCSS();\t// can be optimized pre-storing func ref.\r\n\r\n    return me\r\n  }\r\n};\r\n\r\n// Node support\r\nif (typeof exports !== \"undefined\") exports.Matrix = Matrix;\r\n"]},"metadata":{},"sourceType":"script"}