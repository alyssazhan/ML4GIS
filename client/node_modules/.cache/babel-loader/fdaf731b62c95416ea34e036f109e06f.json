{"ast":null,"code":"import _objectSpread from \"/Users/yan/Documents/proj/ML4GIS/client/node_modules/react-scripts/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\n\nfunction clamp(num, min, max) {\n  return num <= min ? min : num >= max ? max : num;\n}\n\nexport default (expandingLine => {\n  const expandingWidth = expandingLine.expandingWidth || 0.005;\n  const pointPairs = expandingLine.points.map(({\n    x,\n    y,\n    angle,\n    width\n  }, i) => {\n    if (!angle) {\n      const n = expandingLine.points[clamp(i + 1, 0, expandingLine.points.length - 1)];\n      const p = expandingLine.points[clamp(i - 1, 0, expandingLine.points.length - 1)];\n      angle = Math.atan2(p.x - n.x, p.y - n.y) + Math.PI / 2;\n    }\n\n    const dx = Math.sin(angle) * (width || expandingWidth) / 2;\n    const dy = Math.cos(angle) * (width || expandingWidth) / 2;\n    return [{\n      x: x + dx,\n      y: y + dy\n    }, {\n      x: x - dx,\n      y: y - dy\n    }];\n  });\n  const firstSection = pointPairs.map(([p1, p2]) => p1);\n  const secondSection = pointPairs.map(([p1, p2]) => p2).asMutable();\n  secondSection.reverse();\n  const newPoints = firstSection.concat(secondSection).map(({\n    x,\n    y\n  }) => [x, y]);\n  return _objectSpread(_objectSpread({}, expandingLine), {}, {\n    type: \"polygon\",\n    open: false,\n    points: newPoints,\n    unfinished: undefined,\n    candidatePoint: undefined\n  }); // let { expandingWidth = 0.005, points } = region\n  // expandingWidth = points.slice(-1)[0].width || expandingWidth\n  // const lastPoint = points.slice(-1)[0]\n  // return (\n  //   <>\n  //     <polygon\n  //       points={\n  //         .map((p) => `${p.x * iw} ${p.y * ih}`)\n  //         .join(\" \")}\n  // return {\n  //   ...expandingLine,\n  //   unfinished: undefined,\n  //   candidatePoint: undefined,\n  // }\n});","map":{"version":3,"sources":["/Users/yan/Documents/proj/ML4GIS/client/src/annotateComponents/Annotator/reducers/convert-expanding-line-to-polygon.js"],"names":["clamp","num","min","max","expandingLine","expandingWidth","pointPairs","points","map","x","y","angle","width","i","n","length","p","Math","atan2","PI","dx","sin","dy","cos","firstSection","p1","p2","secondSection","asMutable","reverse","newPoints","concat","type","open","unfinished","undefined","candidatePoint"],"mappings":";;AAEA,SAASA,KAAT,CAAeC,GAAf,EAAoBC,GAApB,EAAyBC,GAAzB,EAA8B;AAC5B,SAAOF,GAAG,IAAIC,GAAP,GAAaA,GAAb,GAAmBD,GAAG,IAAIE,GAAP,GAAaA,GAAb,GAAmBF,GAA7C;AACD;;AAED,gBAAgBG,aAAD,IAAmB;AAChC,QAAMC,cAAc,GAAGD,aAAa,CAACC,cAAd,IAAgC,KAAvD;AACA,QAAMC,UAAU,GAAGF,aAAa,CAACG,MAAd,CAAqBC,GAArB,CAAyB,CAAC;AAAEC,IAAAA,CAAF;AAAKC,IAAAA,CAAL;AAAQC,IAAAA,KAAR;AAAeC,IAAAA;AAAf,GAAD,EAAyBC,CAAzB,KAA+B;AACzE,QAAI,CAACF,KAAL,EAAY;AACV,YAAMG,CAAC,GACLV,aAAa,CAACG,MAAd,CAAqBP,KAAK,CAACa,CAAC,GAAG,CAAL,EAAQ,CAAR,EAAWT,aAAa,CAACG,MAAd,CAAqBQ,MAArB,GAA8B,CAAzC,CAA1B,CADF;AAEA,YAAMC,CAAC,GACLZ,aAAa,CAACG,MAAd,CAAqBP,KAAK,CAACa,CAAC,GAAG,CAAL,EAAQ,CAAR,EAAWT,aAAa,CAACG,MAAd,CAAqBQ,MAArB,GAA8B,CAAzC,CAA1B,CADF;AAEAJ,MAAAA,KAAK,GAAGM,IAAI,CAACC,KAAL,CAAWF,CAAC,CAACP,CAAF,GAAMK,CAAC,CAACL,CAAnB,EAAsBO,CAAC,CAACN,CAAF,GAAMI,CAAC,CAACJ,CAA9B,IAAmCO,IAAI,CAACE,EAAL,GAAU,CAArD;AACD;;AACD,UAAMC,EAAE,GAAIH,IAAI,CAACI,GAAL,CAASV,KAAT,KAAmBC,KAAK,IAAIP,cAA5B,CAAD,GAAgD,CAA3D;AACA,UAAMiB,EAAE,GAAIL,IAAI,CAACM,GAAL,CAASZ,KAAT,KAAmBC,KAAK,IAAIP,cAA5B,CAAD,GAAgD,CAA3D;AACA,WAAO,CACL;AAAEI,MAAAA,CAAC,EAAEA,CAAC,GAAGW,EAAT;AAAaV,MAAAA,CAAC,EAAEA,CAAC,GAAGY;AAApB,KADK,EAEL;AAAEb,MAAAA,CAAC,EAAEA,CAAC,GAAGW,EAAT;AAAaV,MAAAA,CAAC,EAAEA,CAAC,GAAGY;AAApB,KAFK,CAAP;AAID,GAdkB,CAAnB;AAeA,QAAME,YAAY,GAAGlB,UAAU,CAACE,GAAX,CAAe,CAAC,CAACiB,EAAD,EAAKC,EAAL,CAAD,KAAcD,EAA7B,CAArB;AACA,QAAME,aAAa,GAAGrB,UAAU,CAACE,GAAX,CAAe,CAAC,CAACiB,EAAD,EAAKC,EAAL,CAAD,KAAcA,EAA7B,EAAiCE,SAAjC,EAAtB;AACAD,EAAAA,aAAa,CAACE,OAAd;AAEA,QAAMC,SAAS,GAAGN,YAAY,CAACO,MAAb,CAAoBJ,aAApB,EAAmCnB,GAAnC,CAAuC,CAAC;AAAEC,IAAAA,CAAF;AAAKC,IAAAA;AAAL,GAAD,KAAc,CAACD,CAAD,EAAIC,CAAJ,CAArD,CAAlB;AAEA,yCACKN,aADL;AAEE4B,IAAAA,IAAI,EAAE,SAFR;AAGEC,IAAAA,IAAI,EAAE,KAHR;AAIE1B,IAAAA,MAAM,EAAEuB,SAJV;AAKEI,IAAAA,UAAU,EAAEC,SALd;AAMEC,IAAAA,cAAc,EAAED;AANlB,KAvBgC,CAgChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACD,CA9CD","sourcesContent":["// @flow\n\nfunction clamp(num, min, max) {\n  return num <= min ? min : num >= max ? max : num\n}\n\nexport default (expandingLine) => {\n  const expandingWidth = expandingLine.expandingWidth || 0.005\n  const pointPairs = expandingLine.points.map(({ x, y, angle, width }, i) => {\n    if (!angle) {\n      const n =\n        expandingLine.points[clamp(i + 1, 0, expandingLine.points.length - 1)]\n      const p =\n        expandingLine.points[clamp(i - 1, 0, expandingLine.points.length - 1)]\n      angle = Math.atan2(p.x - n.x, p.y - n.y) + Math.PI / 2\n    }\n    const dx = (Math.sin(angle) * (width || expandingWidth)) / 2\n    const dy = (Math.cos(angle) * (width || expandingWidth)) / 2\n    return [\n      { x: x + dx, y: y + dy },\n      { x: x - dx, y: y - dy },\n    ]\n  })\n  const firstSection = pointPairs.map(([p1, p2]) => p1)\n  const secondSection = pointPairs.map(([p1, p2]) => p2).asMutable()\n  secondSection.reverse()\n\n  const newPoints = firstSection.concat(secondSection).map(({ x, y }) => [x, y])\n\n  return {\n    ...expandingLine,\n    type: \"polygon\",\n    open: false,\n    points: newPoints,\n    unfinished: undefined,\n    candidatePoint: undefined,\n  }\n\n  // let { expandingWidth = 0.005, points } = region\n  // expandingWidth = points.slice(-1)[0].width || expandingWidth\n  // const lastPoint = points.slice(-1)[0]\n  // return (\n  //   <>\n  //     <polygon\n  //       points={\n  //         .map((p) => `${p.x * iw} ${p.y * ih}`)\n  //         .join(\" \")}\n  // return {\n  //   ...expandingLine,\n  //   unfinished: undefined,\n  //   candidatePoint: undefined,\n  // }\n}\n"]},"metadata":{},"sourceType":"module"}