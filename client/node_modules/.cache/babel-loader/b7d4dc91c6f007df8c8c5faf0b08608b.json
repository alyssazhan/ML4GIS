{"ast":null,"code":"import _slicedToArray from \"/Users/yan/Documents/proj/ML4GIS/client/node_modules/react-scripts/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _objectSpread from \"/Users/yan/Documents/proj/ML4GIS/client/node_modules/react-scripts/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport _createForOfIteratorHelper from \"/Users/yan/Documents/proj/ML4GIS/client/node_modules/react-scripts/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nconst emptyArr = [];\nexport default ((keyframes, time) => {\n  if (keyframes[time || 0]) {\n    return keyframes[time || 0].regions;\n  } // Get surrounding video keyframes\n\n\n  const keyframeTimes = Object.keys(keyframes).map(a => parseInt(a)).filter(a => !isNaN(a));\n  if (keyframeTimes.length === 0) return emptyArr;\n  keyframeTimes.sort((a, b) => a - b);\n  let nextKeyframeTimeIndex = keyframeTimes.findIndex(kt => kt >= time);\n\n  if (nextKeyframeTimeIndex === -1) {\n    return keyframes[keyframeTimes[keyframeTimes.length - 1]].regions || emptyArr;\n  } else if (nextKeyframeTimeIndex === 0) {\n    return emptyArr;\n  }\n\n  const t1 = keyframeTimes[nextKeyframeTimeIndex - 1];\n  const prevKeyframe = keyframes[t1];\n  const t2 = keyframeTimes[nextKeyframeTimeIndex];\n  const nextKeyframe = keyframes[t2];\n  const prevRegionMap = {},\n        nextRegionMap = {};\n\n  var _iterator = _createForOfIteratorHelper(prevKeyframe.regions),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      const region = _step.value;\n      prevRegionMap[region.id] = region;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  var _iterator2 = _createForOfIteratorHelper(nextKeyframe.regions),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      const region = _step2.value;\n      nextRegionMap[region.id] = region;\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  const impliedRegions = []; // Weighted time coefficients for linear transition\n\n  const w1 = (t2 - time) / (t2 - t1);\n  const w2 = 1 - w1;\n\n  for (const regionId in prevRegionMap) {\n    const _ref = [prevRegionMap[regionId], nextRegionMap[regionId]],\n          prev = _ref[0],\n          next = _ref[1];\n\n    if (!next) {\n      impliedRegions.push(_objectSpread(_objectSpread({}, prev), {}, {\n        highlighted: false,\n        editingLabels: false\n      }));\n      continue;\n    }\n\n    switch (prev.type) {\n      case \"point\":\n        {\n          impliedRegions.push(_objectSpread(_objectSpread({}, prev), {}, {\n            highlighted: false,\n            editingLabels: false,\n            x: prev.x * w1 + next.x * w2,\n            y: prev.y * w1 + next.y * w2\n          }));\n          break;\n        }\n\n      case \"box\":\n        {\n          impliedRegions.push(_objectSpread(_objectSpread({}, prev), {}, {\n            highlighted: false,\n            editingLabels: false,\n            x: prev.x * w1 + next.x * w2,\n            y: prev.y * w1 + next.y * w2,\n            w: prev.w * w1 + next.w * w2,\n            h: prev.h * w1 + next.h * w2\n          }));\n          break;\n        }\n\n      case \"polygon\":\n        {\n          if (next.points.length === prev.points.length) {\n            impliedRegions.push(_objectSpread(_objectSpread({}, prev), {}, {\n              highlighted: false,\n              editingLabels: false,\n              points: prev.points.map((pp, i) => [pp[0] * w1 + next.points[i][0] * w2, pp[1] * w1 + next.points[i][1] * w2])\n            }));\n          } else {\n            impliedRegions.push(prev);\n          }\n\n          break;\n        }\n\n      case \"keypoints\":\n        {\n          const newPoints = {};\n\n          for (var _i = 0, _Object$entries = Object.entries(prev.points); _i < _Object$entries.length; _i++) {\n            const _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n                  pointId = _Object$entries$_i[0],\n                  prevPoint = _Object$entries$_i[1];\n\n            newPoints[pointId] = {\n              x: prevPoint.x * w1 + next.points[pointId].x * w2,\n              y: prevPoint.y * w1 + next.points[pointId].y * w2\n            };\n          }\n\n          impliedRegions.push(_objectSpread(_objectSpread({}, prev), {}, {\n            highlighted: false,\n            editingLabels: false,\n            points: newPoints\n          }));\n          break;\n        }\n\n      default:\n        break;\n    }\n  }\n\n  return impliedRegions;\n});","map":{"version":3,"sources":["/Users/yan/Documents/proj/ML4GIS/client/src/annotateComponents/Annotator/reducers/get-implied-video-regions.js"],"names":["emptyArr","keyframes","time","regions","keyframeTimes","Object","keys","map","a","parseInt","filter","isNaN","length","sort","b","nextKeyframeTimeIndex","findIndex","kt","t1","prevKeyframe","t2","nextKeyframe","prevRegionMap","nextRegionMap","region","id","impliedRegions","w1","w2","regionId","prev","next","push","highlighted","editingLabels","type","x","y","w","h","points","pp","i","newPoints","entries","pointId","prevPoint"],"mappings":"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","sourcesContent":["// @flow\n\nimport type { Region } from \"../../ImageCanvas/region-tools.js\"\n\nconst emptyArr = []\n\nexport default (\n  keyframes: { [string | number]: { regions: Array<Region> } },\n  time: number\n) => {\n  if (keyframes[time || 0]) {\n    return keyframes[time || 0].regions\n  }\n  // Get surrounding video keyframes\n  const keyframeTimes = Object.keys(keyframes)\n    .map((a) => parseInt(a))\n    .filter((a) => !isNaN(a))\n  if (keyframeTimes.length === 0) return emptyArr\n  keyframeTimes.sort((a, b) => a - b)\n  let nextKeyframeTimeIndex = keyframeTimes.findIndex((kt) => kt >= time)\n  if (nextKeyframeTimeIndex === -1) {\n    return (\n      keyframes[keyframeTimes[keyframeTimes.length - 1]].regions || emptyArr\n    )\n  } else if (nextKeyframeTimeIndex === 0) {\n    return emptyArr\n  }\n\n  const t1 = keyframeTimes[nextKeyframeTimeIndex - 1]\n  const prevKeyframe = keyframes[t1]\n  const t2 = keyframeTimes[nextKeyframeTimeIndex]\n  const nextKeyframe = keyframes[t2]\n\n  const [prevRegionMap, nextRegionMap] = [{}, {}]\n  for (const region of prevKeyframe.regions) prevRegionMap[region.id] = region\n  for (const region of nextKeyframe.regions) nextRegionMap[region.id] = region\n\n  const impliedRegions = []\n\n  // Weighted time coefficients for linear transition\n  const w1 = (t2 - time) / (t2 - t1)\n  const w2 = 1 - w1\n\n  for (const regionId in prevRegionMap) {\n    const [prev, next] = [prevRegionMap[regionId], nextRegionMap[regionId]]\n    if (!next) {\n      impliedRegions.push({\n        ...prev,\n        highlighted: false,\n        editingLabels: false,\n      })\n      continue\n    }\n    switch (prev.type) {\n      case \"point\": {\n        impliedRegions.push({\n          ...prev,\n          highlighted: false,\n          editingLabels: false,\n          x: prev.x * w1 + next.x * w2,\n          y: prev.y * w1 + next.y * w2,\n        })\n        break\n      }\n      case \"box\": {\n        impliedRegions.push({\n          ...prev,\n          highlighted: false,\n          editingLabels: false,\n          x: prev.x * w1 + next.x * w2,\n          y: prev.y * w1 + next.y * w2,\n          w: prev.w * w1 + next.w * w2,\n          h: prev.h * w1 + next.h * w2,\n        })\n        break\n      }\n      case \"polygon\": {\n        if (next.points.length === prev.points.length) {\n          impliedRegions.push({\n            ...prev,\n            highlighted: false,\n            editingLabels: false,\n            points: prev.points.map((pp, i) => [\n              pp[0] * w1 + next.points[i][0] * w2,\n              pp[1] * w1 + next.points[i][1] * w2,\n            ]),\n          })\n        } else {\n          impliedRegions.push(prev)\n        }\n        break\n      }\n      case \"keypoints\": {\n        const newPoints = {}\n        for (const [pointId, prevPoint] of Object.entries(prev.points)) {\n          newPoints[pointId] = {\n            x: prevPoint.x * w1 + next.points[pointId].x * w2,\n            y: prevPoint.y * w1 + next.points[pointId].y * w2,\n          }\n        }\n        impliedRegions.push({\n          ...prev,\n          highlighted: false,\n          editingLabels: false,\n          points: newPoints,\n        })\n        break\n      }\n      default:\n        break\n    }\n  }\n\n  return impliedRegions\n}\n"]},"metadata":{},"sourceType":"module"}