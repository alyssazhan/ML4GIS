{"ast":null,"code":"function _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport KeyEventType from '../../const/KeyEventType';\nimport ModifierFlagsDictionary from '../../const/ModifierFlagsDictionary';\nimport Logger from '../logging/Logger';\nimport KeyCombinationSerializer from '../shared/KeyCombinationSerializer';\nimport Configuration from '../config/Configuration';\nimport KeyHistory from '../listening/KeyHistory';\nimport KeyCombination from '../listening/KeyCombination';\nimport ComponentTree from '../definitions/ComponentTree';\nimport ComponentOptionsList from '../definitions/ComponentOptionsList';\nimport ActionResolver from '../matching/ActionResolver';\nimport arrayFrom from '../../utils/array/arrayFrom';\nimport isObject from '../../utils/object/isObject';\nimport isUndefined from '../../utils/isUndefined';\nimport copyAttributes from '../../utils/object/copyAttributes';\nimport hasKey from '../../utils/object/hasKey';\nimport describeKeyEventType from '../../helpers/logging/describeKeyEventType';\nimport printComponent from '../../helpers/logging/printComponent';\nimport hasKeyPressEvent from '../../helpers/resolving-handlers/hasKeyPressEvent';\nimport keyupIsHiddenByCmd from '../../helpers/resolving-handlers/keyupIsHiddenByCmd';\nimport stateFromEvent from '../../helpers/parsing-key-maps/stateFromEvent';\nvar SEQUENCE_ATTRIBUTES = ['sequence', 'action'];\nvar KEYMAP_ATTRIBUTES = ['name', 'description', 'group'];\n/**\r\n * Defines common behaviour for key event strategies\r\n * @abstract\r\n * @class\r\n */\n\nvar AbstractKeyEventStrategy = /*#__PURE__*/function () {\n  /********************************************************************************\r\n   * Init & Reset\r\n   ********************************************************************************/\n\n  /**\r\n   * Creates a new instance of an event strategy (this class is an abstract one and\r\n   * not intended to be instantiated directly).\r\n   * @param {Object} options Options for how event strategy should behave\r\n   * @param {Logger} options.logger The Logger to use to report event strategy actions\r\n   * @param {KeyEventManager} keyEventManager KeyEventManager used for passing\r\n   *        messages between key event strategies\r\n   */\n  function AbstractKeyEventStrategy() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var keyEventManager = arguments.length > 1 ? arguments[1] : undefined;\n\n    _classCallCheck(this, AbstractKeyEventStrategy);\n\n    this.logger = options.logger || new Logger('warn');\n    /**\r\n     * @typedef {number} ComponentId Unique index associated with every HotKeys component\r\n     * as it becomes active.\r\n     *\r\n     * For focus-only components, this happens when the component is focused. The HotKeys\r\n     * component closest to the DOM element in focus gets the smallest number (0) and\r\n     * those further up the render tree get larger (incrementing) numbers. When a different\r\n     * element is focused (triggering the creation of a new focus tree) all component indexes\r\n     * are reset (de-allocated) and re-assigned to the new tree of HotKeys components that\r\n     * are now in focus.\r\n     *\r\n     * For global components, component indexes are assigned when a HotKeys component is\r\n     * mounted, and de-allocated when it unmounts. The component index counter is never reset\r\n     * back to 0 and just keeps incrementing as new components are mounted.\r\n     */\n\n    /**\r\n     * Counter to maintain what the next component index should be\r\n     * @type {ComponentId}\r\n     */\n\n    this.componentId = -1;\n    /**\r\n     * Reference to key event manager, so that information may pass between the\r\n     * global strategy and the focus-only strategy\r\n     * @type {KeyEventManager}\r\n     */\n\n    this.keyEventManager = keyEventManager;\n    this._componentTree = new ComponentTree();\n    this.rootComponentId = null;\n\n    this._reset();\n\n    this.resetKeyHistory();\n  }\n  /**\r\n   * Resets all strategy state to the values it had when it was first created\r\n   * @protected\r\n   */\n\n\n  _createClass(AbstractKeyEventStrategy, [{\n    key: \"_reset\",\n    value: function _reset() {\n      this.componentList = new ComponentOptionsList();\n\n      this._initHandlerResolutionState();\n    }\n  }, {\n    key: \"_newKeyHistory\",\n    value: function _newKeyHistory() {\n      return new KeyHistory({\n        maxLength: this.componentList.getLongestSequence()\n      });\n    }\n  }, {\n    key: \"getKeyHistory\",\n    value: function getKeyHistory() {\n      if (this._keyHistory) {\n        return this._keyHistory;\n      } else {\n        this._keyHistory = this._newKeyHistory();\n      }\n\n      return this._keyHistory;\n    }\n    /**\r\n     * Resets the state of the values used to resolve which handler function should be\r\n     * called when key events match a registered key map\r\n     * @protected\r\n     */\n\n  }, {\n    key: \"_initHandlerResolutionState\",\n    value: function _initHandlerResolutionState() {\n      this._actionResolver = null;\n    }\n    /**\r\n     * Reset the state values that record the current and recent state of key events\r\n     * @param {Object} options An options hash\r\n     * @param {boolean} options.force Whether to force a hard reset of the key\r\n     *        combination history.\r\n     */\n\n  }, {\n    key: \"resetKeyHistory\",\n    value: function resetKeyHistory() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this.keypressEventsToSimulate = [];\n      this.keyupEventsToSimulate = [];\n\n      if (this.getKeyHistory().any() && !options.force) {\n        this._keyHistory = new KeyHistory({\n          maxLength: this.componentList.getLongestSequence()\n        }, new KeyCombination(this.getCurrentCombination().keysStillPressedDict()));\n      } else {\n        this._keyHistory = this._newKeyHistory();\n      }\n    }\n    /********************************************************************************\r\n     * Generating key maps\r\n     ********************************************************************************/\n\n    /**\r\n     * Returns a mapping of all of the application's actions and the key sequences\r\n     * needed to trigger them.\r\n     *\r\n     * @returns {ApplicationKeyMap} The application's key map\r\n     */\n\n  }, {\n    key: \"getApplicationKeyMap\",\n    value: function getApplicationKeyMap() {\n      if (this.rootComponentId === null) {\n        return {};\n      }\n\n      return this._buildApplicationKeyMap([this.rootComponentId], {});\n    }\n  }, {\n    key: \"_buildApplicationKeyMap\",\n    value: function _buildApplicationKeyMap(componentIds, keyMapSummary) {\n      var _this = this;\n\n      componentIds.forEach(function (componentId) {\n        var _this$_componentTree$ = _this._componentTree.get(componentId),\n            childIds = _this$_componentTree$.childIds,\n            keyMap = _this$_componentTree$.keyMap;\n\n        if (keyMap) {\n          Object.keys(keyMap).forEach(function (actionName) {\n            var keyMapConfig = keyMap[actionName];\n            keyMapSummary[actionName] = {};\n\n            if (isObject(keyMapConfig)) {\n              if (hasKey(keyMapConfig, 'sequences')) {\n                /**\r\n                 * Support syntax:\r\n                 *  {\r\n                 *    sequences: [ {sequence: 'a+b', action: 'keyup' }],\r\n                 *    name: 'My keymap',\r\n                 *    description: 'Key to press for something special',\r\n                 *    group: 'Vanity'\r\n                 *  }\r\n                 */\n                copyAttributes(keyMapConfig, keyMapSummary[actionName], KEYMAP_ATTRIBUTES);\n                keyMapSummary[actionName].sequences = _this._createSequenceFromConfig(keyMapConfig.sequences);\n              } else {\n                /**\r\n                 * Support syntax:\r\n                 * {\r\n                 *   sequence: 'a+b', action: 'keyup',\r\n                 *   name: 'My keymap',\r\n                 *   description: 'Key to press for something special',\r\n                 *   group: 'Vanity'\r\n                 * }\r\n                 */\n                copyAttributes(keyMapConfig, keyMapSummary[actionName], KEYMAP_ATTRIBUTES);\n                keyMapSummary[actionName].sequences = [copyAttributes(keyMapConfig, {}, SEQUENCE_ATTRIBUTES)];\n              }\n            } else {\n              keyMapSummary[actionName].sequences = _this._createSequenceFromConfig(keyMapConfig);\n            }\n          });\n        }\n\n        _this._buildApplicationKeyMap(childIds, keyMapSummary);\n      });\n      return keyMapSummary;\n    }\n  }, {\n    key: \"_createSequenceFromConfig\",\n    value: function _createSequenceFromConfig(keyMapConfig) {\n      return arrayFrom(keyMapConfig).map(function (sequenceOrKeyMapOptions) {\n        if (isObject(sequenceOrKeyMapOptions)) {\n          /**\r\n           * Support syntax:\r\n           * [\r\n           *   { sequence: 'a+b', action: 'keyup' },\r\n           *   { sequence: 'c' }\r\n           * ]\r\n           */\n          return copyAttributes(sequenceOrKeyMapOptions, {}, SEQUENCE_ATTRIBUTES);\n        } else {\n          /**\r\n           * Support syntax:\r\n           * 'a+b'\r\n           */\n          return {\n            sequence: sequenceOrKeyMapOptions\n          };\n        }\n      });\n    }\n    /********************************************************************************\r\n     * Registering key maps\r\n     ********************************************************************************/\n\n    /**\r\n     * Registers a new mounted component's key map so that it can be included in the\r\n     * application's key map\r\n     * @param {KeyMap} keyMap - Map of actions to key expressions\r\n     * @returns {ComponentId} Unique component ID to assign to the focused HotKeys\r\n     *          component and passed back when handling a key event\r\n     */\n\n  }, {\n    key: \"registerKeyMap\",\n    value: function registerKeyMap(keyMap) {\n      this.componentId += 1;\n\n      this._componentTree.add(this.componentId, keyMap);\n\n      this.logger.verbose(this._logPrefix(this.componentId), 'Registered component:\\n', \"\".concat(printComponent(this._componentTree.get(this.componentId))));\n      return this.componentId;\n    }\n    /**\r\n     * Re-registers (updates) a mounted component's key map\r\n     * @param {ComponentId} componentId - Id of the component that the keyMap belongs to\r\n     * @param {KeyMap} keyMap - Map of actions to key expressions\r\n     */\n\n  }, {\n    key: \"reregisterKeyMap\",\n    value: function reregisterKeyMap(componentId, keyMap) {\n      this._componentTree.update(componentId, keyMap);\n    }\n    /**\r\n     * Registers that a component has now mounted, and declares its parent hot keys\r\n     * component id so that actions may be properly resolved\r\n     * @param {ComponentId} componentId - Id of the component that has mounted\r\n     * @param {ComponentId} parentId - Id of the parent hot keys component\r\n     */\n\n  }, {\n    key: \"registerComponentMount\",\n    value: function registerComponentMount(componentId, parentId) {\n      if (!isUndefined(parentId)) {\n        this._componentTree.setParent(componentId, parentId);\n      } else {\n        this.rootComponentId = componentId;\n      }\n\n      this.logger.verbose(this._logPrefix(componentId), 'Registered component mount:\\n', \"\".concat(printComponent(this._componentTree.get(componentId))));\n    }\n    /**\r\n     * De-registers (removes) a mounted component's key map from the registry\r\n     * @param {ComponentId} componentId - Id of the component that the keyMap\r\n     *        belongs to\r\n     */\n\n  }, {\n    key: \"deregisterKeyMap\",\n    value: function deregisterKeyMap(componentId) {\n      this._componentTree.remove(componentId);\n\n      this.logger.verbose(this._logPrefix(componentId), 'De-registered component. Remaining component Registry:\\n', \"\".concat(printComponent(this._componentTree.toJSON())));\n\n      if (componentId === this.rootComponentId) {\n        this.rootComponentId = null;\n      }\n    }\n    /********************************************************************************\r\n     * Registering key maps and handlers\r\n     ********************************************************************************/\n\n    /**\r\n     * Registers the hotkeys defined by a HotKeys component\r\n     * @param {ComponentId} componentId - Index of the component\r\n     * @param {KeyMap} actionNameToKeyMap - Definition of actions and key maps defined\r\n     *        in the HotKeys component\r\n     * @param {HandlersMap} actionNameToHandlersMap - Map of ActionNames to handlers\r\n     *        defined in the HotKeys component\r\n     * @param {Object} options - Hash of options that configure how the key map is built.\r\n     * @protected\r\n     */\n\n  }, {\n    key: \"_addComponent\",\n    value: function _addComponent(componentId) {\n      var actionNameToKeyMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var actionNameToHandlersMap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var options = arguments.length > 3 ? arguments[3] : undefined;\n      this.componentList.add(componentId, actionNameToKeyMap, actionNameToHandlersMap, options);\n      this.getKeyHistory().setMaxLength(this.componentList.getLongestSequence());\n    }\n    /********************************************************************************\r\n     * Recording key events\r\n     ********************************************************************************/\n\n    /**\r\n     * Whether there are any keys in the current combination still being pressed\r\n     * @returns {boolean} True if all keys in the current combination are released\r\n     * @protected\r\n     */\n\n  }, {\n    key: \"_allKeysAreReleased\",\n    value: function _allKeysAreReleased() {\n      return this.getCurrentCombination().hasEnded();\n    }\n  }, {\n    key: \"getCurrentCombination\",\n    value: function getCurrentCombination() {\n      return this.getKeyHistory().getCurrentCombination();\n    }\n  }, {\n    key: \"_shouldSimulate\",\n    value: function _shouldSimulate(eventType, keyName) {\n      var keyHasNativeKeyPress = hasKeyPressEvent(keyName);\n      var currentCombination = this.getCurrentCombination();\n\n      if (eventType === KeyEventType.keypress) {\n        return !keyHasNativeKeyPress || keyHasNativeKeyPress && currentCombination.isKeyStillPressed('Meta');\n      } else if (eventType === KeyEventType.keyup) {\n        return keyupIsHiddenByCmd(keyName) && currentCombination.isKeyReleased('Meta');\n      }\n\n      return false;\n    }\n  }, {\n    key: \"_cloneAndMergeEvent\",\n    value: function _cloneAndMergeEvent(event, extra) {\n      var eventAttributes = Object.keys(ModifierFlagsDictionary).reduce(function (memo, eventAttribute) {\n        memo[eventAttribute] = event[eventAttribute];\n        return memo;\n      }, {});\n      return _objectSpread({}, eventAttributes, extra);\n    }\n    /********************************************************************************\r\n     * Matching and calling handlers\r\n     ********************************************************************************/\n\n  }, {\n    key: \"_callClosestMatchingHandler\",\n    value: function _callClosestMatchingHandler(event, keyName, keyEventType, componentPosition, componentSearchIndex) {\n      if (!this._actionResolver) {\n        this._actionResolver = new ActionResolver(this.componentList);\n      }\n\n      while (componentSearchIndex <= componentPosition) {\n        var keyHistoryMatcher = this._actionResolver.getKeyHistoryMatcher(componentSearchIndex);\n\n        this.logger.verbose(this._logPrefix(componentSearchIndex), 'Internal key mapping:\\n', \"\".concat(printComponent(keyHistoryMatcher.toJSON())));\n\n        var sequenceMatch = this._actionResolver.findMatchingKeySequenceInComponent(componentSearchIndex, this.getKeyHistory(), keyName, keyEventType);\n\n        var currentCombination = this.getCurrentCombination();\n\n        if (sequenceMatch) {\n          var eventSchema = sequenceMatch.events[keyEventType];\n\n          if (Configuration.option('allowCombinationSubmatches')) {\n            var subMatchDescription = KeyCombinationSerializer.serialize(sequenceMatch.keyDictionary);\n            this.logger.debug(this._logPrefix(componentSearchIndex), \"Found action that matches '\".concat(currentCombination.describe(), \"' (sub-match: '\").concat(subMatchDescription, \"'): \").concat(eventSchema.actionName, \". Calling handler . . .\"));\n          } else {\n            this.logger.debug(this._logPrefix(componentSearchIndex), \"Found action that matches '\".concat(currentCombination.describe(), \"': \").concat(eventSchema.actionName, \". Calling handler . . .\"));\n          }\n\n          eventSchema.handler(event);\n\n          this._stopEventPropagationAfterHandlingIfEnabled(event, componentSearchIndex);\n\n          return true;\n        } else {\n          if (this._actionResolver.componentHasActionsBoundToEventType(componentSearchIndex, keyEventType)) {\n            var eventName = describeKeyEventType(keyEventType);\n            this.logger.debug(this._logPrefix(componentSearchIndex), \"No matching actions found for '\".concat(currentCombination.describe(), \"' \").concat(eventName, \".\"));\n          } else {\n            this.logger.debug(this._logPrefix(componentSearchIndex), \"Doesn't define a handler for '\".concat(currentCombination.describe(), \"' \").concat(describeKeyEventType(keyEventType), \".\"));\n          }\n        }\n\n        componentSearchIndex++;\n      }\n    }\n  }, {\n    key: \"_stopEventPropagationAfterHandlingIfEnabled\",\n    value: function _stopEventPropagationAfterHandlingIfEnabled(event, componentId) {\n      if (Configuration.option('stopEventPropagationAfterHandling')) {\n        this._stopEventPropagation(event, componentId);\n\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"_stopEventPropagation\",\n    value: function _stopEventPropagation(event, componentId) {\n      throw new Error('_stopEventPropagation must be overridden by a subclass');\n    }\n    /**\r\n     * Synchronises the key combination history to match the modifier key flag attributes\r\n     * on new key events\r\n     * @param {KeyboardEvent} event - Event to check the modifier flags for\r\n     * @param {string} key - Name of key that events relates to\r\n     * @param {KeyEventType} keyEventType - The record index of the current\r\n     *        key event type\r\n     * @protected\r\n     */\n\n  }, {\n    key: \"_checkForModifierFlagDiscrepancies\",\n    value: function _checkForModifierFlagDiscrepancies(event, key, keyEventType) {\n      var _this2 = this;\n      /**\r\n       * If a new key event is received with modifier key flags that contradict the\r\n       * key combination history we are maintaining, we can surmise that some keyup events\r\n       * for those modifier keys have been lost (possibly because the window lost focus).\r\n       * We update the key combination to match the modifier flags\r\n       */\n\n\n      Object.keys(ModifierFlagsDictionary).forEach(function (modifierKey) {\n        /**\r\n         * When a modifier key is being released (keyup), it sets its own modifier flag\r\n         * to false. (e.g. On the keyup event for Command, the metaKey attribute is false).\r\n         * If this the case, we want to handle it using the main algorithm and skip the\r\n         * reconciliation algorithm.\r\n         */\n        if (key === modifierKey && keyEventType === KeyEventType.keyup) {\n          return;\n        }\n\n        var currentCombination = _this2.getCurrentCombination();\n\n        var modifierStillPressed = currentCombination.isKeyStillPressed(modifierKey);\n        ModifierFlagsDictionary[modifierKey].forEach(function (attributeName) {\n          if (event[attributeName] === false && modifierStillPressed) {\n            currentCombination.setKeyState(modifierKey, KeyEventType.keyup, stateFromEvent(event));\n          }\n        });\n      });\n    }\n    /**\r\n     * Returns a prefix for all log entries related to the current event strategy\r\n     * @protected\r\n     * @abstract\r\n     */\n\n  }, {\n    key: \"_logPrefix\",\n    value: function _logPrefix() {}\n  }]);\n\n  return AbstractKeyEventStrategy;\n}();\n\nexport default AbstractKeyEventStrategy;","map":{"version":3,"sources":["D:/GitHub/ML4GIS/client/node_modules/react-hotkeys/es/lib/strategies/AbstractKeyEventStrategy.js"],"names":["_objectSpread","target","i","arguments","length","source","ownKeys","Object","keys","getOwnPropertySymbols","concat","filter","sym","getOwnPropertyDescriptor","enumerable","forEach","key","_defineProperty","obj","value","defineProperty","configurable","writable","_classCallCheck","instance","Constructor","TypeError","_defineProperties","props","descriptor","_createClass","protoProps","staticProps","prototype","KeyEventType","ModifierFlagsDictionary","Logger","KeyCombinationSerializer","Configuration","KeyHistory","KeyCombination","ComponentTree","ComponentOptionsList","ActionResolver","arrayFrom","isObject","isUndefined","copyAttributes","hasKey","describeKeyEventType","printComponent","hasKeyPressEvent","keyupIsHiddenByCmd","stateFromEvent","SEQUENCE_ATTRIBUTES","KEYMAP_ATTRIBUTES","AbstractKeyEventStrategy","options","undefined","keyEventManager","logger","componentId","_componentTree","rootComponentId","_reset","resetKeyHistory","componentList","_initHandlerResolutionState","_newKeyHistory","maxLength","getLongestSequence","getKeyHistory","_keyHistory","_actionResolver","keypressEventsToSimulate","keyupEventsToSimulate","any","force","getCurrentCombination","keysStillPressedDict","getApplicationKeyMap","_buildApplicationKeyMap","componentIds","keyMapSummary","_this","_this$_componentTree$","get","childIds","keyMap","actionName","keyMapConfig","sequences","_createSequenceFromConfig","map","sequenceOrKeyMapOptions","sequence","registerKeyMap","add","verbose","_logPrefix","reregisterKeyMap","update","registerComponentMount","parentId","setParent","deregisterKeyMap","remove","toJSON","_addComponent","actionNameToKeyMap","actionNameToHandlersMap","setMaxLength","_allKeysAreReleased","hasEnded","_shouldSimulate","eventType","keyName","keyHasNativeKeyPress","currentCombination","keypress","isKeyStillPressed","keyup","isKeyReleased","_cloneAndMergeEvent","event","extra","eventAttributes","reduce","memo","eventAttribute","_callClosestMatchingHandler","keyEventType","componentPosition","componentSearchIndex","keyHistoryMatcher","getKeyHistoryMatcher","sequenceMatch","findMatchingKeySequenceInComponent","eventSchema","events","option","subMatchDescription","serialize","keyDictionary","debug","describe","handler","_stopEventPropagationAfterHandlingIfEnabled","componentHasActionsBoundToEventType","eventName","_stopEventPropagation","Error","_checkForModifierFlagDiscrepancies","_this2","modifierKey","modifierStillPressed","attributeName","setKeyState"],"mappings":"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","sourcesContent":["function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\r\n\r\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\r\n\r\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\r\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\r\n\r\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\r\n\r\nimport KeyEventType from '../../const/KeyEventType';\r\nimport ModifierFlagsDictionary from '../../const/ModifierFlagsDictionary';\r\nimport Logger from '../logging/Logger';\r\nimport KeyCombinationSerializer from '../shared/KeyCombinationSerializer';\r\nimport Configuration from '../config/Configuration';\r\nimport KeyHistory from '../listening/KeyHistory';\r\nimport KeyCombination from '../listening/KeyCombination';\r\nimport ComponentTree from '../definitions/ComponentTree';\r\nimport ComponentOptionsList from '../definitions/ComponentOptionsList';\r\nimport ActionResolver from '../matching/ActionResolver';\r\nimport arrayFrom from '../../utils/array/arrayFrom';\r\nimport isObject from '../../utils/object/isObject';\r\nimport isUndefined from '../../utils/isUndefined';\r\nimport copyAttributes from '../../utils/object/copyAttributes';\r\nimport hasKey from '../../utils/object/hasKey';\r\nimport describeKeyEventType from '../../helpers/logging/describeKeyEventType';\r\nimport printComponent from '../../helpers/logging/printComponent';\r\nimport hasKeyPressEvent from '../../helpers/resolving-handlers/hasKeyPressEvent';\r\nimport keyupIsHiddenByCmd from '../../helpers/resolving-handlers/keyupIsHiddenByCmd';\r\nimport stateFromEvent from '../../helpers/parsing-key-maps/stateFromEvent';\r\nvar SEQUENCE_ATTRIBUTES = ['sequence', 'action'];\r\nvar KEYMAP_ATTRIBUTES = ['name', 'description', 'group'];\r\n/**\r\n * Defines common behaviour for key event strategies\r\n * @abstract\r\n * @class\r\n */\r\n\r\nvar AbstractKeyEventStrategy =\r\n/*#__PURE__*/\r\nfunction () {\r\n  /********************************************************************************\r\n   * Init & Reset\r\n   ********************************************************************************/\r\n\r\n  /**\r\n   * Creates a new instance of an event strategy (this class is an abstract one and\r\n   * not intended to be instantiated directly).\r\n   * @param {Object} options Options for how event strategy should behave\r\n   * @param {Logger} options.logger The Logger to use to report event strategy actions\r\n   * @param {KeyEventManager} keyEventManager KeyEventManager used for passing\r\n   *        messages between key event strategies\r\n   */\r\n  function AbstractKeyEventStrategy() {\r\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\r\n    var keyEventManager = arguments.length > 1 ? arguments[1] : undefined;\r\n\r\n    _classCallCheck(this, AbstractKeyEventStrategy);\r\n\r\n    this.logger = options.logger || new Logger('warn');\r\n    /**\r\n     * @typedef {number} ComponentId Unique index associated with every HotKeys component\r\n     * as it becomes active.\r\n     *\r\n     * For focus-only components, this happens when the component is focused. The HotKeys\r\n     * component closest to the DOM element in focus gets the smallest number (0) and\r\n     * those further up the render tree get larger (incrementing) numbers. When a different\r\n     * element is focused (triggering the creation of a new focus tree) all component indexes\r\n     * are reset (de-allocated) and re-assigned to the new tree of HotKeys components that\r\n     * are now in focus.\r\n     *\r\n     * For global components, component indexes are assigned when a HotKeys component is\r\n     * mounted, and de-allocated when it unmounts. The component index counter is never reset\r\n     * back to 0 and just keeps incrementing as new components are mounted.\r\n     */\r\n\r\n    /**\r\n     * Counter to maintain what the next component index should be\r\n     * @type {ComponentId}\r\n     */\r\n\r\n    this.componentId = -1;\r\n    /**\r\n     * Reference to key event manager, so that information may pass between the\r\n     * global strategy and the focus-only strategy\r\n     * @type {KeyEventManager}\r\n     */\r\n\r\n    this.keyEventManager = keyEventManager;\r\n    this._componentTree = new ComponentTree();\r\n    this.rootComponentId = null;\r\n\r\n    this._reset();\r\n\r\n    this.resetKeyHistory();\r\n  }\r\n  /**\r\n   * Resets all strategy state to the values it had when it was first created\r\n   * @protected\r\n   */\r\n\r\n\r\n  _createClass(AbstractKeyEventStrategy, [{\r\n    key: \"_reset\",\r\n    value: function _reset() {\r\n      this.componentList = new ComponentOptionsList();\r\n\r\n      this._initHandlerResolutionState();\r\n    }\r\n  }, {\r\n    key: \"_newKeyHistory\",\r\n    value: function _newKeyHistory() {\r\n      return new KeyHistory({\r\n        maxLength: this.componentList.getLongestSequence()\r\n      });\r\n    }\r\n  }, {\r\n    key: \"getKeyHistory\",\r\n    value: function getKeyHistory() {\r\n      if (this._keyHistory) {\r\n        return this._keyHistory;\r\n      } else {\r\n        this._keyHistory = this._newKeyHistory();\r\n      }\r\n\r\n      return this._keyHistory;\r\n    }\r\n    /**\r\n     * Resets the state of the values used to resolve which handler function should be\r\n     * called when key events match a registered key map\r\n     * @protected\r\n     */\r\n\r\n  }, {\r\n    key: \"_initHandlerResolutionState\",\r\n    value: function _initHandlerResolutionState() {\r\n      this._actionResolver = null;\r\n    }\r\n    /**\r\n     * Reset the state values that record the current and recent state of key events\r\n     * @param {Object} options An options hash\r\n     * @param {boolean} options.force Whether to force a hard reset of the key\r\n     *        combination history.\r\n     */\r\n\r\n  }, {\r\n    key: \"resetKeyHistory\",\r\n    value: function resetKeyHistory() {\r\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\r\n      this.keypressEventsToSimulate = [];\r\n      this.keyupEventsToSimulate = [];\r\n\r\n      if (this.getKeyHistory().any() && !options.force) {\r\n        this._keyHistory = new KeyHistory({\r\n          maxLength: this.componentList.getLongestSequence()\r\n        }, new KeyCombination(this.getCurrentCombination().keysStillPressedDict()));\r\n      } else {\r\n        this._keyHistory = this._newKeyHistory();\r\n      }\r\n    }\r\n    /********************************************************************************\r\n     * Generating key maps\r\n     ********************************************************************************/\r\n\r\n    /**\r\n     * Returns a mapping of all of the application's actions and the key sequences\r\n     * needed to trigger them.\r\n     *\r\n     * @returns {ApplicationKeyMap} The application's key map\r\n     */\r\n\r\n  }, {\r\n    key: \"getApplicationKeyMap\",\r\n    value: function getApplicationKeyMap() {\r\n      if (this.rootComponentId === null) {\r\n        return {};\r\n      }\r\n\r\n      return this._buildApplicationKeyMap([this.rootComponentId], {});\r\n    }\r\n  }, {\r\n    key: \"_buildApplicationKeyMap\",\r\n    value: function _buildApplicationKeyMap(componentIds, keyMapSummary) {\r\n      var _this = this;\r\n\r\n      componentIds.forEach(function (componentId) {\r\n        var _this$_componentTree$ = _this._componentTree.get(componentId),\r\n            childIds = _this$_componentTree$.childIds,\r\n            keyMap = _this$_componentTree$.keyMap;\r\n\r\n        if (keyMap) {\r\n          Object.keys(keyMap).forEach(function (actionName) {\r\n            var keyMapConfig = keyMap[actionName];\r\n            keyMapSummary[actionName] = {};\r\n\r\n            if (isObject(keyMapConfig)) {\r\n              if (hasKey(keyMapConfig, 'sequences')) {\r\n                /**\r\n                 * Support syntax:\r\n                 *  {\r\n                 *    sequences: [ {sequence: 'a+b', action: 'keyup' }],\r\n                 *    name: 'My keymap',\r\n                 *    description: 'Key to press for something special',\r\n                 *    group: 'Vanity'\r\n                 *  }\r\n                 */\r\n                copyAttributes(keyMapConfig, keyMapSummary[actionName], KEYMAP_ATTRIBUTES);\r\n                keyMapSummary[actionName].sequences = _this._createSequenceFromConfig(keyMapConfig.sequences);\r\n              } else {\r\n                /**\r\n                 * Support syntax:\r\n                 * {\r\n                 *   sequence: 'a+b', action: 'keyup',\r\n                 *   name: 'My keymap',\r\n                 *   description: 'Key to press for something special',\r\n                 *   group: 'Vanity'\r\n                 * }\r\n                 */\r\n                copyAttributes(keyMapConfig, keyMapSummary[actionName], KEYMAP_ATTRIBUTES);\r\n                keyMapSummary[actionName].sequences = [copyAttributes(keyMapConfig, {}, SEQUENCE_ATTRIBUTES)];\r\n              }\r\n            } else {\r\n              keyMapSummary[actionName].sequences = _this._createSequenceFromConfig(keyMapConfig);\r\n            }\r\n          });\r\n        }\r\n\r\n        _this._buildApplicationKeyMap(childIds, keyMapSummary);\r\n      });\r\n      return keyMapSummary;\r\n    }\r\n  }, {\r\n    key: \"_createSequenceFromConfig\",\r\n    value: function _createSequenceFromConfig(keyMapConfig) {\r\n      return arrayFrom(keyMapConfig).map(function (sequenceOrKeyMapOptions) {\r\n        if (isObject(sequenceOrKeyMapOptions)) {\r\n          /**\r\n           * Support syntax:\r\n           * [\r\n           *   { sequence: 'a+b', action: 'keyup' },\r\n           *   { sequence: 'c' }\r\n           * ]\r\n           */\r\n          return copyAttributes(sequenceOrKeyMapOptions, {}, SEQUENCE_ATTRIBUTES);\r\n        } else {\r\n          /**\r\n           * Support syntax:\r\n           * 'a+b'\r\n           */\r\n          return {\r\n            sequence: sequenceOrKeyMapOptions\r\n          };\r\n        }\r\n      });\r\n    }\r\n    /********************************************************************************\r\n     * Registering key maps\r\n     ********************************************************************************/\r\n\r\n    /**\r\n     * Registers a new mounted component's key map so that it can be included in the\r\n     * application's key map\r\n     * @param {KeyMap} keyMap - Map of actions to key expressions\r\n     * @returns {ComponentId} Unique component ID to assign to the focused HotKeys\r\n     *          component and passed back when handling a key event\r\n     */\r\n\r\n  }, {\r\n    key: \"registerKeyMap\",\r\n    value: function registerKeyMap(keyMap) {\r\n      this.componentId += 1;\r\n\r\n      this._componentTree.add(this.componentId, keyMap);\r\n\r\n      this.logger.verbose(this._logPrefix(this.componentId), 'Registered component:\\n', \"\".concat(printComponent(this._componentTree.get(this.componentId))));\r\n      return this.componentId;\r\n    }\r\n    /**\r\n     * Re-registers (updates) a mounted component's key map\r\n     * @param {ComponentId} componentId - Id of the component that the keyMap belongs to\r\n     * @param {KeyMap} keyMap - Map of actions to key expressions\r\n     */\r\n\r\n  }, {\r\n    key: \"reregisterKeyMap\",\r\n    value: function reregisterKeyMap(componentId, keyMap) {\r\n      this._componentTree.update(componentId, keyMap);\r\n    }\r\n    /**\r\n     * Registers that a component has now mounted, and declares its parent hot keys\r\n     * component id so that actions may be properly resolved\r\n     * @param {ComponentId} componentId - Id of the component that has mounted\r\n     * @param {ComponentId} parentId - Id of the parent hot keys component\r\n     */\r\n\r\n  }, {\r\n    key: \"registerComponentMount\",\r\n    value: function registerComponentMount(componentId, parentId) {\r\n      if (!isUndefined(parentId)) {\r\n        this._componentTree.setParent(componentId, parentId);\r\n      } else {\r\n        this.rootComponentId = componentId;\r\n      }\r\n\r\n      this.logger.verbose(this._logPrefix(componentId), 'Registered component mount:\\n', \"\".concat(printComponent(this._componentTree.get(componentId))));\r\n    }\r\n    /**\r\n     * De-registers (removes) a mounted component's key map from the registry\r\n     * @param {ComponentId} componentId - Id of the component that the keyMap\r\n     *        belongs to\r\n     */\r\n\r\n  }, {\r\n    key: \"deregisterKeyMap\",\r\n    value: function deregisterKeyMap(componentId) {\r\n      this._componentTree.remove(componentId);\r\n\r\n      this.logger.verbose(this._logPrefix(componentId), 'De-registered component. Remaining component Registry:\\n', \"\".concat(printComponent(this._componentTree.toJSON())));\r\n\r\n      if (componentId === this.rootComponentId) {\r\n        this.rootComponentId = null;\r\n      }\r\n    }\r\n    /********************************************************************************\r\n     * Registering key maps and handlers\r\n     ********************************************************************************/\r\n\r\n    /**\r\n     * Registers the hotkeys defined by a HotKeys component\r\n     * @param {ComponentId} componentId - Index of the component\r\n     * @param {KeyMap} actionNameToKeyMap - Definition of actions and key maps defined\r\n     *        in the HotKeys component\r\n     * @param {HandlersMap} actionNameToHandlersMap - Map of ActionNames to handlers\r\n     *        defined in the HotKeys component\r\n     * @param {Object} options - Hash of options that configure how the key map is built.\r\n     * @protected\r\n     */\r\n\r\n  }, {\r\n    key: \"_addComponent\",\r\n    value: function _addComponent(componentId) {\r\n      var actionNameToKeyMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\r\n      var actionNameToHandlersMap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\r\n      var options = arguments.length > 3 ? arguments[3] : undefined;\r\n      this.componentList.add(componentId, actionNameToKeyMap, actionNameToHandlersMap, options);\r\n      this.getKeyHistory().setMaxLength(this.componentList.getLongestSequence());\r\n    }\r\n    /********************************************************************************\r\n     * Recording key events\r\n     ********************************************************************************/\r\n\r\n    /**\r\n     * Whether there are any keys in the current combination still being pressed\r\n     * @returns {boolean} True if all keys in the current combination are released\r\n     * @protected\r\n     */\r\n\r\n  }, {\r\n    key: \"_allKeysAreReleased\",\r\n    value: function _allKeysAreReleased() {\r\n      return this.getCurrentCombination().hasEnded();\r\n    }\r\n  }, {\r\n    key: \"getCurrentCombination\",\r\n    value: function getCurrentCombination() {\r\n      return this.getKeyHistory().getCurrentCombination();\r\n    }\r\n  }, {\r\n    key: \"_shouldSimulate\",\r\n    value: function _shouldSimulate(eventType, keyName) {\r\n      var keyHasNativeKeyPress = hasKeyPressEvent(keyName);\r\n      var currentCombination = this.getCurrentCombination();\r\n\r\n      if (eventType === KeyEventType.keypress) {\r\n        return !keyHasNativeKeyPress || keyHasNativeKeyPress && currentCombination.isKeyStillPressed('Meta');\r\n      } else if (eventType === KeyEventType.keyup) {\r\n        return keyupIsHiddenByCmd(keyName) && currentCombination.isKeyReleased('Meta');\r\n      }\r\n\r\n      return false;\r\n    }\r\n  }, {\r\n    key: \"_cloneAndMergeEvent\",\r\n    value: function _cloneAndMergeEvent(event, extra) {\r\n      var eventAttributes = Object.keys(ModifierFlagsDictionary).reduce(function (memo, eventAttribute) {\r\n        memo[eventAttribute] = event[eventAttribute];\r\n        return memo;\r\n      }, {});\r\n      return _objectSpread({}, eventAttributes, extra);\r\n    }\r\n    /********************************************************************************\r\n     * Matching and calling handlers\r\n     ********************************************************************************/\r\n\r\n  }, {\r\n    key: \"_callClosestMatchingHandler\",\r\n    value: function _callClosestMatchingHandler(event, keyName, keyEventType, componentPosition, componentSearchIndex) {\r\n      if (!this._actionResolver) {\r\n        this._actionResolver = new ActionResolver(this.componentList);\r\n      }\r\n\r\n      while (componentSearchIndex <= componentPosition) {\r\n        var keyHistoryMatcher = this._actionResolver.getKeyHistoryMatcher(componentSearchIndex);\r\n\r\n        this.logger.verbose(this._logPrefix(componentSearchIndex), 'Internal key mapping:\\n', \"\".concat(printComponent(keyHistoryMatcher.toJSON())));\r\n\r\n        var sequenceMatch = this._actionResolver.findMatchingKeySequenceInComponent(componentSearchIndex, this.getKeyHistory(), keyName, keyEventType);\r\n\r\n        var currentCombination = this.getCurrentCombination();\r\n\r\n        if (sequenceMatch) {\r\n          var eventSchema = sequenceMatch.events[keyEventType];\r\n\r\n          if (Configuration.option('allowCombinationSubmatches')) {\r\n            var subMatchDescription = KeyCombinationSerializer.serialize(sequenceMatch.keyDictionary);\r\n            this.logger.debug(this._logPrefix(componentSearchIndex), \"Found action that matches '\".concat(currentCombination.describe(), \"' (sub-match: '\").concat(subMatchDescription, \"'): \").concat(eventSchema.actionName, \". Calling handler . . .\"));\r\n          } else {\r\n            this.logger.debug(this._logPrefix(componentSearchIndex), \"Found action that matches '\".concat(currentCombination.describe(), \"': \").concat(eventSchema.actionName, \". Calling handler . . .\"));\r\n          }\r\n\r\n          eventSchema.handler(event);\r\n\r\n          this._stopEventPropagationAfterHandlingIfEnabled(event, componentSearchIndex);\r\n\r\n          return true;\r\n        } else {\r\n          if (this._actionResolver.componentHasActionsBoundToEventType(componentSearchIndex, keyEventType)) {\r\n            var eventName = describeKeyEventType(keyEventType);\r\n            this.logger.debug(this._logPrefix(componentSearchIndex), \"No matching actions found for '\".concat(currentCombination.describe(), \"' \").concat(eventName, \".\"));\r\n          } else {\r\n            this.logger.debug(this._logPrefix(componentSearchIndex), \"Doesn't define a handler for '\".concat(currentCombination.describe(), \"' \").concat(describeKeyEventType(keyEventType), \".\"));\r\n          }\r\n        }\r\n\r\n        componentSearchIndex++;\r\n      }\r\n    }\r\n  }, {\r\n    key: \"_stopEventPropagationAfterHandlingIfEnabled\",\r\n    value: function _stopEventPropagationAfterHandlingIfEnabled(event, componentId) {\r\n      if (Configuration.option('stopEventPropagationAfterHandling')) {\r\n        this._stopEventPropagation(event, componentId);\r\n\r\n        return true;\r\n      }\r\n\r\n      return false;\r\n    }\r\n  }, {\r\n    key: \"_stopEventPropagation\",\r\n    value: function _stopEventPropagation(event, componentId) {\r\n      throw new Error('_stopEventPropagation must be overridden by a subclass');\r\n    }\r\n    /**\r\n     * Synchronises the key combination history to match the modifier key flag attributes\r\n     * on new key events\r\n     * @param {KeyboardEvent} event - Event to check the modifier flags for\r\n     * @param {string} key - Name of key that events relates to\r\n     * @param {KeyEventType} keyEventType - The record index of the current\r\n     *        key event type\r\n     * @protected\r\n     */\r\n\r\n  }, {\r\n    key: \"_checkForModifierFlagDiscrepancies\",\r\n    value: function _checkForModifierFlagDiscrepancies(event, key, keyEventType) {\r\n      var _this2 = this;\r\n\r\n      /**\r\n       * If a new key event is received with modifier key flags that contradict the\r\n       * key combination history we are maintaining, we can surmise that some keyup events\r\n       * for those modifier keys have been lost (possibly because the window lost focus).\r\n       * We update the key combination to match the modifier flags\r\n       */\r\n      Object.keys(ModifierFlagsDictionary).forEach(function (modifierKey) {\r\n        /**\r\n         * When a modifier key is being released (keyup), it sets its own modifier flag\r\n         * to false. (e.g. On the keyup event for Command, the metaKey attribute is false).\r\n         * If this the case, we want to handle it using the main algorithm and skip the\r\n         * reconciliation algorithm.\r\n         */\r\n        if (key === modifierKey && keyEventType === KeyEventType.keyup) {\r\n          return;\r\n        }\r\n\r\n        var currentCombination = _this2.getCurrentCombination();\r\n\r\n        var modifierStillPressed = currentCombination.isKeyStillPressed(modifierKey);\r\n        ModifierFlagsDictionary[modifierKey].forEach(function (attributeName) {\r\n          if (event[attributeName] === false && modifierStillPressed) {\r\n            currentCombination.setKeyState(modifierKey, KeyEventType.keyup, stateFromEvent(event));\r\n          }\r\n        });\r\n      });\r\n    }\r\n    /**\r\n     * Returns a prefix for all log entries related to the current event strategy\r\n     * @protected\r\n     * @abstract\r\n     */\r\n\r\n  }, {\r\n    key: \"_logPrefix\",\r\n    value: function _logPrefix() {}\r\n  }]);\r\n\r\n  return AbstractKeyEventStrategy;\r\n}();\r\n\r\nexport default AbstractKeyEventStrategy;"]},"metadata":{},"sourceType":"module"}