{"ast":null,"code":"function _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _get(target, property, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get(target, property, receiver || target);\n}\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nimport AbstractKeyEventStrategy from './AbstractKeyEventStrategy';\nimport KeyEventType from '../../const/KeyEventType';\nimport KeyEventCounter from '../listening/KeyEventCounter';\nimport describeKeyEventType from '../../helpers/logging/describeKeyEventType';\nimport Configuration from '../config/Configuration';\nimport Logger from '../logging/Logger';\nimport printComponent from '../../helpers/logging/printComponent';\nimport isUndefined from '../../utils/isUndefined';\nimport getKeyName from '../../helpers/resolving-handlers/getKeyName';\nimport isCmdKey from '../../helpers/parsing-key-maps/isCmdKey';\nimport describeKeyEvent from '../../helpers/logging/describeKeyEvent';\nimport EventResponse from '../../const/EventResponse';\nimport KeyEventState from '../../const/KeyEventState';\nimport stateFromEvent from '../../helpers/parsing-key-maps/stateFromEvent';\nimport EventPropagator from '../listening/EventPropagator';\n/**\r\n * Defines behaviour for dealing with key maps defined in focus-only HotKey components\r\n * @class\r\n */\n\nvar FocusOnlyKeyEventStrategy = /*#__PURE__*/function (_AbstractKeyEventStra) {\n  _inherits(FocusOnlyKeyEventStrategy, _AbstractKeyEventStra);\n  /********************************************************************************\r\n   * Init & Reset\r\n   ********************************************************************************/\n\n\n  function FocusOnlyKeyEventStrategy() {\n    var _this;\n\n    var configuration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var keyEventManager = arguments.length > 1 ? arguments[1] : undefined;\n\n    _classCallCheck(this, FocusOnlyKeyEventStrategy);\n    /**\r\n     * Set state that DOES get cleared on each new focus tree\r\n     */\n\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(FocusOnlyKeyEventStrategy).call(this, configuration, keyEventManager));\n    /**\r\n     * State that doesn't get cleared on each new focus tree\r\n     */\n\n    /**\r\n     * Unique identifier given to each focus tree - when the focus in the browser\r\n     * changes, and a different tree of elements are focused, a new id is allocated\r\n     * @typedef {number} FocusTreeId\r\n     */\n\n    /**\r\n     * Counter to keep track of what focus tree ID should be allocated next\r\n     * @type {FocusTreeId}\r\n     */\n\n    _this.focusTreeId = 0;\n    return _this;\n  }\n  /**\r\n   * Clears the internal state, wiping any history of key events and registered handlers\r\n   * so they have no effect on the next tree of focused HotKeys components\r\n   * @private\r\n   */\n\n\n  _createClass(FocusOnlyKeyEventStrategy, [{\n    key: \"_reset\",\n    value: function _reset() {\n      _get(_getPrototypeOf(FocusOnlyKeyEventStrategy.prototype), \"_reset\", this).call(this);\n\n      this.keypressEventsToSimulate = [];\n      /**\r\n       * Increase the unique ID associated with each unique focus tree\r\n       * @type {number}\r\n       */\n\n      this.focusTreeId += 1;\n      this.eventPropagator = new EventPropagator(this.componentList, {\n        logger: this.logger,\n        logPrefix: this._logPrefix.bind(this)\n      });\n    }\n    /********************************************************************************\r\n     * Registering key maps and handlers\r\n     ********************************************************************************/\n\n    /**\r\n     * Registers the actions and handlers of a HotKeys component that has gained focus\r\n     * @param {ComponentId} componentId - Id of the component that the keyMap belongs to\r\n     * @param {KeyMap} actionNameToKeyMap - Map of actions to key expressions\r\n     * @param {HandlersMap} actionNameToHandlersMap - Map of actions to handler functions\r\n     * @param {Object} options Hash of options that configure how the actions\r\n     *        and handlers are associated and called.\r\n     * @returns {FocusTreeId|undefined} The current focus tree's ID or undefined if the\r\n     *        the <tt>componentId</tt> has already been registered (shouldn't normally\r\n     *        occur).\r\n     */\n\n  }, {\n    key: \"enableHotKeys\",\n    value: function enableHotKeys(componentId) {\n      var actionNameToKeyMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var actionNameToHandlersMap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var options = arguments.length > 3 ? arguments[3] : undefined;\n\n      if (this.resetOnNextFocus) {\n        /**\r\n         * We know components have just lost focus or keymaps have already been built,\r\n         * meaning we are either anticipating a new set of components to be focused or\r\n         * we are receiving notice of a component being focused when we aren't expecting it.\r\n         * In either case, the internal state needs to be reset.\r\n         */\n        this._reset();\n\n        this.resetOnNextFocus = false;\n      }\n\n      if (this.componentList.containsId(componentId)) {\n        /**\r\n         * The <tt>componentId</tt> has already been registered - this occurs when the\r\n         * same component has somehow managed to be focused twice, without being blurred\r\n         * in between.\r\n         *\r\n         * @see https://github.com/greena13/react-hotkeys/issues/173\r\n         */\n        return undefined;\n      }\n\n      this._addComponent(componentId, actionNameToKeyMap, actionNameToHandlersMap, options);\n\n      this.logger.debug(this._logPrefix(componentId, {\n        eventId: false\n      }), 'Focused. \\n');\n      this.logger.verbose(this._logPrefix(componentId, {\n        eventId: false\n      }), 'Component options:\\n', printComponent(this.componentList.get(componentId)));\n      return this.focusTreeId;\n    }\n    /**\r\n     * Handles when a HotKeys component that is in focus updates its props and changes\r\n     * either the keyMap or handlers prop value\r\n     * @param {FocusTreeId} focusTreeId - The ID of the focus tree the component is part of.\r\n     *        Used to identify (and ignore) stale updates.\r\n     * @param {ComponentId} componentId - The component index of the component to\r\n     *        update\r\n     * @param {KeyMap} actionNameToKeyMap - Map of key sequences to action names\r\n     * @param {HandlersMap} actionNameToHandlersMap - Map of action names to handler\r\n     *        functions\r\n     * @param {Object} options Hash of options that configure how the actions\r\n     *        and handlers are associated and called.\r\n     */\n\n  }, {\n    key: \"updateEnabledHotKeys\",\n    value: function updateEnabledHotKeys(focusTreeId, componentId) {\n      var actionNameToKeyMap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var actionNameToHandlersMap = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      var options = arguments.length > 4 ? arguments[4] : undefined;\n\n      if (focusTreeId !== this.focusTreeId || !this.componentList.containsId(componentId)) {\n        return;\n      }\n\n      this.componentList.update(componentId, actionNameToKeyMap, actionNameToHandlersMap, options);\n      this.getKeyHistory().setMaxLength(this.componentList.getLongestSequence());\n      this.logger.debug(this._logPrefix(componentId, {\n        focusTreeId: focusTreeId,\n        eventId: false\n      }), 'Received new props.');\n      /**\r\n       * Reset handler resolution state\r\n       */\n\n      this._initHandlerResolutionState();\n\n      this.logger.verbose(this._logPrefix(componentId, {\n        focusTreeId: focusTreeId,\n        eventId: false\n      }), 'Component options:\\n', printComponent(this.componentList.get(componentId)));\n    }\n    /**\r\n     * Handles when a component loses focus by resetting the internal state, ready to\r\n     * receive the next tree of focused HotKeys components\r\n     * @param {FocusTreeId} focusTreeId - Id of focus tree component thinks it's\r\n     *        apart of\r\n     * @param {ComponentId} componentId - Index of component that is blurring\r\n     * @returns {boolean} Whether the component still has event propagation yet to handle\r\n     */\n\n  }, {\n    key: \"disableHotKeys\",\n    value: function disableHotKeys(focusTreeId, componentId) {\n      if (!this.resetOnNextFocus) {\n        this.resetOnNextFocus = true;\n      }\n\n      var outstandingEventPropagation = this.eventPropagator.isPendingPropagation();\n      this.logger.debug(\"\".concat(this._logPrefix(componentId, {\n        focusTreeId: focusTreeId,\n        eventId: false\n      })), \"Lost focus\".concat(outstandingEventPropagation ? ' (Key event has yet to propagate through it)' : '', \".\"));\n      return outstandingEventPropagation;\n    }\n    /********************************************************************************\r\n     * Recording key events\r\n     ********************************************************************************/\n\n    /**\r\n     * @typedef {KeyboardEvent} SyntheticKeyboardEvent\r\n     * @property {function} persist\r\n     */\n\n    /**\r\n     * Records a keydown keyboard event and matches it against the list of pre-registered\r\n     * event handlers, calling the first matching handler with the highest priority if\r\n     * one exists.\r\n     *\r\n     * This method is called many times as a keyboard event bubbles up through the React\r\n     * render tree. The event is only registered the first time it is seen and results\r\n     * of some calculations are cached. The event is matched against the handlers registered\r\n     * at each component level, to ensure the proper handler declaration scoping.\r\n     * @param {SyntheticKeyboardEvent} event - Event containing the key name and state\r\n     * @param {FocusTreeId} focusTreeId - Id of focus tree component thinks it's apart of\r\n     * @param {ComponentId} componentId - The id of the component that is currently handling\r\n     *        the keyboard event as it bubbles towards the document root.\r\n     * @param {Object} options - Hash of options that configure how the event is handled.\r\n     * @returns Whether the event was discarded because it was part of an old focus tree\r\n     */\n\n  }, {\n    key: \"handleKeydown\",\n    value: function handleKeydown(event, focusTreeId, componentId) {\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      var key = getKeyName(event);\n\n      if (focusTreeId !== this.focusTreeId) {\n        this.logger.debug(this._logPrefix(componentId), \"Ignored \".concat(describeKeyEvent(event, key, KeyEventType.keydown), \" event because it had an old focus tree id: \").concat(focusTreeId, \".\"));\n        this.eventPropagator.ignoreEvent(event);\n        return true;\n      }\n\n      var started = this.eventPropagator.startNewPropagationStep(componentId, event, key, KeyEventType.keydown);\n\n      if (!started) {\n        return;\n      }\n\n      var responseAction = this._howToHandleKeyEvent(event, focusTreeId, componentId, key, options, KeyEventType.keydown);\n\n      if (responseAction === EventResponse.handled) {\n        var keyEventState = stateFromEvent(event);\n        var currentCombination = this.getCurrentCombination();\n\n        if (currentCombination.isKeyIncluded(key) || currentCombination.isEnding()) {\n          this._startAndLogNewKeyCombination(key, focusTreeId, componentId, keyEventState);\n        } else {\n          this._addToAndLogCurrentKeyCombination(key, KeyEventType.keydown, focusTreeId, componentId, keyEventState);\n        }\n\n        this._callHandlerIfActionNotHandled(event, key, KeyEventType.keydown, componentId, focusTreeId);\n      }\n\n      this._simulateKeyPressForNonPrintableKeys(event, key, focusTreeId, componentId, options);\n\n      this.eventPropagator.finishPropagationStep();\n      return false;\n    }\n  }, {\n    key: \"_howToHandleKeyEvent\",\n    value: function _howToHandleKeyEvent(event, focusTreeId, componentId, key, options, keyEventType) {\n      if (this.eventPropagator.isFirstPropagationStep()) {\n        if (options.ignoreEventsCondition(event) && this.eventPropagator.ignoreEvent(event)) {\n          return this._eventIsToBeIgnored(event, componentId, key, keyEventType);\n        }\n\n        this.logger.debug(this._logPrefix(componentId), \"New \".concat(describeKeyEvent(event, key, keyEventType), \" event.\"));\n\n        this._checkForModifierFlagDiscrepancies(event, key, keyEventType);\n      } else if (this.eventPropagator.isIgnoringEvent()) {\n        return this._eventIsToBeIgnored(event, componentId, key, keyEventType);\n      }\n\n      return EventResponse.handled;\n    }\n  }, {\n    key: \"_eventIsToBeIgnored\",\n    value: function _eventIsToBeIgnored(event, componentId, key, keyEventType) {\n      this.logger.debug(this._logPrefix(componentId), \"Ignored \".concat(describeKeyEvent(event, key, keyEventType), \" event because ignoreEventsFilter rejected it.\"));\n      return EventResponse.ignored;\n    }\n    /**\r\n     * Records a keypress keyboard event and matches it against the list of pre-registered\r\n     * event handlers, calling the first matching handler with the highest priority if\r\n     * one exists.\r\n     *\r\n     * This method is called many times as a keyboard event bubbles up through the React\r\n     * render tree. The event is only registered the first time it is seen and results\r\n     * of some calculations are cached. The event is matched against the handlers registered\r\n     * at each component level, to ensure the proper handler declaration scoping.\r\n     * @param {KeyboardEvent} event - Event containing the key name and state\r\n     * @param {FocusTreeId} focusTreeId Id - of focus tree component thinks it's apart of\r\n     * @param {ComponentId} componentId - The index of the component that is currently handling\r\n     *        the keyboard event as it bubbles towards the document root.\r\n     * @param {Object} options - Hash of options that configure how the event\r\n     *        is handled.\r\n     * @returns {boolean} Whether the HotKeys component should discard its current focus\r\n     *        tree Id, because it belongs to an old focus tree.\r\n     */\n\n  }, {\n    key: \"handleKeyPress\",\n    value: function handleKeyPress(event, focusTreeId, componentId, options) {\n      var key = getKeyName(event);\n      var currentCombination = this.getCurrentCombination();\n\n      if (currentCombination.isKeyPressSimulated(key)) {\n        this.logger.debug(this._logPrefix(componentId), \"Ignored \".concat(describeKeyEvent(event, key, KeyEventType.keypress), \" as it was not expected, and has already been simulated.\"));\n        this.eventPropagator.ignoreEvent(event);\n        return true;\n      }\n\n      var started = this.eventPropagator.startNewPropagationStep(componentId, event, key, KeyEventType.keypress);\n\n      if (!started) {\n        return;\n      }\n\n      var shouldDiscardFocusTreeId = focusTreeId !== this.focusTreeId;\n      /**\r\n       * We first decide if the keypress event should be handled (to ensure the correct\r\n       * order of logging statements)\r\n       */\n\n      var responseAction = this._howToHandleKeyEvent(event, focusTreeId, componentId, key, options, KeyEventType.keypress);\n\n      if (this.eventPropagator.isFirstPropagationStep(componentId) && currentCombination.isKeyIncluded(key)) {\n        this._addToAndLogCurrentKeyCombination(key, KeyEventType.keypress, focusTreeId, componentId, stateFromEvent(event));\n      }\n      /**\r\n       * We attempt to find a handler of the event, only if it has not already\r\n       * been handled and should not be ignored\r\n       */\n\n\n      if (responseAction === EventResponse.handled) {\n        this._callHandlerIfActionNotHandled(event, key, KeyEventType.keypress, componentId, focusTreeId);\n      }\n\n      this.eventPropagator.finishPropagationStep();\n      return shouldDiscardFocusTreeId;\n    }\n    /**\r\n     * Records a keyup keyboard event and matches it against the list of pre-registered\r\n     * event handlers, calling the first matching handler with the highest priority if\r\n     * one exists.\r\n     *\r\n     * This method is called many times as a keyboard event bubbles up through the React\r\n     * render tree. The event is only registered the first time it is seen and results\r\n     * of some calculations are cached. The event is matched against the handlers registered\r\n     * at each component level, to ensure the proper handler declaration scoping.\r\n     * @param {KeyboardEvent} event Event containing the key name and state\r\n     * @param {FocusTreeId} focusTreeId Id of focus tree component thinks it's apart of\r\n     * @param {ComponentId} componentId The index of the component that is currently handling\r\n     *        the keyboard event as it bubbles towards the document root.\r\n     * @param {Object} options Hash of options that configure how the event\r\n     *        is handled.\r\n     * @returns {boolean} Whether HotKeys component should discard its current focusTreeId\r\n     *        because it's stale (part of an old focus tree)\r\n     */\n\n  }, {\n    key: \"handleKeyUp\",\n    value: function handleKeyUp(event, focusTreeId, componentId, options) {\n      var key = getKeyName(event);\n      var currentCombination = this.getCurrentCombination();\n\n      if (currentCombination.isKeyUpSimulated(key)) {\n        this.logger.debug(this._logPrefix(componentId), \"Ignored \".concat(describeKeyEvent(event, key, KeyEventType.keyup), \" as it was not expected, and has already been simulated.\"));\n        this.eventPropagator.ignoreEvent(event);\n        return true;\n      }\n\n      var started = this.eventPropagator.startNewPropagationStep(componentId, event, key, KeyEventType.keyup);\n\n      if (!started) {\n        return;\n      }\n\n      var shouldDiscardFocusId = focusTreeId !== this.focusTreeId;\n      /**\r\n       * We first decide if the keyup event should be handled (to ensure the correct\r\n       * order of logging statements)\r\n       */\n\n      var responseAction = this._howToHandleKeyEvent(event, focusTreeId, componentId, key, options, KeyEventType.keyup);\n      /**\r\n       * We then add the keyup to our current combination - regardless of whether\r\n       * it's to be handled or not. We need to do this to ensure that if a handler\r\n       * function changes focus to a context that ignored events, the keyup event\r\n       * is not lost (leaving react hotkeys thinking the key is still pressed).\r\n       */\n\n\n      if (this.eventPropagator.isFirstPropagationStep(componentId) && currentCombination.isKeyIncluded(key)) {\n        this._addToAndLogCurrentKeyCombination(key, KeyEventType.keyup, focusTreeId, componentId, stateFromEvent(event));\n      }\n      /**\r\n       * We attempt to find a handler of the event, only if it has not already\r\n       * been handled and should not be ignored\r\n       */\n\n\n      if (responseAction === EventResponse.handled) {\n        this._callHandlerIfActionNotHandled(event, key, KeyEventType.keyup, componentId, focusTreeId);\n      }\n      /**\r\n       * We simulate any hidden keyup events hidden by the command key, regardless\r\n       * of whether the event should be ignored or not\r\n       */\n\n\n      this._simulateKeyUpEventsHiddenByCmd(event, key, focusTreeId, componentId, options);\n\n      this.eventPropagator.finishPropagationStep();\n      return shouldDiscardFocusId;\n    }\n    /**\r\n     * Closes any hanging key combinations that have not received the key event indicated\r\n     * by recordIndex.\r\n     * @param {KeyName} keyName The name of the key whose state should be updated if it\r\n     *        is currently set to keydown or keypress.\r\n     * @param {KeyEventType} recordIndex Index of key event to move the key state\r\n     *        up to.\r\n     */\n\n  }, {\n    key: \"closeHangingKeyCombination\",\n    value: function closeHangingKeyCombination(keyName, recordIndex) {\n      var currentCombination = this.getCurrentCombination();\n\n      if (currentCombination.isKeyIncluded(keyName) && !currentCombination.isEventTriggered(keyName, recordIndex)) {\n        /**\r\n         * If the key is in the current combination and recorded as still being pressed\r\n         * down (as either keydown or keypress), then we update the state\r\n         * to keypress or keyup (depending on the value of recordIndex).\r\n         */\n        currentCombination.setKeyState(keyName, recordIndex, KeyEventState.simulated);\n      }\n    }\n  }, {\n    key: \"_simulateKeyPressForNonPrintableKeys\",\n    value: function _simulateKeyPressForNonPrintableKeys(event, key, focusTreeId, componentId, options) {\n      this._handleEventSimulation('keypressEventsToSimulate', 'simulatePendingKeyPressEvents', this._shouldSimulate(KeyEventType.keypress, key), {\n        event: event,\n        key: key,\n        focusTreeId: focusTreeId,\n        componentId: componentId,\n        options: options\n      });\n    }\n  }, {\n    key: \"_simulateKeyUpEventsHiddenByCmd\",\n    value: function _simulateKeyUpEventsHiddenByCmd(event, key, focusTreeId, componentId, options) {\n      var _this2 = this;\n\n      if (isCmdKey(key)) {\n        this.getCurrentCombination().forEachKey(function (keyName) {\n          if (isCmdKey(keyName)) {\n            return;\n          }\n\n          _this2._handleEventSimulation('keyupEventsToSimulate', 'simulatePendingKeyUpEvents', _this2._shouldSimulate(KeyEventType.keyup, keyName), {\n            event: event,\n            key: keyName,\n            focusTreeId: focusTreeId,\n            componentId: componentId,\n            options: options\n          });\n        });\n      }\n    }\n  }, {\n    key: \"_stopEventPropagation\",\n    value: function _stopEventPropagation(event, componentId) {\n      if (this.eventPropagator.stop(event)) {\n        this.logger.debug(this._logPrefix(componentId), 'Stopping further event propagation.');\n      }\n    }\n  }, {\n    key: \"getEventPropagator\",\n    value: function getEventPropagator() {\n      return this.eventPropagator;\n    }\n  }, {\n    key: \"_startAndLogNewKeyCombination\",\n    value: function _startAndLogNewKeyCombination(keyName, focusTreeId, componentId, keyEventState) {\n      this.getKeyHistory().startNewKeyCombination(keyName, keyEventState);\n      this.logger.verbose(this._logPrefix(componentId, {\n        focusTreeId: focusTreeId\n      }), \"Started a new combination with '\".concat(keyName, \"'.\"));\n      this.logger.verbose(this._logPrefix(componentId, {\n        focusTreeId: focusTreeId\n      }), \"Key history: \".concat(printComponent(this.getKeyHistory().toJSON()), \".\"));\n    }\n  }, {\n    key: \"_addToAndLogCurrentKeyCombination\",\n    value: function _addToAndLogCurrentKeyCombination(keyName, keyEventType, focusTreeId, componentId, keyEventState) {\n      this.getKeyHistory().addKeyToCurrentCombination(keyName, keyEventType, keyEventState);\n\n      if (keyEventType === KeyEventType.keydown) {\n        this.logger.verbose(this._logPrefix(componentId, {\n          focusTreeId: focusTreeId\n        }), \"Added '\".concat(keyName, \"' to current combination: '\").concat(this.getCurrentCombination().describe(), \"'.\"));\n      }\n\n      this.logger.verbose(this._logPrefix(componentId, {\n        focusTreeId: focusTreeId\n      }), \"Key history: \".concat(printComponent(this.getKeyHistory().toJSON()), \".\"));\n    }\n    /********************************************************************************\r\n     * Event simulation\r\n     ********************************************************************************/\n\n  }, {\n    key: \"_handleEventSimulation\",\n    value: function _handleEventSimulation(listName, handlerName, shouldSimulate, _ref) {\n      var event = _ref.event,\n          key = _ref.key,\n          focusTreeId = _ref.focusTreeId,\n          componentId = _ref.componentId,\n          options = _ref.options;\n\n      if (shouldSimulate && Configuration.option('simulateMissingKeyPressEvents')) {\n        /**\r\n         * If a key does not have a keypress event, we save the details of the keydown\r\n         * event to simulate the keypress event, as the keydown event bubbles through\r\n         * the last focus-only HotKeysComponent\r\n         */\n        var _event = this._cloneAndMergeEvent(event, {\n          key: key,\n          simulated: true\n        });\n\n        this[listName].push({\n          event: _event,\n          focusTreeId: focusTreeId,\n          componentId: componentId,\n          options: options\n        });\n      }\n\n      if (this.componentList.isRoot(componentId) || this.eventPropagator.isStopped()) {\n        if (!this.keyEventManager.isGlobalListenersBound()) {\n          this[handlerName]();\n        }\n        /**\r\n         * else, we wait for keydown event to propagate through global strategy\r\n         * before we simulate the keypress\r\n         */\n\n      }\n    }\n  }, {\n    key: \"simulatePendingKeyPressEvents\",\n    value: function simulatePendingKeyPressEvents() {\n      this._simulatePendingKeyEvents('keypressEventsToSimulate', 'handleKeyPress');\n    }\n  }, {\n    key: \"simulatePendingKeyUpEvents\",\n    value: function simulatePendingKeyUpEvents() {\n      this._simulatePendingKeyEvents('keyupEventsToSimulate', 'handleKeyUp');\n    }\n  }, {\n    key: \"_simulatePendingKeyEvents\",\n    value: function _simulatePendingKeyEvents(listName, handlerName) {\n      var _this3 = this;\n\n      if (this[listName].length > 0) {\n        KeyEventCounter.incrementId();\n      }\n\n      this[listName].forEach(function (_ref2) {\n        var event = _ref2.event,\n            focusTreeId = _ref2.focusTreeId,\n            componentId = _ref2.componentId,\n            options = _ref2.options;\n\n        _this3[handlerName](event, focusTreeId, componentId, options);\n      });\n      this[listName] = [];\n    }\n    /********************************************************************************\r\n     * Matching and calling handlers\r\n     ********************************************************************************/\n\n    /**\r\n     * Calls the first handler that matches the current key event if the action has not\r\n     * already been handled in a more deeply nested component\r\n     * @param {KeyboardEvent} event Keyboard event object to be passed to the handler\r\n     * @param {NormalizedKeyName} keyName Normalized key name\r\n     * @param {KeyEventType} keyEventType The record index of the current key event type\r\n     * @param {FocusTreeId} focusTreeId Id of focus tree component thinks it's apart of\r\n     * @param {ComponentId} componentId Index of the component that is currently handling\r\n     *        the keyboard event\r\n     * @private\r\n     */\n\n  }, {\n    key: \"_callHandlerIfActionNotHandled\",\n    value: function _callHandlerIfActionNotHandled(event, keyName, keyEventType, componentId, focusTreeId) {\n      var eventName = describeKeyEventType(keyEventType);\n      var combinationName = this.getCurrentCombination().describe();\n\n      if (!this.componentList.anyActionsForEventType(keyEventType)) {\n        this.logger.verbose(this._logPrefix(componentId, {\n          focusTreeId: focusTreeId\n        }), \"Ignored '\".concat(combinationName, \"' \").concat(eventName, \" because it doesn't have any \").concat(eventName, \" handlers.\"));\n        return;\n      }\n\n      if (this.eventPropagator.isHandled()) {\n        this.logger.debug(this._logPrefix(componentId, {\n          focusTreeId: focusTreeId\n        }), \"Ignored '\".concat(combinationName, \"' \").concat(eventName, \" as it has already been handled.\"));\n      } else {\n        this.logger.verbose(this._logPrefix(componentId, {\n          focusTreeId: focusTreeId\n        }), \"Attempting to find action matching '\".concat(combinationName, \"' \").concat(eventName, \" . . .\"));\n        var previousComponentPosition = this.eventPropagator.getPreviousPosition();\n        var componentPosition = this.componentList.getIndexById(componentId);\n\n        var handlerWasCalled = this._callClosestMatchingHandler(event, keyName, keyEventType, componentPosition, previousComponentPosition === -1 ? 0 : previousComponentPosition);\n\n        if (handlerWasCalled) {\n          this.eventPropagator.setHandled();\n        }\n      }\n    }\n    /********************************************************************************\r\n     * Logging\r\n     ********************************************************************************/\n\n  }, {\n    key: \"_logPrefix\",\n    value: function _logPrefix(componentId) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var logIcons = Logger.logIcons;\n      var eventIcons = Logger.eventIcons;\n      var componentIcons = Logger.componentIcons;\n      var base = 'HotKeys (';\n\n      if (options.focusTreeId !== false) {\n        var focusTreeId = isUndefined(options.focusTreeId) ? this.focusTreeId : options.focusTreeId;\n        base += \"F\".concat(focusTreeId).concat(logIcons[focusTreeId % logIcons.length], \"-\");\n      }\n\n      if (options.eventId !== false) {\n        var eventId = isUndefined(options.eventId) ? KeyEventCounter.getId() : options.eventId;\n        base += \"E\".concat(eventId).concat(eventIcons[eventId % eventIcons.length], \"-\");\n      }\n\n      base += \"C\".concat(componentId).concat(componentIcons[componentId % componentIcons.length]);\n      var position = this.componentList.getIndexById(componentId);\n\n      if (!isUndefined(position)) {\n        base += \"-P\".concat(position).concat(componentIcons[position % componentIcons.length], \":\");\n      }\n\n      return \"\".concat(base, \")\");\n    }\n  }]);\n\n  return FocusOnlyKeyEventStrategy;\n}(AbstractKeyEventStrategy);\n\nexport default FocusOnlyKeyEventStrategy;","map":{"version":3,"sources":["D:/GitHub/ML4GIS/client/node_modules/react-hotkeys/es/lib/strategies/FocusOnlyKeyEventStrategy.js"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","_possibleConstructorReturn","self","call","_assertThisInitialized","ReferenceError","_get","property","receiver","Reflect","get","base","_superPropBase","desc","getOwnPropertyDescriptor","value","object","hasOwnProperty","_getPrototypeOf","o","setPrototypeOf","getPrototypeOf","__proto__","_inherits","subClass","superClass","create","_setPrototypeOf","p","AbstractKeyEventStrategy","KeyEventType","KeyEventCounter","describeKeyEventType","Configuration","Logger","printComponent","isUndefined","getKeyName","isCmdKey","describeKeyEvent","EventResponse","KeyEventState","stateFromEvent","EventPropagator","FocusOnlyKeyEventStrategy","_AbstractKeyEventStra","_this","configuration","arguments","undefined","keyEventManager","focusTreeId","_reset","keypressEventsToSimulate","eventPropagator","componentList","logger","logPrefix","_logPrefix","bind","enableHotKeys","componentId","actionNameToKeyMap","actionNameToHandlersMap","options","resetOnNextFocus","containsId","_addComponent","debug","eventId","verbose","updateEnabledHotKeys","update","getKeyHistory","setMaxLength","getLongestSequence","_initHandlerResolutionState","disableHotKeys","outstandingEventPropagation","isPendingPropagation","concat","handleKeydown","event","keydown","ignoreEvent","started","startNewPropagationStep","responseAction","_howToHandleKeyEvent","handled","keyEventState","currentCombination","getCurrentCombination","isKeyIncluded","isEnding","_startAndLogNewKeyCombination","_addToAndLogCurrentKeyCombination","_callHandlerIfActionNotHandled","_simulateKeyPressForNonPrintableKeys","finishPropagationStep","keyEventType","isFirstPropagationStep","ignoreEventsCondition","_eventIsToBeIgnored","_checkForModifierFlagDiscrepancies","isIgnoringEvent","ignored","handleKeyPress","isKeyPressSimulated","keypress","shouldDiscardFocusTreeId","handleKeyUp","isKeyUpSimulated","keyup","shouldDiscardFocusId","_simulateKeyUpEventsHiddenByCmd","closeHangingKeyCombination","keyName","recordIndex","isEventTriggered","setKeyState","simulated","_handleEventSimulation","_shouldSimulate","_this2","forEachKey","_stopEventPropagation","stop","getEventPropagator","startNewKeyCombination","toJSON","addKeyToCurrentCombination","describe","listName","handlerName","shouldSimulate","_ref","option","_event","_cloneAndMergeEvent","push","isRoot","isStopped","isGlobalListenersBound","simulatePendingKeyPressEvents","_simulatePendingKeyEvents","simulatePendingKeyUpEvents","_this3","incrementId","forEach","_ref2","eventName","combinationName","anyActionsForEventType","isHandled","previousComponentPosition","getPreviousPosition","componentPosition","getIndexById","handlerWasCalled","_callClosestMatchingHandler","setHandled","logIcons","eventIcons","componentIcons","getId","position"],"mappings":"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","sourcesContent":["function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\r\n\r\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\r\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\r\n\r\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\r\n\r\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\r\n\r\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\r\n\r\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\r\n\r\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\r\n\r\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\r\n\r\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\r\n\r\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\r\n\r\nimport AbstractKeyEventStrategy from './AbstractKeyEventStrategy';\r\nimport KeyEventType from '../../const/KeyEventType';\r\nimport KeyEventCounter from '../listening/KeyEventCounter';\r\nimport describeKeyEventType from '../../helpers/logging/describeKeyEventType';\r\nimport Configuration from '../config/Configuration';\r\nimport Logger from '../logging/Logger';\r\nimport printComponent from '../../helpers/logging/printComponent';\r\nimport isUndefined from '../../utils/isUndefined';\r\nimport getKeyName from '../../helpers/resolving-handlers/getKeyName';\r\nimport isCmdKey from '../../helpers/parsing-key-maps/isCmdKey';\r\nimport describeKeyEvent from '../../helpers/logging/describeKeyEvent';\r\nimport EventResponse from '../../const/EventResponse';\r\nimport KeyEventState from '../../const/KeyEventState';\r\nimport stateFromEvent from '../../helpers/parsing-key-maps/stateFromEvent';\r\nimport EventPropagator from '../listening/EventPropagator';\r\n/**\r\n * Defines behaviour for dealing with key maps defined in focus-only HotKey components\r\n * @class\r\n */\r\n\r\nvar FocusOnlyKeyEventStrategy =\r\n/*#__PURE__*/\r\nfunction (_AbstractKeyEventStra) {\r\n  _inherits(FocusOnlyKeyEventStrategy, _AbstractKeyEventStra);\r\n\r\n  /********************************************************************************\r\n   * Init & Reset\r\n   ********************************************************************************/\r\n  function FocusOnlyKeyEventStrategy() {\r\n    var _this;\r\n\r\n    var configuration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\r\n    var keyEventManager = arguments.length > 1 ? arguments[1] : undefined;\r\n\r\n    _classCallCheck(this, FocusOnlyKeyEventStrategy);\r\n\r\n    /**\r\n     * Set state that DOES get cleared on each new focus tree\r\n     */\r\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(FocusOnlyKeyEventStrategy).call(this, configuration, keyEventManager));\r\n    /**\r\n     * State that doesn't get cleared on each new focus tree\r\n     */\r\n\r\n    /**\r\n     * Unique identifier given to each focus tree - when the focus in the browser\r\n     * changes, and a different tree of elements are focused, a new id is allocated\r\n     * @typedef {number} FocusTreeId\r\n     */\r\n\r\n    /**\r\n     * Counter to keep track of what focus tree ID should be allocated next\r\n     * @type {FocusTreeId}\r\n     */\r\n\r\n    _this.focusTreeId = 0;\r\n    return _this;\r\n  }\r\n  /**\r\n   * Clears the internal state, wiping any history of key events and registered handlers\r\n   * so they have no effect on the next tree of focused HotKeys components\r\n   * @private\r\n   */\r\n\r\n\r\n  _createClass(FocusOnlyKeyEventStrategy, [{\r\n    key: \"_reset\",\r\n    value: function _reset() {\r\n      _get(_getPrototypeOf(FocusOnlyKeyEventStrategy.prototype), \"_reset\", this).call(this);\r\n\r\n      this.keypressEventsToSimulate = [];\r\n      /**\r\n       * Increase the unique ID associated with each unique focus tree\r\n       * @type {number}\r\n       */\r\n\r\n      this.focusTreeId += 1;\r\n      this.eventPropagator = new EventPropagator(this.componentList, {\r\n        logger: this.logger,\r\n        logPrefix: this._logPrefix.bind(this)\r\n      });\r\n    }\r\n    /********************************************************************************\r\n     * Registering key maps and handlers\r\n     ********************************************************************************/\r\n\r\n    /**\r\n     * Registers the actions and handlers of a HotKeys component that has gained focus\r\n     * @param {ComponentId} componentId - Id of the component that the keyMap belongs to\r\n     * @param {KeyMap} actionNameToKeyMap - Map of actions to key expressions\r\n     * @param {HandlersMap} actionNameToHandlersMap - Map of actions to handler functions\r\n     * @param {Object} options Hash of options that configure how the actions\r\n     *        and handlers are associated and called.\r\n     * @returns {FocusTreeId|undefined} The current focus tree's ID or undefined if the\r\n     *        the <tt>componentId</tt> has already been registered (shouldn't normally\r\n     *        occur).\r\n     */\r\n\r\n  }, {\r\n    key: \"enableHotKeys\",\r\n    value: function enableHotKeys(componentId) {\r\n      var actionNameToKeyMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\r\n      var actionNameToHandlersMap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\r\n      var options = arguments.length > 3 ? arguments[3] : undefined;\r\n\r\n      if (this.resetOnNextFocus) {\r\n        /**\r\n         * We know components have just lost focus or keymaps have already been built,\r\n         * meaning we are either anticipating a new set of components to be focused or\r\n         * we are receiving notice of a component being focused when we aren't expecting it.\r\n         * In either case, the internal state needs to be reset.\r\n         */\r\n        this._reset();\r\n\r\n        this.resetOnNextFocus = false;\r\n      }\r\n\r\n      if (this.componentList.containsId(componentId)) {\r\n        /**\r\n         * The <tt>componentId</tt> has already been registered - this occurs when the\r\n         * same component has somehow managed to be focused twice, without being blurred\r\n         * in between.\r\n         *\r\n         * @see https://github.com/greena13/react-hotkeys/issues/173\r\n         */\r\n        return undefined;\r\n      }\r\n\r\n      this._addComponent(componentId, actionNameToKeyMap, actionNameToHandlersMap, options);\r\n\r\n      this.logger.debug(this._logPrefix(componentId, {\r\n        eventId: false\r\n      }), 'Focused. \\n');\r\n      this.logger.verbose(this._logPrefix(componentId, {\r\n        eventId: false\r\n      }), 'Component options:\\n', printComponent(this.componentList.get(componentId)));\r\n      return this.focusTreeId;\r\n    }\r\n    /**\r\n     * Handles when a HotKeys component that is in focus updates its props and changes\r\n     * either the keyMap or handlers prop value\r\n     * @param {FocusTreeId} focusTreeId - The ID of the focus tree the component is part of.\r\n     *        Used to identify (and ignore) stale updates.\r\n     * @param {ComponentId} componentId - The component index of the component to\r\n     *        update\r\n     * @param {KeyMap} actionNameToKeyMap - Map of key sequences to action names\r\n     * @param {HandlersMap} actionNameToHandlersMap - Map of action names to handler\r\n     *        functions\r\n     * @param {Object} options Hash of options that configure how the actions\r\n     *        and handlers are associated and called.\r\n     */\r\n\r\n  }, {\r\n    key: \"updateEnabledHotKeys\",\r\n    value: function updateEnabledHotKeys(focusTreeId, componentId) {\r\n      var actionNameToKeyMap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\r\n      var actionNameToHandlersMap = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\r\n      var options = arguments.length > 4 ? arguments[4] : undefined;\r\n\r\n      if (focusTreeId !== this.focusTreeId || !this.componentList.containsId(componentId)) {\r\n        return;\r\n      }\r\n\r\n      this.componentList.update(componentId, actionNameToKeyMap, actionNameToHandlersMap, options);\r\n      this.getKeyHistory().setMaxLength(this.componentList.getLongestSequence());\r\n      this.logger.debug(this._logPrefix(componentId, {\r\n        focusTreeId: focusTreeId,\r\n        eventId: false\r\n      }), 'Received new props.');\r\n      /**\r\n       * Reset handler resolution state\r\n       */\r\n\r\n      this._initHandlerResolutionState();\r\n\r\n      this.logger.verbose(this._logPrefix(componentId, {\r\n        focusTreeId: focusTreeId,\r\n        eventId: false\r\n      }), 'Component options:\\n', printComponent(this.componentList.get(componentId)));\r\n    }\r\n    /**\r\n     * Handles when a component loses focus by resetting the internal state, ready to\r\n     * receive the next tree of focused HotKeys components\r\n     * @param {FocusTreeId} focusTreeId - Id of focus tree component thinks it's\r\n     *        apart of\r\n     * @param {ComponentId} componentId - Index of component that is blurring\r\n     * @returns {boolean} Whether the component still has event propagation yet to handle\r\n     */\r\n\r\n  }, {\r\n    key: \"disableHotKeys\",\r\n    value: function disableHotKeys(focusTreeId, componentId) {\r\n      if (!this.resetOnNextFocus) {\r\n        this.resetOnNextFocus = true;\r\n      }\r\n\r\n      var outstandingEventPropagation = this.eventPropagator.isPendingPropagation();\r\n      this.logger.debug(\"\".concat(this._logPrefix(componentId, {\r\n        focusTreeId: focusTreeId,\r\n        eventId: false\r\n      })), \"Lost focus\".concat(outstandingEventPropagation ? ' (Key event has yet to propagate through it)' : '', \".\"));\r\n      return outstandingEventPropagation;\r\n    }\r\n    /********************************************************************************\r\n     * Recording key events\r\n     ********************************************************************************/\r\n\r\n    /**\r\n     * @typedef {KeyboardEvent} SyntheticKeyboardEvent\r\n     * @property {function} persist\r\n     */\r\n\r\n    /**\r\n     * Records a keydown keyboard event and matches it against the list of pre-registered\r\n     * event handlers, calling the first matching handler with the highest priority if\r\n     * one exists.\r\n     *\r\n     * This method is called many times as a keyboard event bubbles up through the React\r\n     * render tree. The event is only registered the first time it is seen and results\r\n     * of some calculations are cached. The event is matched against the handlers registered\r\n     * at each component level, to ensure the proper handler declaration scoping.\r\n     * @param {SyntheticKeyboardEvent} event - Event containing the key name and state\r\n     * @param {FocusTreeId} focusTreeId - Id of focus tree component thinks it's apart of\r\n     * @param {ComponentId} componentId - The id of the component that is currently handling\r\n     *        the keyboard event as it bubbles towards the document root.\r\n     * @param {Object} options - Hash of options that configure how the event is handled.\r\n     * @returns Whether the event was discarded because it was part of an old focus tree\r\n     */\r\n\r\n  }, {\r\n    key: \"handleKeydown\",\r\n    value: function handleKeydown(event, focusTreeId, componentId) {\r\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\r\n      var key = getKeyName(event);\r\n\r\n      if (focusTreeId !== this.focusTreeId) {\r\n        this.logger.debug(this._logPrefix(componentId), \"Ignored \".concat(describeKeyEvent(event, key, KeyEventType.keydown), \" event because it had an old focus tree id: \").concat(focusTreeId, \".\"));\r\n        this.eventPropagator.ignoreEvent(event);\r\n        return true;\r\n      }\r\n\r\n      var started = this.eventPropagator.startNewPropagationStep(componentId, event, key, KeyEventType.keydown);\r\n\r\n      if (!started) {\r\n        return;\r\n      }\r\n\r\n      var responseAction = this._howToHandleKeyEvent(event, focusTreeId, componentId, key, options, KeyEventType.keydown);\r\n\r\n      if (responseAction === EventResponse.handled) {\r\n        var keyEventState = stateFromEvent(event);\r\n        var currentCombination = this.getCurrentCombination();\r\n\r\n        if (currentCombination.isKeyIncluded(key) || currentCombination.isEnding()) {\r\n          this._startAndLogNewKeyCombination(key, focusTreeId, componentId, keyEventState);\r\n        } else {\r\n          this._addToAndLogCurrentKeyCombination(key, KeyEventType.keydown, focusTreeId, componentId, keyEventState);\r\n        }\r\n\r\n        this._callHandlerIfActionNotHandled(event, key, KeyEventType.keydown, componentId, focusTreeId);\r\n      }\r\n\r\n      this._simulateKeyPressForNonPrintableKeys(event, key, focusTreeId, componentId, options);\r\n\r\n      this.eventPropagator.finishPropagationStep();\r\n      return false;\r\n    }\r\n  }, {\r\n    key: \"_howToHandleKeyEvent\",\r\n    value: function _howToHandleKeyEvent(event, focusTreeId, componentId, key, options, keyEventType) {\r\n      if (this.eventPropagator.isFirstPropagationStep()) {\r\n        if (options.ignoreEventsCondition(event) && this.eventPropagator.ignoreEvent(event)) {\r\n          return this._eventIsToBeIgnored(event, componentId, key, keyEventType);\r\n        }\r\n\r\n        this.logger.debug(this._logPrefix(componentId), \"New \".concat(describeKeyEvent(event, key, keyEventType), \" event.\"));\r\n\r\n        this._checkForModifierFlagDiscrepancies(event, key, keyEventType);\r\n      } else if (this.eventPropagator.isIgnoringEvent()) {\r\n        return this._eventIsToBeIgnored(event, componentId, key, keyEventType);\r\n      }\r\n\r\n      return EventResponse.handled;\r\n    }\r\n  }, {\r\n    key: \"_eventIsToBeIgnored\",\r\n    value: function _eventIsToBeIgnored(event, componentId, key, keyEventType) {\r\n      this.logger.debug(this._logPrefix(componentId), \"Ignored \".concat(describeKeyEvent(event, key, keyEventType), \" event because ignoreEventsFilter rejected it.\"));\r\n      return EventResponse.ignored;\r\n    }\r\n    /**\r\n     * Records a keypress keyboard event and matches it against the list of pre-registered\r\n     * event handlers, calling the first matching handler with the highest priority if\r\n     * one exists.\r\n     *\r\n     * This method is called many times as a keyboard event bubbles up through the React\r\n     * render tree. The event is only registered the first time it is seen and results\r\n     * of some calculations are cached. The event is matched against the handlers registered\r\n     * at each component level, to ensure the proper handler declaration scoping.\r\n     * @param {KeyboardEvent} event - Event containing the key name and state\r\n     * @param {FocusTreeId} focusTreeId Id - of focus tree component thinks it's apart of\r\n     * @param {ComponentId} componentId - The index of the component that is currently handling\r\n     *        the keyboard event as it bubbles towards the document root.\r\n     * @param {Object} options - Hash of options that configure how the event\r\n     *        is handled.\r\n     * @returns {boolean} Whether the HotKeys component should discard its current focus\r\n     *        tree Id, because it belongs to an old focus tree.\r\n     */\r\n\r\n  }, {\r\n    key: \"handleKeyPress\",\r\n    value: function handleKeyPress(event, focusTreeId, componentId, options) {\r\n      var key = getKeyName(event);\r\n      var currentCombination = this.getCurrentCombination();\r\n\r\n      if (currentCombination.isKeyPressSimulated(key)) {\r\n        this.logger.debug(this._logPrefix(componentId), \"Ignored \".concat(describeKeyEvent(event, key, KeyEventType.keypress), \" as it was not expected, and has already been simulated.\"));\r\n        this.eventPropagator.ignoreEvent(event);\r\n        return true;\r\n      }\r\n\r\n      var started = this.eventPropagator.startNewPropagationStep(componentId, event, key, KeyEventType.keypress);\r\n\r\n      if (!started) {\r\n        return;\r\n      }\r\n\r\n      var shouldDiscardFocusTreeId = focusTreeId !== this.focusTreeId;\r\n      /**\r\n       * We first decide if the keypress event should be handled (to ensure the correct\r\n       * order of logging statements)\r\n       */\r\n\r\n      var responseAction = this._howToHandleKeyEvent(event, focusTreeId, componentId, key, options, KeyEventType.keypress);\r\n\r\n      if (this.eventPropagator.isFirstPropagationStep(componentId) && currentCombination.isKeyIncluded(key)) {\r\n        this._addToAndLogCurrentKeyCombination(key, KeyEventType.keypress, focusTreeId, componentId, stateFromEvent(event));\r\n      }\r\n      /**\r\n       * We attempt to find a handler of the event, only if it has not already\r\n       * been handled and should not be ignored\r\n       */\r\n\r\n\r\n      if (responseAction === EventResponse.handled) {\r\n        this._callHandlerIfActionNotHandled(event, key, KeyEventType.keypress, componentId, focusTreeId);\r\n      }\r\n\r\n      this.eventPropagator.finishPropagationStep();\r\n      return shouldDiscardFocusTreeId;\r\n    }\r\n    /**\r\n     * Records a keyup keyboard event and matches it against the list of pre-registered\r\n     * event handlers, calling the first matching handler with the highest priority if\r\n     * one exists.\r\n     *\r\n     * This method is called many times as a keyboard event bubbles up through the React\r\n     * render tree. The event is only registered the first time it is seen and results\r\n     * of some calculations are cached. The event is matched against the handlers registered\r\n     * at each component level, to ensure the proper handler declaration scoping.\r\n     * @param {KeyboardEvent} event Event containing the key name and state\r\n     * @param {FocusTreeId} focusTreeId Id of focus tree component thinks it's apart of\r\n     * @param {ComponentId} componentId The index of the component that is currently handling\r\n     *        the keyboard event as it bubbles towards the document root.\r\n     * @param {Object} options Hash of options that configure how the event\r\n     *        is handled.\r\n     * @returns {boolean} Whether HotKeys component should discard its current focusTreeId\r\n     *        because it's stale (part of an old focus tree)\r\n     */\r\n\r\n  }, {\r\n    key: \"handleKeyUp\",\r\n    value: function handleKeyUp(event, focusTreeId, componentId, options) {\r\n      var key = getKeyName(event);\r\n      var currentCombination = this.getCurrentCombination();\r\n\r\n      if (currentCombination.isKeyUpSimulated(key)) {\r\n        this.logger.debug(this._logPrefix(componentId), \"Ignored \".concat(describeKeyEvent(event, key, KeyEventType.keyup), \" as it was not expected, and has already been simulated.\"));\r\n        this.eventPropagator.ignoreEvent(event);\r\n        return true;\r\n      }\r\n\r\n      var started = this.eventPropagator.startNewPropagationStep(componentId, event, key, KeyEventType.keyup);\r\n\r\n      if (!started) {\r\n        return;\r\n      }\r\n\r\n      var shouldDiscardFocusId = focusTreeId !== this.focusTreeId;\r\n      /**\r\n       * We first decide if the keyup event should be handled (to ensure the correct\r\n       * order of logging statements)\r\n       */\r\n\r\n      var responseAction = this._howToHandleKeyEvent(event, focusTreeId, componentId, key, options, KeyEventType.keyup);\r\n      /**\r\n       * We then add the keyup to our current combination - regardless of whether\r\n       * it's to be handled or not. We need to do this to ensure that if a handler\r\n       * function changes focus to a context that ignored events, the keyup event\r\n       * is not lost (leaving react hotkeys thinking the key is still pressed).\r\n       */\r\n\r\n\r\n      if (this.eventPropagator.isFirstPropagationStep(componentId) && currentCombination.isKeyIncluded(key)) {\r\n        this._addToAndLogCurrentKeyCombination(key, KeyEventType.keyup, focusTreeId, componentId, stateFromEvent(event));\r\n      }\r\n      /**\r\n       * We attempt to find a handler of the event, only if it has not already\r\n       * been handled and should not be ignored\r\n       */\r\n\r\n\r\n      if (responseAction === EventResponse.handled) {\r\n        this._callHandlerIfActionNotHandled(event, key, KeyEventType.keyup, componentId, focusTreeId);\r\n      }\r\n      /**\r\n       * We simulate any hidden keyup events hidden by the command key, regardless\r\n       * of whether the event should be ignored or not\r\n       */\r\n\r\n\r\n      this._simulateKeyUpEventsHiddenByCmd(event, key, focusTreeId, componentId, options);\r\n\r\n      this.eventPropagator.finishPropagationStep();\r\n      return shouldDiscardFocusId;\r\n    }\r\n    /**\r\n     * Closes any hanging key combinations that have not received the key event indicated\r\n     * by recordIndex.\r\n     * @param {KeyName} keyName The name of the key whose state should be updated if it\r\n     *        is currently set to keydown or keypress.\r\n     * @param {KeyEventType} recordIndex Index of key event to move the key state\r\n     *        up to.\r\n     */\r\n\r\n  }, {\r\n    key: \"closeHangingKeyCombination\",\r\n    value: function closeHangingKeyCombination(keyName, recordIndex) {\r\n      var currentCombination = this.getCurrentCombination();\r\n\r\n      if (currentCombination.isKeyIncluded(keyName) && !currentCombination.isEventTriggered(keyName, recordIndex)) {\r\n        /**\r\n         * If the key is in the current combination and recorded as still being pressed\r\n         * down (as either keydown or keypress), then we update the state\r\n         * to keypress or keyup (depending on the value of recordIndex).\r\n         */\r\n        currentCombination.setKeyState(keyName, recordIndex, KeyEventState.simulated);\r\n      }\r\n    }\r\n  }, {\r\n    key: \"_simulateKeyPressForNonPrintableKeys\",\r\n    value: function _simulateKeyPressForNonPrintableKeys(event, key, focusTreeId, componentId, options) {\r\n      this._handleEventSimulation('keypressEventsToSimulate', 'simulatePendingKeyPressEvents', this._shouldSimulate(KeyEventType.keypress, key), {\r\n        event: event,\r\n        key: key,\r\n        focusTreeId: focusTreeId,\r\n        componentId: componentId,\r\n        options: options\r\n      });\r\n    }\r\n  }, {\r\n    key: \"_simulateKeyUpEventsHiddenByCmd\",\r\n    value: function _simulateKeyUpEventsHiddenByCmd(event, key, focusTreeId, componentId, options) {\r\n      var _this2 = this;\r\n\r\n      if (isCmdKey(key)) {\r\n        this.getCurrentCombination().forEachKey(function (keyName) {\r\n          if (isCmdKey(keyName)) {\r\n            return;\r\n          }\r\n\r\n          _this2._handleEventSimulation('keyupEventsToSimulate', 'simulatePendingKeyUpEvents', _this2._shouldSimulate(KeyEventType.keyup, keyName), {\r\n            event: event,\r\n            key: keyName,\r\n            focusTreeId: focusTreeId,\r\n            componentId: componentId,\r\n            options: options\r\n          });\r\n        });\r\n      }\r\n    }\r\n  }, {\r\n    key: \"_stopEventPropagation\",\r\n    value: function _stopEventPropagation(event, componentId) {\r\n      if (this.eventPropagator.stop(event)) {\r\n        this.logger.debug(this._logPrefix(componentId), 'Stopping further event propagation.');\r\n      }\r\n    }\r\n  }, {\r\n    key: \"getEventPropagator\",\r\n    value: function getEventPropagator() {\r\n      return this.eventPropagator;\r\n    }\r\n  }, {\r\n    key: \"_startAndLogNewKeyCombination\",\r\n    value: function _startAndLogNewKeyCombination(keyName, focusTreeId, componentId, keyEventState) {\r\n      this.getKeyHistory().startNewKeyCombination(keyName, keyEventState);\r\n      this.logger.verbose(this._logPrefix(componentId, {\r\n        focusTreeId: focusTreeId\r\n      }), \"Started a new combination with '\".concat(keyName, \"'.\"));\r\n      this.logger.verbose(this._logPrefix(componentId, {\r\n        focusTreeId: focusTreeId\r\n      }), \"Key history: \".concat(printComponent(this.getKeyHistory().toJSON()), \".\"));\r\n    }\r\n  }, {\r\n    key: \"_addToAndLogCurrentKeyCombination\",\r\n    value: function _addToAndLogCurrentKeyCombination(keyName, keyEventType, focusTreeId, componentId, keyEventState) {\r\n      this.getKeyHistory().addKeyToCurrentCombination(keyName, keyEventType, keyEventState);\r\n\r\n      if (keyEventType === KeyEventType.keydown) {\r\n        this.logger.verbose(this._logPrefix(componentId, {\r\n          focusTreeId: focusTreeId\r\n        }), \"Added '\".concat(keyName, \"' to current combination: '\").concat(this.getCurrentCombination().describe(), \"'.\"));\r\n      }\r\n\r\n      this.logger.verbose(this._logPrefix(componentId, {\r\n        focusTreeId: focusTreeId\r\n      }), \"Key history: \".concat(printComponent(this.getKeyHistory().toJSON()), \".\"));\r\n    }\r\n    /********************************************************************************\r\n     * Event simulation\r\n     ********************************************************************************/\r\n\r\n  }, {\r\n    key: \"_handleEventSimulation\",\r\n    value: function _handleEventSimulation(listName, handlerName, shouldSimulate, _ref) {\r\n      var event = _ref.event,\r\n          key = _ref.key,\r\n          focusTreeId = _ref.focusTreeId,\r\n          componentId = _ref.componentId,\r\n          options = _ref.options;\r\n\r\n      if (shouldSimulate && Configuration.option('simulateMissingKeyPressEvents')) {\r\n        /**\r\n         * If a key does not have a keypress event, we save the details of the keydown\r\n         * event to simulate the keypress event, as the keydown event bubbles through\r\n         * the last focus-only HotKeysComponent\r\n         */\r\n        var _event = this._cloneAndMergeEvent(event, {\r\n          key: key,\r\n          simulated: true\r\n        });\r\n\r\n        this[listName].push({\r\n          event: _event,\r\n          focusTreeId: focusTreeId,\r\n          componentId: componentId,\r\n          options: options\r\n        });\r\n      }\r\n\r\n      if (this.componentList.isRoot(componentId) || this.eventPropagator.isStopped()) {\r\n        if (!this.keyEventManager.isGlobalListenersBound()) {\r\n          this[handlerName]();\r\n        }\r\n        /**\r\n         * else, we wait for keydown event to propagate through global strategy\r\n         * before we simulate the keypress\r\n         */\r\n\r\n      }\r\n    }\r\n  }, {\r\n    key: \"simulatePendingKeyPressEvents\",\r\n    value: function simulatePendingKeyPressEvents() {\r\n      this._simulatePendingKeyEvents('keypressEventsToSimulate', 'handleKeyPress');\r\n    }\r\n  }, {\r\n    key: \"simulatePendingKeyUpEvents\",\r\n    value: function simulatePendingKeyUpEvents() {\r\n      this._simulatePendingKeyEvents('keyupEventsToSimulate', 'handleKeyUp');\r\n    }\r\n  }, {\r\n    key: \"_simulatePendingKeyEvents\",\r\n    value: function _simulatePendingKeyEvents(listName, handlerName) {\r\n      var _this3 = this;\r\n\r\n      if (this[listName].length > 0) {\r\n        KeyEventCounter.incrementId();\r\n      }\r\n\r\n      this[listName].forEach(function (_ref2) {\r\n        var event = _ref2.event,\r\n            focusTreeId = _ref2.focusTreeId,\r\n            componentId = _ref2.componentId,\r\n            options = _ref2.options;\r\n\r\n        _this3[handlerName](event, focusTreeId, componentId, options);\r\n      });\r\n      this[listName] = [];\r\n    }\r\n    /********************************************************************************\r\n     * Matching and calling handlers\r\n     ********************************************************************************/\r\n\r\n    /**\r\n     * Calls the first handler that matches the current key event if the action has not\r\n     * already been handled in a more deeply nested component\r\n     * @param {KeyboardEvent} event Keyboard event object to be passed to the handler\r\n     * @param {NormalizedKeyName} keyName Normalized key name\r\n     * @param {KeyEventType} keyEventType The record index of the current key event type\r\n     * @param {FocusTreeId} focusTreeId Id of focus tree component thinks it's apart of\r\n     * @param {ComponentId} componentId Index of the component that is currently handling\r\n     *        the keyboard event\r\n     * @private\r\n     */\r\n\r\n  }, {\r\n    key: \"_callHandlerIfActionNotHandled\",\r\n    value: function _callHandlerIfActionNotHandled(event, keyName, keyEventType, componentId, focusTreeId) {\r\n      var eventName = describeKeyEventType(keyEventType);\r\n      var combinationName = this.getCurrentCombination().describe();\r\n\r\n      if (!this.componentList.anyActionsForEventType(keyEventType)) {\r\n        this.logger.verbose(this._logPrefix(componentId, {\r\n          focusTreeId: focusTreeId\r\n        }), \"Ignored '\".concat(combinationName, \"' \").concat(eventName, \" because it doesn't have any \").concat(eventName, \" handlers.\"));\r\n        return;\r\n      }\r\n\r\n      if (this.eventPropagator.isHandled()) {\r\n        this.logger.debug(this._logPrefix(componentId, {\r\n          focusTreeId: focusTreeId\r\n        }), \"Ignored '\".concat(combinationName, \"' \").concat(eventName, \" as it has already been handled.\"));\r\n      } else {\r\n        this.logger.verbose(this._logPrefix(componentId, {\r\n          focusTreeId: focusTreeId\r\n        }), \"Attempting to find action matching '\".concat(combinationName, \"' \").concat(eventName, \" . . .\"));\r\n        var previousComponentPosition = this.eventPropagator.getPreviousPosition();\r\n        var componentPosition = this.componentList.getIndexById(componentId);\r\n\r\n        var handlerWasCalled = this._callClosestMatchingHandler(event, keyName, keyEventType, componentPosition, previousComponentPosition === -1 ? 0 : previousComponentPosition);\r\n\r\n        if (handlerWasCalled) {\r\n          this.eventPropagator.setHandled();\r\n        }\r\n      }\r\n    }\r\n    /********************************************************************************\r\n     * Logging\r\n     ********************************************************************************/\r\n\r\n  }, {\r\n    key: \"_logPrefix\",\r\n    value: function _logPrefix(componentId) {\r\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\r\n      var logIcons = Logger.logIcons;\r\n      var eventIcons = Logger.eventIcons;\r\n      var componentIcons = Logger.componentIcons;\r\n      var base = 'HotKeys (';\r\n\r\n      if (options.focusTreeId !== false) {\r\n        var focusTreeId = isUndefined(options.focusTreeId) ? this.focusTreeId : options.focusTreeId;\r\n        base += \"F\".concat(focusTreeId).concat(logIcons[focusTreeId % logIcons.length], \"-\");\r\n      }\r\n\r\n      if (options.eventId !== false) {\r\n        var eventId = isUndefined(options.eventId) ? KeyEventCounter.getId() : options.eventId;\r\n        base += \"E\".concat(eventId).concat(eventIcons[eventId % eventIcons.length], \"-\");\r\n      }\r\n\r\n      base += \"C\".concat(componentId).concat(componentIcons[componentId % componentIcons.length]);\r\n      var position = this.componentList.getIndexById(componentId);\r\n\r\n      if (!isUndefined(position)) {\r\n        base += \"-P\".concat(position).concat(componentIcons[position % componentIcons.length], \":\");\r\n      }\r\n\r\n      return \"\".concat(base, \")\");\r\n    }\r\n  }]);\r\n\r\n  return FocusOnlyKeyEventStrategy;\r\n}(AbstractKeyEventStrategy);\r\n\r\nexport default FocusOnlyKeyEventStrategy;"]},"metadata":{},"sourceType":"module"}