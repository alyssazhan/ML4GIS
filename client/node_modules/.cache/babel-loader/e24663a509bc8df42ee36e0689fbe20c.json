{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport KeyHistoryMatcher from './KeyHistoryMatcher';\n/**\n * Resolves the correct actions to trigger for a list of hotkeys components and a\n * history of key events\n * @class\n */\n\nvar ActionResolver = /*#__PURE__*/function () {\n  /**\n   * Creates a new instance of ActionResolver\n   * @param {ComponentOptionsList} componentList List of components\n   * @returns {ActionResolver}\n   */\n  function ActionResolver(componentList) {\n    _classCallCheck(this, ActionResolver);\n    /**\n     * List of mappings from key sequences to handlers that is constructed on-the-fly\n     * as key events propagate up the render tree\n     * @type {KeyHistoryMatcher[]}\n     */\n\n\n    this._keyMapMatchers = [];\n    /**\n     * Array of counters - one for each component - to keep track of how many handlers\n     * for that component still need actions assigned to them\n     * @type {Array.<Number,Object>}\n     */\n\n    this._unmatchedHandlerStatus = [];\n    /**\n     * A dictionary mapping action names to the position in the list of the components\n     * that define handlers for them\n     * @type {Object.<ActionName, Number[]>}\n     */\n\n    this._handlersDictionary = {};\n    /**\n     * A dictionary of sequences already encountered in the process of building the\n     * list of keyMaps on the fly, as key events propagate up the component tree\n     * @type {Object.<MouseTrapKeySequence, Number[]>}\n     */\n\n    this._keySequencesDictionary = {};\n    var iterator = componentList.getNewIterator();\n\n    while (iterator.next()) {\n      var _iterator$getComponen = iterator.getComponent(),\n          handlers = _iterator$getComponen.handlers;\n\n      this._unmatchedHandlerStatus.push([Object.keys(handlers).length, {}]);\n\n      this._keyMapMatchers.push(new KeyHistoryMatcher());\n    }\n\n    this._componentList = componentList;\n    this._componentListIterator = componentList.getNewIterator();\n  }\n  /**\n   * The KeyHistoryMatcher for the component in a particular position\n   * @param {number} componentPosition Position of component to find the\n   *        KeyHistoryMatcher for\n   * @returns {KeyHistoryMatcher} Key combination matcher that corresponds\n   *        to the component\n   */\n\n\n  _createClass(ActionResolver, [{\n    key: \"getKeyHistoryMatcher\",\n    value: function getKeyHistoryMatcher(componentPosition) {\n      if (this._componentHasUnmatchedHandlers(componentPosition)) {\n        /**\n         * We build the mapping between actions and their closest handlers the\n         * first time the key map for the component at <tt>position</tt> is accessed.\n         *\n         * We must search higher than the current component for actions, as they are\n         * often defined in parent components of those that ultimately define their\n         * handlers.\n         */\n        while (this._componentListIterator.next()) {\n          this._addHandlersFromComponent();\n\n          this._addActionsFromComponent();\n        }\n      }\n\n      return this._getKeyHistoryMatcher(componentPosition);\n    }\n    /**\n     * Whether a component has one or more actions bound to an event type\n     * @param {number} componentPosition Position of the component\n     * @param {KeyEventType} keyEventType\n     * @returns {boolean} true if the component has an action bound to the event type\n     */\n\n  }, {\n    key: \"componentHasActionsBoundToEventType\",\n    value: function componentHasActionsBoundToEventType(componentPosition, keyEventType) {\n      return this.getKeyHistoryMatcher(componentPosition).hasMatchesForEventType(keyEventType);\n    }\n    /**\n     * Finds matcher for sequence and current key event for a component at a position\n     * @param {number} componentPosition Position of the component\n     * @param {KeyHistory} keyHistory History of key combinations to match\n     *        against actions defined in component\n     * @param {ReactKeyName} keyName Name of the key the current event relates to\n     * @param {KeyEventType} keyEventType Type of key event\n     * @returns {Object|null}\n     */\n\n  }, {\n    key: \"findMatchingKeySequenceInComponent\",\n    value: function findMatchingKeySequenceInComponent(componentPosition, keyHistory, keyName, keyEventType) {\n      if (!this.componentHasActionsBoundToEventType(componentPosition, keyEventType)) {\n        return null;\n      }\n\n      return this.getKeyHistoryMatcher(componentPosition).findMatch(keyHistory, keyName, keyEventType);\n    }\n    /********************************************************************************\n     * Private methods\n     *********************************************************************************/\n\n  }, {\n    key: \"_getKeyHistoryMatcher\",\n    value: function _getKeyHistoryMatcher(index) {\n      return this._keyMapMatchers[index];\n    }\n  }, {\n    key: \"_addActionsFromComponent\",\n    value: function _addActionsFromComponent() {\n      var _this = this;\n\n      var _this$_componentListI = this._componentListIterator.getComponent(),\n          actions = _this$_componentListI.actions;\n      /**\n       * Iterate over the actions of a component (starting with the current component\n       * and working through its ancestors), matching them to the current component's\n       * handlers\n       */\n\n\n      Object.keys(actions).forEach(function (actionName) {\n        var handlerComponentIndexArray = _this._getHandlers(actionName);\n\n        if (handlerComponentIndexArray) {\n          /**\n           * Get action handler closest to the event target\n           */\n          var handlerComponentIndex = handlerComponentIndexArray[0];\n\n          var handler = _this._componentList.getAtPosition(handlerComponentIndex).handlers[actionName];\n          /**\n           * Get key map that corresponds with the component that defines the handler\n           * closest to the event target\n           */\n\n\n          var keyMapMatcher = _this._getKeyHistoryMatcher(handlerComponentIndex);\n          /**\n           * At least one child HotKeys component (or the component itself) has\n           * defined a handler for the action, so now we need to associate them\n           */\n\n\n          var actionOptionsList = actions[actionName];\n          actionOptionsList.forEach(function (actionOptions) {\n            var keySequence = [actionOptions.prefix, actionOptions.id].join(' ');\n\n            if (_this._isClosestHandlerFound(keySequence, actionOptions)) {\n              /**\n               * Return if there is already a component with handlers for the current\n               * key sequence closer to the event target\n               */\n              return;\n            }\n\n            keyMapMatcher.addMatch(actionOptions, handler);\n\n            _this._addKeySequence(keySequence, [handlerComponentIndex, actionOptions.keyEventType]);\n          });\n          handlerComponentIndexArray.forEach(function (handlerComponentIndex) {\n            var handlerComponentStatus = _this._getUnmatchedHandlerStatus(handlerComponentIndex);\n\n            if (!handlerComponentStatus[1][actionName]) {\n              handlerComponentStatus[1][actionName] = true;\n              /**\n               * Decrement the number of remaining unmatched handlers for the\n               * component currently handling the propagating key event, so we know\n               * when all handlers have been matched to sequences and we can move on\n               * to matching them against the current key event\n               */\n\n              handlerComponentStatus[0]--;\n            }\n          });\n        }\n      });\n    }\n  }, {\n    key: \"_getHandlers\",\n    value: function _getHandlers(actionName) {\n      return this._handlersDictionary[actionName];\n    }\n  }, {\n    key: \"_addHandlersFromComponent\",\n    value: function _addHandlersFromComponent() {\n      var _this2 = this;\n\n      var _this$_componentListI2 = this._componentListIterator.getComponent(),\n          handlers = _this$_componentListI2.handlers;\n      /**\n       * Add current component's handlers to the handlersDictionary so we know\n       * which component has defined them\n       */\n\n\n      Object.keys(handlers).forEach(function (actionName) {\n        _this2._addHandler(actionName);\n      });\n    }\n  }, {\n    key: \"_addHandler\",\n    value: function _addHandler(actionName) {\n      if (!this._handlersDictionary[actionName]) {\n        this._handlersDictionary[actionName] = [];\n      }\n\n      this._handlersDictionary[actionName].push(this._componentListIterator.getPosition());\n    }\n  }, {\n    key: \"_addKeySequence\",\n    value: function _addKeySequence(keySequence, value) {\n      /**\n       * Record that we have already found a handler for the current action so\n       * that we do not override handlers for an action closest to the event target\n       * with handlers further up the tree\n       */\n      if (!this._keySequencesDictionary[keySequence]) {\n        this._keySequencesDictionary[keySequence] = [];\n      }\n\n      this._keySequencesDictionary[keySequence].push(value);\n    }\n  }, {\n    key: \"_componentHasUnmatchedHandlers\",\n    value: function _componentHasUnmatchedHandlers(componentIndex) {\n      return this._getUnmatchedHandlerStatus(componentIndex)[0] > 0;\n    }\n  }, {\n    key: \"_getUnmatchedHandlerStatus\",\n    value: function _getUnmatchedHandlerStatus(index) {\n      return this._unmatchedHandlerStatus[index];\n    }\n  }, {\n    key: \"_isClosestHandlerFound\",\n    value: function _isClosestHandlerFound(keySequence, keyMatcher) {\n      return this._keySequencesDictionary[keySequence] && this._keySequencesDictionary[keySequence].some(function (dictEntry) {\n        return dictEntry[1] === keyMatcher.keyEventType;\n      });\n    }\n  }]);\n\n  return ActionResolver;\n}();\n\nexport default ActionResolver;","map":{"version":3,"sources":["D:/GitHub/ML4GIS/client/node_modules/react-hotkeys/es/lib/matching/ActionResolver.js"],"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","KeyHistoryMatcher","ActionResolver","componentList","_keyMapMatchers","_unmatchedHandlerStatus","_handlersDictionary","_keySequencesDictionary","iterator","getNewIterator","next","_iterator$getComponen","getComponent","handlers","push","keys","_componentList","_componentListIterator","value","getKeyHistoryMatcher","componentPosition","_componentHasUnmatchedHandlers","_addHandlersFromComponent","_addActionsFromComponent","_getKeyHistoryMatcher","componentHasActionsBoundToEventType","keyEventType","hasMatchesForEventType","findMatchingKeySequenceInComponent","keyHistory","keyName","findMatch","index","_this","_this$_componentListI","actions","forEach","actionName","handlerComponentIndexArray","_getHandlers","handlerComponentIndex","handler","getAtPosition","keyMapMatcher","actionOptionsList","actionOptions","keySequence","prefix","id","join","_isClosestHandlerFound","addMatch","_addKeySequence","handlerComponentStatus","_getUnmatchedHandlerStatus","_this2","_this$_componentListI2","_addHandler","getPosition","componentIndex","keyMatcher","some","dictEntry"],"mappings":"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","sourcesContent":["function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nimport KeyHistoryMatcher from './KeyHistoryMatcher';\n/**\n * Resolves the correct actions to trigger for a list of hotkeys components and a\n * history of key events\n * @class\n */\n\nvar ActionResolver =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Creates a new instance of ActionResolver\n   * @param {ComponentOptionsList} componentList List of components\n   * @returns {ActionResolver}\n   */\n  function ActionResolver(componentList) {\n    _classCallCheck(this, ActionResolver);\n\n    /**\n     * List of mappings from key sequences to handlers that is constructed on-the-fly\n     * as key events propagate up the render tree\n     * @type {KeyHistoryMatcher[]}\n     */\n    this._keyMapMatchers = [];\n    /**\n     * Array of counters - one for each component - to keep track of how many handlers\n     * for that component still need actions assigned to them\n     * @type {Array.<Number,Object>}\n     */\n\n    this._unmatchedHandlerStatus = [];\n    /**\n     * A dictionary mapping action names to the position in the list of the components\n     * that define handlers for them\n     * @type {Object.<ActionName, Number[]>}\n     */\n\n    this._handlersDictionary = {};\n    /**\n     * A dictionary of sequences already encountered in the process of building the\n     * list of keyMaps on the fly, as key events propagate up the component tree\n     * @type {Object.<MouseTrapKeySequence, Number[]>}\n     */\n\n    this._keySequencesDictionary = {};\n    var iterator = componentList.getNewIterator();\n\n    while (iterator.next()) {\n      var _iterator$getComponen = iterator.getComponent(),\n          handlers = _iterator$getComponen.handlers;\n\n      this._unmatchedHandlerStatus.push([Object.keys(handlers).length, {}]);\n\n      this._keyMapMatchers.push(new KeyHistoryMatcher());\n    }\n\n    this._componentList = componentList;\n    this._componentListIterator = componentList.getNewIterator();\n  }\n  /**\n   * The KeyHistoryMatcher for the component in a particular position\n   * @param {number} componentPosition Position of component to find the\n   *        KeyHistoryMatcher for\n   * @returns {KeyHistoryMatcher} Key combination matcher that corresponds\n   *        to the component\n   */\n\n\n  _createClass(ActionResolver, [{\n    key: \"getKeyHistoryMatcher\",\n    value: function getKeyHistoryMatcher(componentPosition) {\n      if (this._componentHasUnmatchedHandlers(componentPosition)) {\n        /**\n         * We build the mapping between actions and their closest handlers the\n         * first time the key map for the component at <tt>position</tt> is accessed.\n         *\n         * We must search higher than the current component for actions, as they are\n         * often defined in parent components of those that ultimately define their\n         * handlers.\n         */\n        while (this._componentListIterator.next()) {\n          this._addHandlersFromComponent();\n\n          this._addActionsFromComponent();\n        }\n      }\n\n      return this._getKeyHistoryMatcher(componentPosition);\n    }\n    /**\n     * Whether a component has one or more actions bound to an event type\n     * @param {number} componentPosition Position of the component\n     * @param {KeyEventType} keyEventType\n     * @returns {boolean} true if the component has an action bound to the event type\n     */\n\n  }, {\n    key: \"componentHasActionsBoundToEventType\",\n    value: function componentHasActionsBoundToEventType(componentPosition, keyEventType) {\n      return this.getKeyHistoryMatcher(componentPosition).hasMatchesForEventType(keyEventType);\n    }\n    /**\n     * Finds matcher for sequence and current key event for a component at a position\n     * @param {number} componentPosition Position of the component\n     * @param {KeyHistory} keyHistory History of key combinations to match\n     *        against actions defined in component\n     * @param {ReactKeyName} keyName Name of the key the current event relates to\n     * @param {KeyEventType} keyEventType Type of key event\n     * @returns {Object|null}\n     */\n\n  }, {\n    key: \"findMatchingKeySequenceInComponent\",\n    value: function findMatchingKeySequenceInComponent(componentPosition, keyHistory, keyName, keyEventType) {\n      if (!this.componentHasActionsBoundToEventType(componentPosition, keyEventType)) {\n        return null;\n      }\n\n      return this.getKeyHistoryMatcher(componentPosition).findMatch(keyHistory, keyName, keyEventType);\n    }\n    /********************************************************************************\n     * Private methods\n     *********************************************************************************/\n\n  }, {\n    key: \"_getKeyHistoryMatcher\",\n    value: function _getKeyHistoryMatcher(index) {\n      return this._keyMapMatchers[index];\n    }\n  }, {\n    key: \"_addActionsFromComponent\",\n    value: function _addActionsFromComponent() {\n      var _this = this;\n\n      var _this$_componentListI = this._componentListIterator.getComponent(),\n          actions = _this$_componentListI.actions;\n      /**\n       * Iterate over the actions of a component (starting with the current component\n       * and working through its ancestors), matching them to the current component's\n       * handlers\n       */\n\n\n      Object.keys(actions).forEach(function (actionName) {\n        var handlerComponentIndexArray = _this._getHandlers(actionName);\n\n        if (handlerComponentIndexArray) {\n          /**\n           * Get action handler closest to the event target\n           */\n          var handlerComponentIndex = handlerComponentIndexArray[0];\n\n          var handler = _this._componentList.getAtPosition(handlerComponentIndex).handlers[actionName];\n          /**\n           * Get key map that corresponds with the component that defines the handler\n           * closest to the event target\n           */\n\n\n          var keyMapMatcher = _this._getKeyHistoryMatcher(handlerComponentIndex);\n          /**\n           * At least one child HotKeys component (or the component itself) has\n           * defined a handler for the action, so now we need to associate them\n           */\n\n\n          var actionOptionsList = actions[actionName];\n          actionOptionsList.forEach(function (actionOptions) {\n            var keySequence = [actionOptions.prefix, actionOptions.id].join(' ');\n\n            if (_this._isClosestHandlerFound(keySequence, actionOptions)) {\n              /**\n               * Return if there is already a component with handlers for the current\n               * key sequence closer to the event target\n               */\n              return;\n            }\n\n            keyMapMatcher.addMatch(actionOptions, handler);\n\n            _this._addKeySequence(keySequence, [handlerComponentIndex, actionOptions.keyEventType]);\n          });\n          handlerComponentIndexArray.forEach(function (handlerComponentIndex) {\n            var handlerComponentStatus = _this._getUnmatchedHandlerStatus(handlerComponentIndex);\n\n            if (!handlerComponentStatus[1][actionName]) {\n              handlerComponentStatus[1][actionName] = true;\n              /**\n               * Decrement the number of remaining unmatched handlers for the\n               * component currently handling the propagating key event, so we know\n               * when all handlers have been matched to sequences and we can move on\n               * to matching them against the current key event\n               */\n\n              handlerComponentStatus[0]--;\n            }\n          });\n        }\n      });\n    }\n  }, {\n    key: \"_getHandlers\",\n    value: function _getHandlers(actionName) {\n      return this._handlersDictionary[actionName];\n    }\n  }, {\n    key: \"_addHandlersFromComponent\",\n    value: function _addHandlersFromComponent() {\n      var _this2 = this;\n\n      var _this$_componentListI2 = this._componentListIterator.getComponent(),\n          handlers = _this$_componentListI2.handlers;\n      /**\n       * Add current component's handlers to the handlersDictionary so we know\n       * which component has defined them\n       */\n\n\n      Object.keys(handlers).forEach(function (actionName) {\n        _this2._addHandler(actionName);\n      });\n    }\n  }, {\n    key: \"_addHandler\",\n    value: function _addHandler(actionName) {\n      if (!this._handlersDictionary[actionName]) {\n        this._handlersDictionary[actionName] = [];\n      }\n\n      this._handlersDictionary[actionName].push(this._componentListIterator.getPosition());\n    }\n  }, {\n    key: \"_addKeySequence\",\n    value: function _addKeySequence(keySequence, value) {\n      /**\n       * Record that we have already found a handler for the current action so\n       * that we do not override handlers for an action closest to the event target\n       * with handlers further up the tree\n       */\n      if (!this._keySequencesDictionary[keySequence]) {\n        this._keySequencesDictionary[keySequence] = [];\n      }\n\n      this._keySequencesDictionary[keySequence].push(value);\n    }\n  }, {\n    key: \"_componentHasUnmatchedHandlers\",\n    value: function _componentHasUnmatchedHandlers(componentIndex) {\n      return this._getUnmatchedHandlerStatus(componentIndex)[0] > 0;\n    }\n  }, {\n    key: \"_getUnmatchedHandlerStatus\",\n    value: function _getUnmatchedHandlerStatus(index) {\n      return this._unmatchedHandlerStatus[index];\n    }\n  }, {\n    key: \"_isClosestHandlerFound\",\n    value: function _isClosestHandlerFound(keySequence, keyMatcher) {\n      return this._keySequencesDictionary[keySequence] && this._keySequencesDictionary[keySequence].some(function (dictEntry) {\n        return dictEntry[1] === keyMatcher.keyEventType;\n      });\n    }\n  }]);\n\n  return ActionResolver;\n}();\n\nexport default ActionResolver;"]},"metadata":{},"sourceType":"module"}