{"ast":null,"code":"import { __assign } from \"tslib\";\n/* eslint-disable */\n\nimport { useMemo, useRef } from 'react';\nimport useMountedState from './useMountedState';\nimport useUpdate from './useUpdate';\nimport useUpdateEffect from './useUpdateEffect';\nexport default function useStateList(stateSet) {\n  if (stateSet === void 0) {\n    stateSet = [];\n  }\n\n  var isMounted = useMountedState();\n  var update = useUpdate();\n  var index = useRef(0); // If new state list is shorter that before - switch to the last element\n\n  useUpdateEffect(function () {\n    if (stateSet.length <= index.current) {\n      index.current = stateSet.length - 1;\n      update();\n    }\n  }, [stateSet.length]);\n  var actions = useMemo(function () {\n    return {\n      next: function next() {\n        return actions.setStateAt(index.current + 1);\n      },\n      prev: function prev() {\n        return actions.setStateAt(index.current - 1);\n      },\n      setStateAt: function setStateAt(newIndex) {\n        // do nothing on unmounted component\n        if (!isMounted()) return; // do nothing on empty states list\n\n        if (!stateSet.length) return; // in case new index is equal current - do nothing\n\n        if (newIndex === index.current) return; // it gives the ability to travel through the left and right borders.\n        // 4ex: if list contains 5 elements, attempt to set index 9 will bring use to 5th element\n        // in case of negative index it will start counting from the right, so -17 will bring us to 4th element\n\n        index.current = newIndex >= 0 ? newIndex % stateSet.length : stateSet.length + newIndex % stateSet.length;\n        update();\n      },\n      setState: function setState(state) {\n        // do nothing on unmounted component\n        if (!isMounted()) return;\n        var newIndex = stateSet.length ? stateSet.indexOf(state) : -1;\n\n        if (newIndex === -1) {\n          throw new Error(\"State '\" + state + \"' is not a valid state (does not exist in state list)\");\n        }\n\n        index.current = newIndex;\n        update();\n      }\n    };\n  }, [stateSet]);\n  return __assign({\n    state: stateSet[index.current],\n    currentIndex: index.current\n  }, actions);\n}","map":{"version":3,"sources":["D:/GitHub/ML4GIS/client/node_modules/react-use/esm/useStateList.js"],"names":["__assign","useMemo","useRef","useMountedState","useUpdate","useUpdateEffect","useStateList","stateSet","isMounted","update","index","length","current","actions","next","setStateAt","prev","newIndex","setState","state","indexOf","Error","currentIndex"],"mappings":"AAAA,SAASA,QAAT,QAAyB,OAAzB;AACA;;AACA,SAASC,OAAT,EAAkBC,MAAlB,QAAgC,OAAhC;AACA,OAAOC,eAAP,MAA4B,mBAA5B;AACA,OAAOC,SAAP,MAAsB,aAAtB;AACA,OAAOC,eAAP,MAA4B,mBAA5B;AACA,eAAe,SAASC,YAAT,CAAsBC,QAAtB,EAAgC;AAC3C,MAAIA,QAAQ,KAAK,KAAK,CAAtB,EAAyB;AAAEA,IAAAA,QAAQ,GAAG,EAAX;AAAgB;;AAC3C,MAAIC,SAAS,GAAGL,eAAe,EAA/B;AACA,MAAIM,MAAM,GAAGL,SAAS,EAAtB;AACA,MAAIM,KAAK,GAAGR,MAAM,CAAC,CAAD,CAAlB,CAJ2C,CAK3C;;AACAG,EAAAA,eAAe,CAAC,YAAY;AACxB,QAAIE,QAAQ,CAACI,MAAT,IAAmBD,KAAK,CAACE,OAA7B,EAAsC;AAClCF,MAAAA,KAAK,CAACE,OAAN,GAAgBL,QAAQ,CAACI,MAAT,GAAkB,CAAlC;AACAF,MAAAA,MAAM;AACT;AACJ,GALc,EAKZ,CAACF,QAAQ,CAACI,MAAV,CALY,CAAf;AAMA,MAAIE,OAAO,GAAGZ,OAAO,CAAC,YAAY;AAAE,WAAQ;AACxCa,MAAAA,IAAI,EAAE,gBAAY;AAAE,eAAOD,OAAO,CAACE,UAAR,CAAmBL,KAAK,CAACE,OAAN,GAAgB,CAAnC,CAAP;AAA+C,OAD3B;AAExCI,MAAAA,IAAI,EAAE,gBAAY;AAAE,eAAOH,OAAO,CAACE,UAAR,CAAmBL,KAAK,CAACE,OAAN,GAAgB,CAAnC,CAAP;AAA+C,OAF3B;AAGxCG,MAAAA,UAAU,EAAE,oBAAUE,QAAV,EAAoB;AAC5B;AACA,YAAI,CAACT,SAAS,EAAd,EACI,OAHwB,CAI5B;;AACA,YAAI,CAACD,QAAQ,CAACI,MAAd,EACI,OANwB,CAO5B;;AACA,YAAIM,QAAQ,KAAKP,KAAK,CAACE,OAAvB,EACI,OATwB,CAU5B;AACA;AACA;;AACAF,QAAAA,KAAK,CAACE,OAAN,GAAgBK,QAAQ,IAAI,CAAZ,GAAgBA,QAAQ,GAAGV,QAAQ,CAACI,MAApC,GAA6CJ,QAAQ,CAACI,MAAT,GAAmBM,QAAQ,GAAGV,QAAQ,CAACI,MAApG;AACAF,QAAAA,MAAM;AACT,OAlBuC;AAmBxCS,MAAAA,QAAQ,EAAE,kBAAUC,KAAV,EAAiB;AACvB;AACA,YAAI,CAACX,SAAS,EAAd,EACI;AACJ,YAAIS,QAAQ,GAAGV,QAAQ,CAACI,MAAT,GAAkBJ,QAAQ,CAACa,OAAT,CAAiBD,KAAjB,CAAlB,GAA4C,CAAC,CAA5D;;AACA,YAAIF,QAAQ,KAAK,CAAC,CAAlB,EAAqB;AACjB,gBAAM,IAAII,KAAJ,CAAU,YAAYF,KAAZ,GAAoB,uDAA9B,CAAN;AACH;;AACDT,QAAAA,KAAK,CAACE,OAAN,GAAgBK,QAAhB;AACAR,QAAAA,MAAM;AACT;AA7BuC,KAAR;AA8B/B,GA9BgB,EA8Bd,CAACF,QAAD,CA9Bc,CAArB;AA+BA,SAAOP,QAAQ,CAAC;AAAEmB,IAAAA,KAAK,EAAEZ,QAAQ,CAACG,KAAK,CAACE,OAAP,CAAjB;AAAkCU,IAAAA,YAAY,EAAEZ,KAAK,CAACE;AAAtD,GAAD,EAAkEC,OAAlE,CAAf;AACH","sourcesContent":["import { __assign } from \"tslib\";\r\n/* eslint-disable */\r\nimport { useMemo, useRef } from 'react';\r\nimport useMountedState from './useMountedState';\r\nimport useUpdate from './useUpdate';\r\nimport useUpdateEffect from './useUpdateEffect';\r\nexport default function useStateList(stateSet) {\r\n    if (stateSet === void 0) { stateSet = []; }\r\n    var isMounted = useMountedState();\r\n    var update = useUpdate();\r\n    var index = useRef(0);\r\n    // If new state list is shorter that before - switch to the last element\r\n    useUpdateEffect(function () {\r\n        if (stateSet.length <= index.current) {\r\n            index.current = stateSet.length - 1;\r\n            update();\r\n        }\r\n    }, [stateSet.length]);\r\n    var actions = useMemo(function () { return ({\r\n        next: function () { return actions.setStateAt(index.current + 1); },\r\n        prev: function () { return actions.setStateAt(index.current - 1); },\r\n        setStateAt: function (newIndex) {\r\n            // do nothing on unmounted component\r\n            if (!isMounted())\r\n                return;\r\n            // do nothing on empty states list\r\n            if (!stateSet.length)\r\n                return;\r\n            // in case new index is equal current - do nothing\r\n            if (newIndex === index.current)\r\n                return;\r\n            // it gives the ability to travel through the left and right borders.\r\n            // 4ex: if list contains 5 elements, attempt to set index 9 will bring use to 5th element\r\n            // in case of negative index it will start counting from the right, so -17 will bring us to 4th element\r\n            index.current = newIndex >= 0 ? newIndex % stateSet.length : stateSet.length + (newIndex % stateSet.length);\r\n            update();\r\n        },\r\n        setState: function (state) {\r\n            // do nothing on unmounted component\r\n            if (!isMounted())\r\n                return;\r\n            var newIndex = stateSet.length ? stateSet.indexOf(state) : -1;\r\n            if (newIndex === -1) {\r\n                throw new Error(\"State '\" + state + \"' is not a valid state (does not exist in state list)\");\r\n            }\r\n            index.current = newIndex;\r\n            update();\r\n        },\r\n    }); }, [stateSet]);\r\n    return __assign({ state: stateSet[index.current], currentIndex: index.current }, actions);\r\n}\r\n"]},"metadata":{},"sourceType":"module"}