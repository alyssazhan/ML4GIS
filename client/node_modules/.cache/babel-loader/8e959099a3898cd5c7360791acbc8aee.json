{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport KeyEventCounter from './KeyEventCounter';\nimport Configuration from '../config/Configuration';\nimport describeKeyEvent from '../../helpers/logging/describeKeyEvent';\nimport KeyEventType from '../../const/KeyEventType';\n/**\n * Handles the propagation of keyboard events up through the React component tree,\n * starting from the hot keys component closest to the event target\n * @class\n */\n\nvar EventPropagator = /*#__PURE__*/function () {\n  /**\n   * Create a new instance of EventPropagator\n   * @param {ComponentOptionsList} componentList List of options of the components\n   *        the event is propagating through\n   * @param {Logger} logger The logger instance to use\n   * @param {function} logPrefix Function that returns the appropriate log prefix for\n   *        each log entry\n   * @returns {EventPropagator}\n   */\n  function EventPropagator(componentList, _ref) {\n    var logger = _ref.logger,\n        logPrefix = _ref.logPrefix;\n\n    _classCallCheck(this, EventPropagator);\n\n    this._componentList = componentList;\n    this._previousPropagation = null;\n    this.logger = logger;\n    this._logPrefix = logPrefix;\n\n    this._reset();\n  }\n\n  _createClass(EventPropagator, [{\n    key: \"_reset\",\n    value: function _reset() {\n      /**\n       * Position of the component that the event last propagated through\n       * @type {number}\n       */\n      this._previousPosition = -1;\n      /**\n       * Position of the current component the event is propagating through\n       * @type {number}\n       */\n\n      this._position = -1;\n      /**\n       * Flag to record whether the keyboard event matches an action whose handler\n       * has already been called\n       * @type {boolean}\n       */\n\n      this._actionHandled = false;\n      /**\n       * Flag to record whether the keyboard event should be ignored\n       * @type {boolean}\n       */\n\n      this._ignoreEvent = false;\n      /**\n       * Flag to record whether the keyboard event current being handled should be\n       * observed, even if matches the ignoreEventCondition\n       * @type {boolean}\n       */\n\n      this._observeIgnoredEvents = false;\n      /**\n       * Flag to record whether the event is being stopped from further propagation\n       * @type {boolean}\n       */\n\n      this._stopping = false;\n      /**\n       * The id of the component the event is current propagating through\n       * @type {ComponentId}\n       */\n\n      this._componentId = null;\n      /**\n       * The name of the key the propagating event relates to\n       * @type {ReactKeyName}\n       */\n\n      this._key = null;\n      /**\n       * The type of keyboard event that is propagating\n       * @type {KeyEventType}\n       */\n\n      this._type = null;\n    }\n    /********************************************************************************\n     * New event propagation\n     *********************************************************************************/\n\n    /**\n     * Whether the current propagation step is the first one\n     * @returns {boolean} true if this is the first propagation step\n     */\n\n  }, {\n    key: \"isFirstPropagationStep\",\n    value: function isFirstPropagationStep() {\n      var previousPosition = this.getPreviousPosition();\n      return previousPosition === -1 || previousPosition >= this._position;\n    }\n    /**\n     * Whether the propagation is for a particular key\n     * @param {ReactKeyName} keyName The name of the key to query\n     * @returns {boolean} true if the event propagation is for the key\n     */\n\n  }, {\n    key: \"isForKey\",\n    value: function isForKey(keyName) {\n      return this._key === keyName;\n    }\n    /**\n     * The type of keyboard event that is propagating\n     * @param {KeyEventType} keyEventType The type of keyboard event to query\n     * @returns {boolean} true if the keyboard event propagating is that type\n     */\n\n  }, {\n    key: \"isForEventType\",\n    value: function isForEventType(keyEventType) {\n      return this._type === keyEventType;\n    }\n    /********************************************************************************\n     * Propagation steps\n     *********************************************************************************/\n\n    /**\n     * Begin a new propagation step, called as a before callback. i.e. the first thing\n     * after an event has propagated to a new hot keys component\n     * @param {ComponentId} componentId The id of the component that has just had the\n     *        event propagate up to it\n     * @param {KeyboardEvent} event The actual KeyboardEvent that is propagating\n     * @param {ReactKeyName} key The name of the key the event relates to\n     * @param {KeyEventType} type The type of keyboard event\n     * @returns {boolean} true if the event should be observed, otherwise false if it\n     *        should be ignored.\n     */\n\n  }, {\n    key: \"startNewPropagationStep\",\n    value: function startNewPropagationStep(componentId, event, key, type) {\n      this._position = this._componentList.getIndexById(componentId);\n      this._componentId = componentId;\n\n      if (this.isFirstPropagationStep()) {\n        KeyEventCounter.incrementId();\n        this._key = event.key;\n        this._type = type;\n      }\n\n      if (event.repeat && Configuration.option('ignoreRepeatedEventsWhenKeyHeldDown')) {\n        this.logger.debug(this._logPrefix(componentId), \"Ignored repeated \".concat(describeKeyEvent(event, key, KeyEventType.keydown), \" event.\"));\n        this.ignoreEvent(event);\n        return false;\n      }\n\n      return true;\n    }\n    /**\n     * Ends handling of a propagation step and performs cleanup. Called as a after callback.\n     * @returns {void}\n     */\n\n  }, {\n    key: \"finishPropagationStep\",\n    value: function finishPropagationStep() {\n      if (this.isStopped() || this._componentList.isRoot(this._componentId)) {\n        this._previousPropagation = this._clone();\n\n        this._reset();\n      } else {\n        this._previousPosition = this._position;\n      }\n    }\n    /********************************************************************************\n     * Previous propagation\n     *********************************************************************************/\n\n    /**\n     * The previous event propagation, either for an earlier event type of the same key\n     * or a different key's event propagation\n     * @returns {EventPropagator} The propagator for the previous event propagation\n     */\n\n  }, {\n    key: \"getPreviousPropagation\",\n    value: function getPreviousPropagation() {\n      if (!this._previousPropagation) {\n        this._previousPropagation = this._clone({\n          copyState: false\n        });\n      }\n\n      return this._previousPropagation;\n    }\n    /**\n     * The position of the component that last had the current propagating event\n     * propagate through it\n     * @returns {number}\n     */\n\n  }, {\n    key: \"getPreviousPosition\",\n    value: function getPreviousPosition() {\n      return this._previousPosition;\n    }\n    /********************************************************************************\n     * Ignoring events\n     *********************************************************************************/\n\n    /**\n     * Set the observeIgnoredEvents flag, to observe (not ignore) keyboard events that\n     * match the ignored events filter\n     * @returns {void}\n     */\n\n  }, {\n    key: \"observeIgnoredEvents\",\n    value: function observeIgnoredEvents() {\n      this._observeIgnoredEvents = true;\n    }\n    /**\n     * Record that an event is being ignored for the rest of its propagation and, if\n     * enabled, stop it from further propagation entirely.\n     * @param {KeyboardEvent} event Event to ignore\n     * @returns {boolean} true if the event was stopped from further propagation,\n     *          otherwise false.\n     */\n\n  }, {\n    key: \"ignoreEvent\",\n    value: function ignoreEvent(event) {\n      this.setIgnoreEvent(true);\n\n      if (this.isIgnoringEvent() && Configuration.option('stopEventPropagationAfterIgnoring')) {\n        this.logger.debug(this._logPrefix(this._componentId), 'Stopping further event propagation.');\n        this.stop(event);\n        this.finishPropagationStep();\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     * Set the ignore event flag, to ignore the current event for the rest of its\n     * propagation\n     * @param {boolean} ignore true to ignore the event, or false to not ignore it\n     * @returns {void}\n     */\n\n  }, {\n    key: \"setIgnoreEvent\",\n    value: function setIgnoreEvent(ignore) {\n      this._ignoreEvent = ignore;\n    }\n    /**\n     * Whether to ignore the currently propagating event or not\n     * @returns {boolean} true if the event is being ignored for the current propagation\n     */\n\n  }, {\n    key: \"isIgnoringEvent\",\n    value: function isIgnoringEvent() {\n      return !this._observeIgnoredEvents && this._ignoreEvent;\n    }\n    /********************************************************************************\n     * Stopping propagation\n     *********************************************************************************/\n\n    /**\n     * Whether the event has been stopped from further propagation\n     * @returns {boolean} true if the event is being stopped\n     */\n\n  }, {\n    key: \"isStopped\",\n    value: function isStopped() {\n      return this._stopping;\n    }\n    /**\n     * Stop an event from further propagation\n     * @param {KeyboardEvent} event Event to call stopPropagation() on\n     * @returns {boolean} true if the event was stopped and false if it was already\n     *          stopped\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop(event) {\n      if (!this.isStopped()) {\n        this._stopping = true; // noinspection JSUnresolvedVariable\n\n        if (!event.simulated) {\n          event.stopPropagation();\n        }\n\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     * Whether the keyboard event has yet propagated to the root hot keys component\n     * @returns {boolean} true if it still has hotkeys components to propagate to\n     *          before being complete.\n     */\n\n  }, {\n    key: \"isPendingPropagation\",\n    value: function isPendingPropagation() {\n      var previousPosition = this.getPreviousPosition();\n      return previousPosition !== -1 && previousPosition + 1 < this._position;\n    }\n    /**\n     * If the action has already been handled\n     * @returns {boolean} true if the action has already been handled\n     */\n\n  }, {\n    key: \"isHandled\",\n    value: function isHandled() {\n      return this._actionHandled;\n    }\n    /**\n     * Record that the current propagating event matched and action and its handler\n     * has been called.\n     * @returns {void}\n     */\n\n  }, {\n    key: \"setHandled\",\n    value: function setHandled() {\n      this._actionHandled = true;\n    }\n    /********************************************************************************\n     * Private methods\n     ********************************************************************************/\n\n  }, {\n    key: \"_clone\",\n    value: function _clone() {\n      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref2$copyState = _ref2.copyState,\n          copyState = _ref2$copyState === void 0 ? true : _ref2$copyState;\n\n      var cloned = new EventPropagator(this._componentList, {\n        logger: this.logger,\n        logPrefix: this._logPrefix\n      });\n\n      if (copyState) {\n        Object.assign(cloned, this);\n      }\n\n      return cloned;\n    }\n  }]);\n\n  return EventPropagator;\n}();\n\nexport default EventPropagator;","map":{"version":3,"sources":["/Users/yan/Documents/proj/ML4GIS/client/node_modules/react-hotkeys/es/lib/listening/EventPropagator.js"],"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","KeyEventCounter","Configuration","describeKeyEvent","KeyEventType","EventPropagator","componentList","_ref","logger","logPrefix","_componentList","_previousPropagation","_logPrefix","_reset","value","_previousPosition","_position","_actionHandled","_ignoreEvent","_observeIgnoredEvents","_stopping","_componentId","_key","_type","isFirstPropagationStep","previousPosition","getPreviousPosition","isForKey","keyName","isForEventType","keyEventType","startNewPropagationStep","componentId","event","type","getIndexById","incrementId","repeat","option","debug","concat","keydown","ignoreEvent","finishPropagationStep","isStopped","isRoot","_clone","getPreviousPropagation","copyState","observeIgnoredEvents","setIgnoreEvent","isIgnoringEvent","stop","ignore","simulated","stopPropagation","isPendingPropagation","isHandled","setHandled","_ref2","arguments","undefined","_ref2$copyState","cloned","assign"],"mappings":"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","sourcesContent":["function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nimport KeyEventCounter from './KeyEventCounter';\nimport Configuration from '../config/Configuration';\nimport describeKeyEvent from '../../helpers/logging/describeKeyEvent';\nimport KeyEventType from '../../const/KeyEventType';\n/**\n * Handles the propagation of keyboard events up through the React component tree,\n * starting from the hot keys component closest to the event target\n * @class\n */\n\nvar EventPropagator =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Create a new instance of EventPropagator\n   * @param {ComponentOptionsList} componentList List of options of the components\n   *        the event is propagating through\n   * @param {Logger} logger The logger instance to use\n   * @param {function} logPrefix Function that returns the appropriate log prefix for\n   *        each log entry\n   * @returns {EventPropagator}\n   */\n  function EventPropagator(componentList, _ref) {\n    var logger = _ref.logger,\n        logPrefix = _ref.logPrefix;\n\n    _classCallCheck(this, EventPropagator);\n\n    this._componentList = componentList;\n    this._previousPropagation = null;\n    this.logger = logger;\n    this._logPrefix = logPrefix;\n\n    this._reset();\n  }\n\n  _createClass(EventPropagator, [{\n    key: \"_reset\",\n    value: function _reset() {\n      /**\n       * Position of the component that the event last propagated through\n       * @type {number}\n       */\n      this._previousPosition = -1;\n      /**\n       * Position of the current component the event is propagating through\n       * @type {number}\n       */\n\n      this._position = -1;\n      /**\n       * Flag to record whether the keyboard event matches an action whose handler\n       * has already been called\n       * @type {boolean}\n       */\n\n      this._actionHandled = false;\n      /**\n       * Flag to record whether the keyboard event should be ignored\n       * @type {boolean}\n       */\n\n      this._ignoreEvent = false;\n      /**\n       * Flag to record whether the keyboard event current being handled should be\n       * observed, even if matches the ignoreEventCondition\n       * @type {boolean}\n       */\n\n      this._observeIgnoredEvents = false;\n      /**\n       * Flag to record whether the event is being stopped from further propagation\n       * @type {boolean}\n       */\n\n      this._stopping = false;\n      /**\n       * The id of the component the event is current propagating through\n       * @type {ComponentId}\n       */\n\n      this._componentId = null;\n      /**\n       * The name of the key the propagating event relates to\n       * @type {ReactKeyName}\n       */\n\n      this._key = null;\n      /**\n       * The type of keyboard event that is propagating\n       * @type {KeyEventType}\n       */\n\n      this._type = null;\n    }\n    /********************************************************************************\n     * New event propagation\n     *********************************************************************************/\n\n    /**\n     * Whether the current propagation step is the first one\n     * @returns {boolean} true if this is the first propagation step\n     */\n\n  }, {\n    key: \"isFirstPropagationStep\",\n    value: function isFirstPropagationStep() {\n      var previousPosition = this.getPreviousPosition();\n      return previousPosition === -1 || previousPosition >= this._position;\n    }\n    /**\n     * Whether the propagation is for a particular key\n     * @param {ReactKeyName} keyName The name of the key to query\n     * @returns {boolean} true if the event propagation is for the key\n     */\n\n  }, {\n    key: \"isForKey\",\n    value: function isForKey(keyName) {\n      return this._key === keyName;\n    }\n    /**\n     * The type of keyboard event that is propagating\n     * @param {KeyEventType} keyEventType The type of keyboard event to query\n     * @returns {boolean} true if the keyboard event propagating is that type\n     */\n\n  }, {\n    key: \"isForEventType\",\n    value: function isForEventType(keyEventType) {\n      return this._type === keyEventType;\n    }\n    /********************************************************************************\n     * Propagation steps\n     *********************************************************************************/\n\n    /**\n     * Begin a new propagation step, called as a before callback. i.e. the first thing\n     * after an event has propagated to a new hot keys component\n     * @param {ComponentId} componentId The id of the component that has just had the\n     *        event propagate up to it\n     * @param {KeyboardEvent} event The actual KeyboardEvent that is propagating\n     * @param {ReactKeyName} key The name of the key the event relates to\n     * @param {KeyEventType} type The type of keyboard event\n     * @returns {boolean} true if the event should be observed, otherwise false if it\n     *        should be ignored.\n     */\n\n  }, {\n    key: \"startNewPropagationStep\",\n    value: function startNewPropagationStep(componentId, event, key, type) {\n      this._position = this._componentList.getIndexById(componentId);\n      this._componentId = componentId;\n\n      if (this.isFirstPropagationStep()) {\n        KeyEventCounter.incrementId();\n        this._key = event.key;\n        this._type = type;\n      }\n\n      if (event.repeat && Configuration.option('ignoreRepeatedEventsWhenKeyHeldDown')) {\n        this.logger.debug(this._logPrefix(componentId), \"Ignored repeated \".concat(describeKeyEvent(event, key, KeyEventType.keydown), \" event.\"));\n        this.ignoreEvent(event);\n        return false;\n      }\n\n      return true;\n    }\n    /**\n     * Ends handling of a propagation step and performs cleanup. Called as a after callback.\n     * @returns {void}\n     */\n\n  }, {\n    key: \"finishPropagationStep\",\n    value: function finishPropagationStep() {\n      if (this.isStopped() || this._componentList.isRoot(this._componentId)) {\n        this._previousPropagation = this._clone();\n\n        this._reset();\n      } else {\n        this._previousPosition = this._position;\n      }\n    }\n    /********************************************************************************\n     * Previous propagation\n     *********************************************************************************/\n\n    /**\n     * The previous event propagation, either for an earlier event type of the same key\n     * or a different key's event propagation\n     * @returns {EventPropagator} The propagator for the previous event propagation\n     */\n\n  }, {\n    key: \"getPreviousPropagation\",\n    value: function getPreviousPropagation() {\n      if (!this._previousPropagation) {\n        this._previousPropagation = this._clone({\n          copyState: false\n        });\n      }\n\n      return this._previousPropagation;\n    }\n    /**\n     * The position of the component that last had the current propagating event\n     * propagate through it\n     * @returns {number}\n     */\n\n  }, {\n    key: \"getPreviousPosition\",\n    value: function getPreviousPosition() {\n      return this._previousPosition;\n    }\n    /********************************************************************************\n     * Ignoring events\n     *********************************************************************************/\n\n    /**\n     * Set the observeIgnoredEvents flag, to observe (not ignore) keyboard events that\n     * match the ignored events filter\n     * @returns {void}\n     */\n\n  }, {\n    key: \"observeIgnoredEvents\",\n    value: function observeIgnoredEvents() {\n      this._observeIgnoredEvents = true;\n    }\n    /**\n     * Record that an event is being ignored for the rest of its propagation and, if\n     * enabled, stop it from further propagation entirely.\n     * @param {KeyboardEvent} event Event to ignore\n     * @returns {boolean} true if the event was stopped from further propagation,\n     *          otherwise false.\n     */\n\n  }, {\n    key: \"ignoreEvent\",\n    value: function ignoreEvent(event) {\n      this.setIgnoreEvent(true);\n\n      if (this.isIgnoringEvent() && Configuration.option('stopEventPropagationAfterIgnoring')) {\n        this.logger.debug(this._logPrefix(this._componentId), 'Stopping further event propagation.');\n        this.stop(event);\n        this.finishPropagationStep();\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     * Set the ignore event flag, to ignore the current event for the rest of its\n     * propagation\n     * @param {boolean} ignore true to ignore the event, or false to not ignore it\n     * @returns {void}\n     */\n\n  }, {\n    key: \"setIgnoreEvent\",\n    value: function setIgnoreEvent(ignore) {\n      this._ignoreEvent = ignore;\n    }\n    /**\n     * Whether to ignore the currently propagating event or not\n     * @returns {boolean} true if the event is being ignored for the current propagation\n     */\n\n  }, {\n    key: \"isIgnoringEvent\",\n    value: function isIgnoringEvent() {\n      return !this._observeIgnoredEvents && this._ignoreEvent;\n    }\n    /********************************************************************************\n     * Stopping propagation\n     *********************************************************************************/\n\n    /**\n     * Whether the event has been stopped from further propagation\n     * @returns {boolean} true if the event is being stopped\n     */\n\n  }, {\n    key: \"isStopped\",\n    value: function isStopped() {\n      return this._stopping;\n    }\n    /**\n     * Stop an event from further propagation\n     * @param {KeyboardEvent} event Event to call stopPropagation() on\n     * @returns {boolean} true if the event was stopped and false if it was already\n     *          stopped\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop(event) {\n      if (!this.isStopped()) {\n        this._stopping = true; // noinspection JSUnresolvedVariable\n\n        if (!event.simulated) {\n          event.stopPropagation();\n        }\n\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     * Whether the keyboard event has yet propagated to the root hot keys component\n     * @returns {boolean} true if it still has hotkeys components to propagate to\n     *          before being complete.\n     */\n\n  }, {\n    key: \"isPendingPropagation\",\n    value: function isPendingPropagation() {\n      var previousPosition = this.getPreviousPosition();\n      return previousPosition !== -1 && previousPosition + 1 < this._position;\n    }\n    /**\n     * If the action has already been handled\n     * @returns {boolean} true if the action has already been handled\n     */\n\n  }, {\n    key: \"isHandled\",\n    value: function isHandled() {\n      return this._actionHandled;\n    }\n    /**\n     * Record that the current propagating event matched and action and its handler\n     * has been called.\n     * @returns {void}\n     */\n\n  }, {\n    key: \"setHandled\",\n    value: function setHandled() {\n      this._actionHandled = true;\n    }\n    /********************************************************************************\n     * Private methods\n     ********************************************************************************/\n\n  }, {\n    key: \"_clone\",\n    value: function _clone() {\n      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref2$copyState = _ref2.copyState,\n          copyState = _ref2$copyState === void 0 ? true : _ref2$copyState;\n\n      var cloned = new EventPropagator(this._componentList, {\n        logger: this.logger,\n        logPrefix: this._logPrefix\n      });\n\n      if (copyState) {\n        Object.assign(cloned, this);\n      }\n\n      return cloned;\n    }\n  }]);\n\n  return EventPropagator;\n}();\n\nexport default EventPropagator;"]},"metadata":{},"sourceType":"module"}