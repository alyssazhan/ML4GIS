{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport KeyEventStateArrayManager from '../shared/KeyEventStateArrayManager';\nimport indexFromEnd from '../../utils/array/indexFromEnd';\nimport KeyCombinationMatcher from './KeyCombinationMatcher';\nimport KeyEventState from '../../const/KeyEventState';\n/**\n * Matches a KeyHistory to a list of pre-registered ActionConfiguration and\n * their corresponding handler functions\n * @class\n */\n\nvar KeyHistoryMatcher = /*#__PURE__*/function () {\n  /**\n   * Returns a new instance of KeyMapMatcher\n   * @returns {KeyHistoryMatcher}\n   */\n  function KeyHistoryMatcher() {\n    _classCallCheck(this, KeyHistoryMatcher);\n\n    this._combinationMatchers = {};\n    this._eventRecord = KeyEventStateArrayManager.newRecord();\n  }\n  /**\n   * Adds a possible match that can be used to match key combination histories\n   * @param {ActionConfiguration} actionConfig The configuration object that\n   *        defines the action the possible match represents\n   * @param {Function} handler Function to call if the possible match is selected\n   *        when matching against a key combination history\n   * @returns {void}\n   */\n\n\n  _createClass(KeyHistoryMatcher, [{\n    key: \"addMatch\",\n    value: function addMatch(actionConfig, handler) {\n      var combinationMatcher = this._getOrCreateCombinationMatcher(actionConfig.prefix);\n\n      combinationMatcher.addMatch(actionConfig, handler);\n      /**\n       * Merge event records so we can quickly determine if a given component\n       * has any handlers bound to particular key events\n       */\n\n      KeyEventStateArrayManager.setBit(this._eventRecord, actionConfig.keyEventType, KeyEventState.seen);\n      /**\n       * Record the longest sequence length so we know to only check for sequences\n       * of that length or shorter for a particular component\n       */\n\n      if (!this._longestSequence || this._longestSequence < actionConfig.sequenceLength) {\n        this._longestSequence = actionConfig.sequenceLength;\n      }\n    }\n    /**\n     * Attempts to find a match from the list of possible matches previously registered\n     * for a given key event and key combination history\n     * @param {KeyHistory} keyHistory History to attempt to\n     *        find a match for\n     * @param {ReactKeyName} key Name of the key to find a match for\n     * @param {KeyEventType} keyEventType Type of event to find a match\n     * @returns {MatchingActionConfig|null} First MatchingActionOptions that matches\n     */\n\n  }, {\n    key: \"findMatch\",\n    value: function findMatch(keyHistory, key, keyEventType) {\n      var combinationMatcher = this._findCombinationMatcher(keyHistory);\n\n      if (combinationMatcher) {\n        return combinationMatcher.findMatch(keyHistory.getCurrentCombination(), keyHistory.getCurrentCombination().getNormalizedKeyName(key), keyEventType);\n      }\n\n      return null;\n    }\n    /**\n     * Whether a possible match has been registered for a key event type\n     * @param {KeyEventType} eventType Type of event\n     * @returns {boolean} true if at least one possible match has been registered for\n     *        the event\n     */\n\n  }, {\n    key: \"hasMatchesForEventType\",\n    value: function hasMatchesForEventType(eventType) {\n      return !!this._eventRecord[eventType];\n    }\n    /**\n     * The number of combinations involved for the ActionConfiguration with the longest\n     * key sequence\n     * @returns {number} Number of combinations in the longest sequence\n     */\n\n  }, {\n    key: \"getLongestSequence\",\n    value: function getLongestSequence() {\n      return this._longestSequence;\n    }\n    /********************************************************************************\n     * Presentation\n     ********************************************************************************/\n\n    /**\n     * A plain JavaScript representation of the KeyMapMatcher, useful for\n     * serialization or debugging\n     * @returns {Object} Serialized representation of the key map matcher\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var _this = this;\n\n      return Object.keys(this._combinationMatchers).reduce(function (memo, prefix) {\n        var combinationMatcher = _this._combinationMatchers[prefix];\n        memo[prefix] = combinationMatcher.toJSON();\n        return memo;\n      }, {});\n    }\n    /********************************************************************************\n     * Private methods\n     ********************************************************************************/\n\n  }, {\n    key: \"_getOrCreateCombinationMatcher\",\n    value: function _getOrCreateCombinationMatcher(prefix) {\n      if (!this._combinationMatchers[prefix]) {\n        this._combinationMatchers[prefix] = new KeyCombinationMatcher();\n      }\n\n      return this._combinationMatchers[prefix];\n    }\n  }, {\n    key: \"_findCombinationMatcher\",\n    value: function _findCombinationMatcher(keyHistory) {\n      var sequenceHistory = keyHistory.getMostRecentCombinations(this.getLongestSequence());\n\n      if (sequenceHistory.length === 0) {\n        return this._combinationMatchers[''];\n      }\n\n      var sequenceIds = sequenceHistory.map(function (keyCombination) {\n        return keyCombination.getIds();\n      });\n      var idSizes = sequenceIds.map(function (ids) {\n        return ids.length;\n      });\n      /**\n       * List of counters\n       * @type {number[]}\n       */\n\n      var indexCounters = new Array(sequenceIds.length).fill(0);\n      var triedAllPossiblePermutations = false;\n\n      while (!triedAllPossiblePermutations) {\n        var sequenceIdPermutation = indexCounters.map(function (sequenceIdIndex, index) {\n          return sequenceIds[index][sequenceIdIndex];\n        });\n        var candidateId = sequenceIdPermutation.join(' ');\n\n        if (this._combinationMatchers[candidateId]) {\n          return this._combinationMatchers[candidateId];\n        }\n\n        var incrementer = 0;\n        var carry = true;\n\n        while (carry && incrementer < indexCounters.length) {\n          var count = indexFromEnd(indexCounters, incrementer);\n          var newIndex = (count + 1) % (indexFromEnd(idSizes, incrementer) || 1);\n          indexCounters[indexCounters.length - (incrementer + 1)] = newIndex;\n          carry = newIndex === 0;\n\n          if (carry) {\n            incrementer++;\n          }\n        }\n\n        triedAllPossiblePermutations = incrementer === indexCounters.length;\n      }\n    }\n  }]);\n\n  return KeyHistoryMatcher;\n}();\n\nexport default KeyHistoryMatcher;","map":{"version":3,"sources":["/Users/yan/Documents/proj/ML4GIS/client/node_modules/react-hotkeys/es/lib/matching/KeyHistoryMatcher.js"],"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","KeyEventStateArrayManager","indexFromEnd","KeyCombinationMatcher","KeyEventState","KeyHistoryMatcher","_combinationMatchers","_eventRecord","newRecord","value","addMatch","actionConfig","handler","combinationMatcher","_getOrCreateCombinationMatcher","prefix","setBit","keyEventType","seen","_longestSequence","sequenceLength","findMatch","keyHistory","_findCombinationMatcher","getCurrentCombination","getNormalizedKeyName","hasMatchesForEventType","eventType","getLongestSequence","toJSON","_this","keys","reduce","memo","sequenceHistory","getMostRecentCombinations","sequenceIds","map","keyCombination","getIds","idSizes","ids","indexCounters","Array","fill","triedAllPossiblePermutations","sequenceIdPermutation","sequenceIdIndex","index","candidateId","join","incrementer","carry","count","newIndex"],"mappings":"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","sourcesContent":["function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nimport KeyEventStateArrayManager from '../shared/KeyEventStateArrayManager';\nimport indexFromEnd from '../../utils/array/indexFromEnd';\nimport KeyCombinationMatcher from './KeyCombinationMatcher';\nimport KeyEventState from '../../const/KeyEventState';\n/**\n * Matches a KeyHistory to a list of pre-registered ActionConfiguration and\n * their corresponding handler functions\n * @class\n */\n\nvar KeyHistoryMatcher =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Returns a new instance of KeyMapMatcher\n   * @returns {KeyHistoryMatcher}\n   */\n  function KeyHistoryMatcher() {\n    _classCallCheck(this, KeyHistoryMatcher);\n\n    this._combinationMatchers = {};\n    this._eventRecord = KeyEventStateArrayManager.newRecord();\n  }\n  /**\n   * Adds a possible match that can be used to match key combination histories\n   * @param {ActionConfiguration} actionConfig The configuration object that\n   *        defines the action the possible match represents\n   * @param {Function} handler Function to call if the possible match is selected\n   *        when matching against a key combination history\n   * @returns {void}\n   */\n\n\n  _createClass(KeyHistoryMatcher, [{\n    key: \"addMatch\",\n    value: function addMatch(actionConfig, handler) {\n      var combinationMatcher = this._getOrCreateCombinationMatcher(actionConfig.prefix);\n\n      combinationMatcher.addMatch(actionConfig, handler);\n      /**\n       * Merge event records so we can quickly determine if a given component\n       * has any handlers bound to particular key events\n       */\n\n      KeyEventStateArrayManager.setBit(this._eventRecord, actionConfig.keyEventType, KeyEventState.seen);\n      /**\n       * Record the longest sequence length so we know to only check for sequences\n       * of that length or shorter for a particular component\n       */\n\n      if (!this._longestSequence || this._longestSequence < actionConfig.sequenceLength) {\n        this._longestSequence = actionConfig.sequenceLength;\n      }\n    }\n    /**\n     * Attempts to find a match from the list of possible matches previously registered\n     * for a given key event and key combination history\n     * @param {KeyHistory} keyHistory History to attempt to\n     *        find a match for\n     * @param {ReactKeyName} key Name of the key to find a match for\n     * @param {KeyEventType} keyEventType Type of event to find a match\n     * @returns {MatchingActionConfig|null} First MatchingActionOptions that matches\n     */\n\n  }, {\n    key: \"findMatch\",\n    value: function findMatch(keyHistory, key, keyEventType) {\n      var combinationMatcher = this._findCombinationMatcher(keyHistory);\n\n      if (combinationMatcher) {\n        return combinationMatcher.findMatch(keyHistory.getCurrentCombination(), keyHistory.getCurrentCombination().getNormalizedKeyName(key), keyEventType);\n      }\n\n      return null;\n    }\n    /**\n     * Whether a possible match has been registered for a key event type\n     * @param {KeyEventType} eventType Type of event\n     * @returns {boolean} true if at least one possible match has been registered for\n     *        the event\n     */\n\n  }, {\n    key: \"hasMatchesForEventType\",\n    value: function hasMatchesForEventType(eventType) {\n      return !!this._eventRecord[eventType];\n    }\n    /**\n     * The number of combinations involved for the ActionConfiguration with the longest\n     * key sequence\n     * @returns {number} Number of combinations in the longest sequence\n     */\n\n  }, {\n    key: \"getLongestSequence\",\n    value: function getLongestSequence() {\n      return this._longestSequence;\n    }\n    /********************************************************************************\n     * Presentation\n     ********************************************************************************/\n\n    /**\n     * A plain JavaScript representation of the KeyMapMatcher, useful for\n     * serialization or debugging\n     * @returns {Object} Serialized representation of the key map matcher\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var _this = this;\n\n      return Object.keys(this._combinationMatchers).reduce(function (memo, prefix) {\n        var combinationMatcher = _this._combinationMatchers[prefix];\n        memo[prefix] = combinationMatcher.toJSON();\n        return memo;\n      }, {});\n    }\n    /********************************************************************************\n     * Private methods\n     ********************************************************************************/\n\n  }, {\n    key: \"_getOrCreateCombinationMatcher\",\n    value: function _getOrCreateCombinationMatcher(prefix) {\n      if (!this._combinationMatchers[prefix]) {\n        this._combinationMatchers[prefix] = new KeyCombinationMatcher();\n      }\n\n      return this._combinationMatchers[prefix];\n    }\n  }, {\n    key: \"_findCombinationMatcher\",\n    value: function _findCombinationMatcher(keyHistory) {\n      var sequenceHistory = keyHistory.getMostRecentCombinations(this.getLongestSequence());\n\n      if (sequenceHistory.length === 0) {\n        return this._combinationMatchers[''];\n      }\n\n      var sequenceIds = sequenceHistory.map(function (keyCombination) {\n        return keyCombination.getIds();\n      });\n      var idSizes = sequenceIds.map(function (ids) {\n        return ids.length;\n      });\n      /**\n       * List of counters\n       * @type {number[]}\n       */\n\n      var indexCounters = new Array(sequenceIds.length).fill(0);\n      var triedAllPossiblePermutations = false;\n\n      while (!triedAllPossiblePermutations) {\n        var sequenceIdPermutation = indexCounters.map(function (sequenceIdIndex, index) {\n          return sequenceIds[index][sequenceIdIndex];\n        });\n        var candidateId = sequenceIdPermutation.join(' ');\n\n        if (this._combinationMatchers[candidateId]) {\n          return this._combinationMatchers[candidateId];\n        }\n\n        var incrementer = 0;\n        var carry = true;\n\n        while (carry && incrementer < indexCounters.length) {\n          var count = indexFromEnd(indexCounters, incrementer);\n          var newIndex = (count + 1) % (indexFromEnd(idSizes, incrementer) || 1);\n          indexCounters[indexCounters.length - (incrementer + 1)] = newIndex;\n          carry = newIndex === 0;\n\n          if (carry) {\n            incrementer++;\n          }\n        }\n\n        triedAllPossiblePermutations = incrementer === indexCounters.length;\n      }\n    }\n  }]);\n\n  return KeyHistoryMatcher;\n}();\n\nexport default KeyHistoryMatcher;"]},"metadata":{},"sourceType":"module"}