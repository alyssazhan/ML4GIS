{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport KeyEventSequenceIndex from '../../const/KeyEventSequenceIndex';\nimport KeyEventType from '../../const/KeyEventType';\nimport KeyCombinationSerializer from '../shared/KeyCombinationSerializer';\nimport resolveKeyAlias from '../../helpers/resolving-handlers/resolveKeyAlias';\nimport applicableAliasFunctions from '../../helpers/resolving-handlers/applicableAliasFunctions';\nimport KeyEventStateArrayManager from '../shared/KeyEventStateArrayManager';\nimport isEmpty from '../../utils/collection/isEmpty';\nimport size from '../../utils/collection/size';\nimport KeyEventState from '../../const/KeyEventState';\nimport dictionaryFrom from '../../utils/object/dictionaryFrom';\n/**\n * Record of one or more keys pressed together, in a combination\n * @class\n */\n\nvar KeyCombination = /*#__PURE__*/function () {\n  /**\n   * Creates a new KeyCombination instance\n   * @param {Object.<ReactKeyName, Array.<KeyEventState[]>>} keys Dictionary\n   *        of keys\n   * @returns {KeyCombination}\n   */\n  function KeyCombination() {\n    var keys = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, KeyCombination);\n\n    this._keys = keys;\n    this._includesKeyUp = false;\n\n    this._update();\n  }\n  /********************************************************************************\n   * Getters\n   *********************************************************************************/\n\n  /**\n   * List of ids (serialized representations) for the keys involved in the combination\n   * @returns {KeySequence[]} List of combination ids\n   */\n\n\n  _createClass(KeyCombination, [{\n    key: \"getIds\",\n    value: function getIds() {\n      return this._ids;\n    }\n    /**\n     * Dictionary mapping keys to their acceptable aliases. This includes \"shifted\" or\n     * \"alted\" key characters.\n     * @returns {Object.<ReactKeyName, ReactKeyName[]>}\n     */\n\n  }, {\n    key: \"getKeyAliases\",\n    value: function getKeyAliases() {\n      return this._keyAliases;\n    }\n    /**\n     * A normalized version of the key, achieved by comparing it to the list of known\n     * aliases for the keys in the combination\n     * @param {ReactKeyName} keyName Name of the key to normalize\n     * @returns {ReactKeyName} Normalized key name\n     */\n\n  }, {\n    key: \"getNormalizedKeyName\",\n    value: function getNormalizedKeyName(keyName) {\n      var keyState = this._keys[keyName];\n\n      if (keyState) {\n        return keyName;\n      } else {\n        var keyAlias = this._keyAliases[keyName];\n\n        if (keyAlias) {\n          return keyAlias;\n        } else {\n          return keyName;\n        }\n      }\n    }\n    /********************************************************************************\n     * Query attributes of entire combination\n     *********************************************************************************/\n\n    /**\n     * Number of keys involved in the combination\n     * @returns {number} Number of keys\n     */\n\n  }, {\n    key: \"getNumberOfKeys\",\n    value: function getNumberOfKeys() {\n      return size(this._keys);\n    }\n    /**\n     * Whether there are any keys in the combination\n     * @returns {boolean} true if there is 1 or more keys involved in the combination,\n     *          else false.\n     */\n\n  }, {\n    key: \"any\",\n    value: function any() {\n      return Object.keys(this._getKeyStates()).length > 0;\n    }\n    /**\n     * Whether any of the keys in the combination have been released\n     * @returns {boolean} true if at least 1 key has been released in the combination\n     */\n\n  }, {\n    key: \"isEnding\",\n    value: function isEnding() {\n      return this._includesKeyUp;\n    }\n    /**\n     * Whether there are any keys in the current combination still being pressed\n     * @returns {boolean} True if all keys in the current combination are released\n     */\n\n  }, {\n    key: \"hasEnded\",\n    value: function hasEnded() {\n      return isEmpty(this.keysStillPressedDict());\n    }\n    /********************************************************************************\n     * Adding & modifying key states\n     *********************************************************************************/\n\n    /**\n     * Add a new key to the combination (starting with a state of keydown)\n     * @param {ReactKeyName} keyName Name of key\n     * @param {KeyEventState} keyEventState State key is in\n     * @returns {void}\n     */\n\n  }, {\n    key: \"addKey\",\n    value: function addKey(keyName, keyEventState) {\n      this._setKeyState(keyName, [KeyEventStateArrayManager.newRecord(), KeyEventStateArrayManager.newRecord(KeyEventType.keydown, keyEventState)]);\n    }\n    /**\n     * Adds a key event to the current key combination (as opposed to starting a new\n     * keyboard combination).\n     * @param {ReactKeyName} keyName - Name of the key to add to the current combination\n     * @param {KeyEventType} recordIndex - Index in record to set to true\n     * @param {KeyEventState} keyEventState The state to set the key event to\n     */\n\n  }, {\n    key: \"setKeyState\",\n    value: function setKeyState(keyName, recordIndex, keyEventState) {\n      var existingRecord = this._getKeyState(keyName);\n\n      if (this.isKeyIncluded(keyName)) {\n        var previous = KeyEventStateArrayManager.clone(existingRecord[1]);\n        var current = KeyEventStateArrayManager.clone(previous);\n        KeyEventStateArrayManager.setBit(current, recordIndex, keyEventState);\n\n        this._setKeyState(keyName, [previous, current]);\n      } else {\n        this.addKey(keyName, keyEventState);\n      }\n\n      if (recordIndex === KeyEventType.keyup) {\n        this._includesKeyUp = true;\n      }\n    }\n    /********************************************************************************\n     * Iteration and subsets\n     *********************************************************************************/\n\n    /**\n     * @callback forEachHandler\n     * @param {ReactKeyName} keyName Name of a key in the combination\n     * @returns {void}\n     */\n\n    /**\n     * Iterates over every key in the combination, calling an function with each\n     * key name\n     * @param {forEachHandler} handler Function to call with the name of each key\n     *        in the combination\n     * @returns {void}\n     */\n\n  }, {\n    key: \"forEachKey\",\n    value: function forEachKey(handler) {\n      return Object.keys(this._keys).forEach(handler);\n    }\n    /**\n     * @callback evaluator\n     * @param {ReactKeyName} keyName Name of a key in the combination\n     * @returns {boolean}\n     */\n\n    /**\n     * Whether at least one of the keys causes a evaluator function to return true\n     * @callback {evaluator} evaluator Function to evaluate each key\n     * @returns {boolean} Whether at least one key satisfies the evaluator\n     */\n\n  }, {\n    key: \"some\",\n    value: function some(evaluator) {\n      return Object.keys(this._keys).some(evaluator);\n    }\n    /**\n     * Dictionary of keys included in the combination record\n     * @returns {Object.<ReactKeyName, boolean>}\n     */\n\n  }, {\n    key: \"getKeyDictionary\",\n    value: function getKeyDictionary() {\n      return dictionaryFrom(Object.keys(this._getKeyStates()), true);\n    }\n    /**\n     * Returns a new KeyCombination without the keys that have been\n     * released (had the keyup event recorded). Essentially, the keys that are\n     * currently still pressed down at the time a key event is being handled.\n     * @returns {KeyCombination} New KeyCombination with all of the\n     *        keys with keyup events omitted\n     */\n\n  }, {\n    key: \"keysStillPressedDict\",\n    value: function keysStillPressedDict() {\n      var _this = this;\n\n      return Object.keys(this._keys).reduce(function (memo, keyName) {\n        if (_this.isKeyStillPressed(keyName)) {\n          memo[keyName] = _this._getKeyState(keyName);\n        }\n\n        return memo;\n      }, {});\n    }\n    /********************************************************************************\n     * Query individual keys\n     *********************************************************************************/\n\n    /**\n     * Whether key is in the combination\n     * @param {ReactKeyName} keyName Name of key\n     * @returns {boolean} true if the key is in the combination\n     */\n\n  }, {\n    key: \"isKeyIncluded\",\n    value: function isKeyIncluded(keyName) {\n      return !!this._getKeyState(keyName);\n    }\n    /**\n     * Whether key is in the combination and has yet to be released\n     * @param {ReactKeyName} keyName Name of key\n     * @returns {boolean} true if the key is in the combination and yet to be released\n     */\n\n  }, {\n    key: \"isKeyStillPressed\",\n    value: function isKeyStillPressed(keyName) {\n      return this.isEventTriggered(keyName, KeyEventType.keypress) && !this.isKeyReleased(keyName);\n    }\n    /**\n     * Whether key is in the combination and been released\n     * @param {ReactKeyName} keyName Name of key\n     * @returns {boolean} true if the key is in the combination and has been released\n     */\n\n  }, {\n    key: \"isKeyReleased\",\n    value: function isKeyReleased(keyName) {\n      return this.isEventTriggered(keyName, KeyEventType.keyup);\n    }\n    /**\n     * Whether an event has been recorded for a key yet\n     * @param {ReactKeyName} keyName Name of the key\n     * @param {KeyEventType} keyEventType Index of the event type\n     * @returns {boolean} true if the event has been recorded for the key\n     */\n\n  }, {\n    key: \"isEventTriggered\",\n    value: function isEventTriggered(keyName, keyEventType) {\n      return this._getKeyStateType(keyName, KeyEventSequenceIndex.current, keyEventType);\n    }\n    /**\n     * Whether an event has been previously recorded for a key (the second most recent\n     * event to occur for the key)\n     * @param {ReactKeyName} keyName Name of the key\n     * @param {KeyEventType} keyEventType Index of the event type\n     * @returns {boolean} true if the event has been previously recorded for the key\n     */\n\n  }, {\n    key: \"wasEventPreviouslyTriggered\",\n    value: function wasEventPreviouslyTriggered(keyName, keyEventType) {\n      return this._getKeyStateType(keyName, KeyEventSequenceIndex.previous, keyEventType);\n    }\n    /**\n     * Whether a keypress event is currently being simulated\n     * @param {ReactKeyName} keyName Name of the key\n     * @returns {boolean} true if the keypress event is currently being simulated for the\n     *        key\n     */\n\n  }, {\n    key: \"isKeyPressSimulated\",\n    value: function isKeyPressSimulated(keyName) {\n      return this._isKeyEventSimulated(keyName, KeyEventType.keypress);\n    }\n    /**\n     * Whether a keyup event is currently being simulated\n     * @param {ReactKeyName} keyName Name of the key\n     * @returns {boolean} true if the keyup event is currently being simulated for the\n     *        key\n     */\n\n  }, {\n    key: \"isKeyUpSimulated\",\n    value: function isKeyUpSimulated(keyName) {\n      return this._isKeyEventSimulated(keyName, KeyEventType.keyup);\n    }\n    /********************************************************************************\n     * Presentation\n     *********************************************************************************/\n\n    /**\n     * Return a serialized description of the keys in the combination\n     * @returns {KeySequence}\n     */\n\n  }, {\n    key: \"describe\",\n    value: function describe() {\n      return this.getIds()[0];\n    }\n    /**\n     * A plain JavaScript representation of the key combination record, useful for\n     * serialization or debugging\n     * @returns {Object} Serialized representation of the combination record\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        keys: this._getKeyStates(),\n        ids: this.getIds(),\n        keyAliases: this.getKeyAliases()\n      };\n    }\n    /********************************************************************************\n     * Private methods\n     *********************************************************************************/\n\n  }, {\n    key: \"_getKeyStateType\",\n    value: function _getKeyStateType(keyName, keyStage, keyEventType) {\n      var keyState = this._getKeyState(keyName);\n\n      return keyState && keyState[keyStage][keyEventType];\n    }\n  }, {\n    key: \"_update\",\n    value: function _update() {\n      this._ids = KeyCombinationSerializer.serialize(this._keys);\n      this._keyAliases = buildKeyAliases(this._keys);\n    }\n  }, {\n    key: \"_isKeyEventSimulated\",\n    value: function _isKeyEventSimulated(keyName, keyEventType) {\n      return this.isEventTriggered(keyName, keyEventType) === KeyEventState.simulated;\n    }\n  }, {\n    key: \"_getKeyStates\",\n    value: function _getKeyStates() {\n      return this._keys;\n    }\n  }, {\n    key: \"_getKeyState\",\n    value: function _getKeyState(keyName) {\n      var keyState = this._keys[keyName];\n\n      if (keyState) {\n        return keyState;\n      } else {\n        var keyAlias = this._keyAliases[keyName];\n\n        if (keyAlias) {\n          return this._keys[keyAlias];\n        }\n      }\n    }\n  }, {\n    key: \"_setKeyState\",\n    value: function _setKeyState(keyName, keyState) {\n      var keyAlias = this.getNormalizedKeyName(keyName);\n      this._keys[keyAlias] = keyState;\n\n      this._update();\n    }\n  }]);\n\n  return KeyCombination;\n}();\n\nfunction buildKeyAliases(keyDictionary) {\n  return Object.keys(keyDictionary).reduce(function (memo, keyName) {\n    resolveKeyAlias(keyName).forEach(function (normalizedKey) {\n      applicableAliasFunctions(keyDictionary).forEach(function (aliasFunction) {\n        aliasFunction(normalizedKey).forEach(function (keyAlias) {\n          if (keyAlias !== keyName || keyName !== normalizedKey) {\n            memo[keyAlias] = keyName;\n          }\n        });\n      });\n    });\n    return memo;\n  }, {});\n}\n\nexport default KeyCombination;","map":{"version":3,"sources":["/Users/yan/Documents/proj/ML4GIS/client/node_modules/react-hotkeys/es/lib/listening/KeyCombination.js"],"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","KeyEventSequenceIndex","KeyEventType","KeyCombinationSerializer","resolveKeyAlias","applicableAliasFunctions","KeyEventStateArrayManager","isEmpty","size","KeyEventState","dictionaryFrom","KeyCombination","keys","arguments","undefined","_keys","_includesKeyUp","_update","value","getIds","_ids","getKeyAliases","_keyAliases","getNormalizedKeyName","keyName","keyState","keyAlias","getNumberOfKeys","any","_getKeyStates","isEnding","hasEnded","keysStillPressedDict","addKey","keyEventState","_setKeyState","newRecord","keydown","setKeyState","recordIndex","existingRecord","_getKeyState","isKeyIncluded","previous","clone","current","setBit","keyup","forEachKey","handler","forEach","some","evaluator","getKeyDictionary","_this","reduce","memo","isKeyStillPressed","isEventTriggered","keypress","isKeyReleased","keyEventType","_getKeyStateType","wasEventPreviouslyTriggered","isKeyPressSimulated","_isKeyEventSimulated","isKeyUpSimulated","describe","toJSON","ids","keyAliases","keyStage","serialize","buildKeyAliases","simulated","keyDictionary","normalizedKey","aliasFunction"],"mappings":"AAAA,SAASA,eAAT,CAAyBC,QAAzB,EAAmCC,WAAnC,EAAgD;AAAE,MAAI,EAAED,QAAQ,YAAYC,WAAtB,CAAJ,EAAwC;AAAE,UAAM,IAAIC,SAAJ,CAAc,mCAAd,CAAN;AAA2D;AAAE;;AAEzJ,SAASC,iBAAT,CAA2BC,MAA3B,EAAmCC,KAAnC,EAA0C;AAAE,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,KAAK,CAACE,MAA1B,EAAkCD,CAAC,EAAnC,EAAuC;AAAE,QAAIE,UAAU,GAAGH,KAAK,CAACC,CAAD,CAAtB;AAA2BE,IAAAA,UAAU,CAACC,UAAX,GAAwBD,UAAU,CAACC,UAAX,IAAyB,KAAjD;AAAwDD,IAAAA,UAAU,CAACE,YAAX,GAA0B,IAA1B;AAAgC,QAAI,WAAWF,UAAf,EAA2BA,UAAU,CAACG,QAAX,GAAsB,IAAtB;AAA4BC,IAAAA,MAAM,CAACC,cAAP,CAAsBT,MAAtB,EAA8BI,UAAU,CAACM,GAAzC,EAA8CN,UAA9C;AAA4D;AAAE;;AAE7T,SAASO,YAAT,CAAsBd,WAAtB,EAAmCe,UAAnC,EAA+CC,WAA/C,EAA4D;AAAE,MAAID,UAAJ,EAAgBb,iBAAiB,CAACF,WAAW,CAACiB,SAAb,EAAwBF,UAAxB,CAAjB;AAAsD,MAAIC,WAAJ,EAAiBd,iBAAiB,CAACF,WAAD,EAAcgB,WAAd,CAAjB;AAA6C,SAAOhB,WAAP;AAAqB;;AAEvN,OAAOkB,qBAAP,MAAkC,mCAAlC;AACA,OAAOC,YAAP,MAAyB,0BAAzB;AACA,OAAOC,wBAAP,MAAqC,oCAArC;AACA,OAAOC,eAAP,MAA4B,kDAA5B;AACA,OAAOC,wBAAP,MAAqC,2DAArC;AACA,OAAOC,yBAAP,MAAsC,qCAAtC;AACA,OAAOC,OAAP,MAAoB,gCAApB;AACA,OAAOC,IAAP,MAAiB,6BAAjB;AACA,OAAOC,aAAP,MAA0B,2BAA1B;AACA,OAAOC,cAAP,MAA2B,mCAA3B;AACA;AACA;AACA;AACA;;AAEA,IAAIC,cAAc,GAClB,aACA,YAAY;AACV;AACF;AACA;AACA;AACA;AACA;AACE,WAASA,cAAT,GAA0B;AACxB,QAAIC,IAAI,GAAGC,SAAS,CAACxB,MAAV,GAAmB,CAAnB,IAAwBwB,SAAS,CAAC,CAAD,CAAT,KAAiBC,SAAzC,GAAqDD,SAAS,CAAC,CAAD,CAA9D,GAAoE,EAA/E;;AAEAhC,IAAAA,eAAe,CAAC,IAAD,EAAO8B,cAAP,CAAf;;AAEA,SAAKI,KAAL,GAAaH,IAAb;AACA,SAAKI,cAAL,GAAsB,KAAtB;;AAEA,SAAKC,OAAL;AACD;AACD;AACF;AACA;;AAEE;AACF;AACA;AACA;;;AAGEpB,EAAAA,YAAY,CAACc,cAAD,EAAiB,CAAC;AAC5Bf,IAAAA,GAAG,EAAE,QADuB;AAE5BsB,IAAAA,KAAK,EAAE,SAASC,MAAT,GAAkB;AACvB,aAAO,KAAKC,IAAZ;AACD;AACD;AACJ;AACA;AACA;AACA;;AATgC,GAAD,EAW1B;AACDxB,IAAAA,GAAG,EAAE,eADJ;AAEDsB,IAAAA,KAAK,EAAE,SAASG,aAAT,GAAyB;AAC9B,aAAO,KAAKC,WAAZ;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;;AAVK,GAX0B,EAuB1B;AACD1B,IAAAA,GAAG,EAAE,sBADJ;AAEDsB,IAAAA,KAAK,EAAE,SAASK,oBAAT,CAA8BC,OAA9B,EAAuC;AAC5C,UAAIC,QAAQ,GAAG,KAAKV,KAAL,CAAWS,OAAX,CAAf;;AAEA,UAAIC,QAAJ,EAAc;AACZ,eAAOD,OAAP;AACD,OAFD,MAEO;AACL,YAAIE,QAAQ,GAAG,KAAKJ,WAAL,CAAiBE,OAAjB,CAAf;;AAEA,YAAIE,QAAJ,EAAc;AACZ,iBAAOA,QAAP;AACD,SAFD,MAEO;AACL,iBAAOF,OAAP;AACD;AACF;AACF;AACD;AACJ;AACA;;AAEI;AACJ;AACA;AACA;;AAxBK,GAvB0B,EAiD1B;AACD5B,IAAAA,GAAG,EAAE,iBADJ;AAEDsB,IAAAA,KAAK,EAAE,SAASS,eAAT,GAA2B;AAChC,aAAOnB,IAAI,CAAC,KAAKO,KAAN,CAAX;AACD;AACD;AACJ;AACA;AACA;AACA;;AATK,GAjD0B,EA4D1B;AACDnB,IAAAA,GAAG,EAAE,KADJ;AAEDsB,IAAAA,KAAK,EAAE,SAASU,GAAT,GAAe;AACpB,aAAOlC,MAAM,CAACkB,IAAP,CAAY,KAAKiB,aAAL,EAAZ,EAAkCxC,MAAlC,GAA2C,CAAlD;AACD;AACD;AACJ;AACA;AACA;;AARK,GA5D0B,EAsE1B;AACDO,IAAAA,GAAG,EAAE,UADJ;AAEDsB,IAAAA,KAAK,EAAE,SAASY,QAAT,GAAoB;AACzB,aAAO,KAAKd,cAAZ;AACD;AACD;AACJ;AACA;AACA;;AARK,GAtE0B,EAgF1B;AACDpB,IAAAA,GAAG,EAAE,UADJ;AAEDsB,IAAAA,KAAK,EAAE,SAASa,QAAT,GAAoB;AACzB,aAAOxB,OAAO,CAAC,KAAKyB,oBAAL,EAAD,CAAd;AACD;AACD;AACJ;AACA;;AAEI;AACJ;AACA;AACA;AACA;AACA;;AAdK,GAhF0B,EAgG1B;AACDpC,IAAAA,GAAG,EAAE,QADJ;AAEDsB,IAAAA,KAAK,EAAE,SAASe,MAAT,CAAgBT,OAAhB,EAAyBU,aAAzB,EAAwC;AAC7C,WAAKC,YAAL,CAAkBX,OAAlB,EAA2B,CAAClB,yBAAyB,CAAC8B,SAA1B,EAAD,EAAwC9B,yBAAyB,CAAC8B,SAA1B,CAAoClC,YAAY,CAACmC,OAAjD,EAA0DH,aAA1D,CAAxC,CAA3B;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;;AAXK,GAhG0B,EA6G1B;AACDtC,IAAAA,GAAG,EAAE,aADJ;AAEDsB,IAAAA,KAAK,EAAE,SAASoB,WAAT,CAAqBd,OAArB,EAA8Be,WAA9B,EAA2CL,aAA3C,EAA0D;AAC/D,UAAIM,cAAc,GAAG,KAAKC,YAAL,CAAkBjB,OAAlB,CAArB;;AAEA,UAAI,KAAKkB,aAAL,CAAmBlB,OAAnB,CAAJ,EAAiC;AAC/B,YAAImB,QAAQ,GAAGrC,yBAAyB,CAACsC,KAA1B,CAAgCJ,cAAc,CAAC,CAAD,CAA9C,CAAf;AACA,YAAIK,OAAO,GAAGvC,yBAAyB,CAACsC,KAA1B,CAAgCD,QAAhC,CAAd;AACArC,QAAAA,yBAAyB,CAACwC,MAA1B,CAAiCD,OAAjC,EAA0CN,WAA1C,EAAuDL,aAAvD;;AAEA,aAAKC,YAAL,CAAkBX,OAAlB,EAA2B,CAACmB,QAAD,EAAWE,OAAX,CAA3B;AACD,OAND,MAMO;AACL,aAAKZ,MAAL,CAAYT,OAAZ,EAAqBU,aAArB;AACD;;AAED,UAAIK,WAAW,KAAKrC,YAAY,CAAC6C,KAAjC,EAAwC;AACtC,aAAK/B,cAAL,GAAsB,IAAtB;AACD;AACF;AACD;AACJ;AACA;;AAEI;AACJ;AACA;AACA;AACA;;AAEI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAnCK,GA7G0B,EAkJ1B;AACDpB,IAAAA,GAAG,EAAE,YADJ;AAEDsB,IAAAA,KAAK,EAAE,SAAS8B,UAAT,CAAoBC,OAApB,EAA6B;AAClC,aAAOvD,MAAM,CAACkB,IAAP,CAAY,KAAKG,KAAjB,EAAwBmC,OAAxB,CAAgCD,OAAhC,CAAP;AACD;AACD;AACJ;AACA;AACA;AACA;;AAEI;AACJ;AACA;AACA;AACA;;AAfK,GAlJ0B,EAmK1B;AACDrD,IAAAA,GAAG,EAAE,MADJ;AAEDsB,IAAAA,KAAK,EAAE,SAASiC,IAAT,CAAcC,SAAd,EAAyB;AAC9B,aAAO1D,MAAM,CAACkB,IAAP,CAAY,KAAKG,KAAjB,EAAwBoC,IAAxB,CAA6BC,SAA7B,CAAP;AACD;AACD;AACJ;AACA;AACA;;AARK,GAnK0B,EA6K1B;AACDxD,IAAAA,GAAG,EAAE,kBADJ;AAEDsB,IAAAA,KAAK,EAAE,SAASmC,gBAAT,GAA4B;AACjC,aAAO3C,cAAc,CAAChB,MAAM,CAACkB,IAAP,CAAY,KAAKiB,aAAL,EAAZ,CAAD,EAAoC,IAApC,CAArB;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;;AAXK,GA7K0B,EA0L1B;AACDjC,IAAAA,GAAG,EAAE,sBADJ;AAEDsB,IAAAA,KAAK,EAAE,SAASc,oBAAT,GAAgC;AACrC,UAAIsB,KAAK,GAAG,IAAZ;;AAEA,aAAO5D,MAAM,CAACkB,IAAP,CAAY,KAAKG,KAAjB,EAAwBwC,MAAxB,CAA+B,UAAUC,IAAV,EAAgBhC,OAAhB,EAAyB;AAC7D,YAAI8B,KAAK,CAACG,iBAAN,CAAwBjC,OAAxB,CAAJ,EAAsC;AACpCgC,UAAAA,IAAI,CAAChC,OAAD,CAAJ,GAAgB8B,KAAK,CAACb,YAAN,CAAmBjB,OAAnB,CAAhB;AACD;;AAED,eAAOgC,IAAP;AACD,OANM,EAMJ,EANI,CAAP;AAOD;AACD;AACJ;AACA;;AAEI;AACJ;AACA;AACA;AACA;;AArBK,GA1L0B,EAiN1B;AACD5D,IAAAA,GAAG,EAAE,eADJ;AAEDsB,IAAAA,KAAK,EAAE,SAASwB,aAAT,CAAuBlB,OAAvB,EAAgC;AACrC,aAAO,CAAC,CAAC,KAAKiB,YAAL,CAAkBjB,OAAlB,CAAT;AACD;AACD;AACJ;AACA;AACA;AACA;;AATK,GAjN0B,EA4N1B;AACD5B,IAAAA,GAAG,EAAE,mBADJ;AAEDsB,IAAAA,KAAK,EAAE,SAASuC,iBAAT,CAA2BjC,OAA3B,EAAoC;AACzC,aAAO,KAAKkC,gBAAL,CAAsBlC,OAAtB,EAA+BtB,YAAY,CAACyD,QAA5C,KAAyD,CAAC,KAAKC,aAAL,CAAmBpC,OAAnB,CAAjE;AACD;AACD;AACJ;AACA;AACA;AACA;;AATK,GA5N0B,EAuO1B;AACD5B,IAAAA,GAAG,EAAE,eADJ;AAEDsB,IAAAA,KAAK,EAAE,SAAS0C,aAAT,CAAuBpC,OAAvB,EAAgC;AACrC,aAAO,KAAKkC,gBAAL,CAAsBlC,OAAtB,EAA+BtB,YAAY,CAAC6C,KAA5C,CAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;;AAVK,GAvO0B,EAmP1B;AACDnD,IAAAA,GAAG,EAAE,kBADJ;AAEDsB,IAAAA,KAAK,EAAE,SAASwC,gBAAT,CAA0BlC,OAA1B,EAAmCqC,YAAnC,EAAiD;AACtD,aAAO,KAAKC,gBAAL,CAAsBtC,OAAtB,EAA+BvB,qBAAqB,CAAC4C,OAArD,EAA8DgB,YAA9D,CAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;;AAXK,GAnP0B,EAgQ1B;AACDjE,IAAAA,GAAG,EAAE,6BADJ;AAEDsB,IAAAA,KAAK,EAAE,SAAS6C,2BAAT,CAAqCvC,OAArC,EAA8CqC,YAA9C,EAA4D;AACjE,aAAO,KAAKC,gBAAL,CAAsBtC,OAAtB,EAA+BvB,qBAAqB,CAAC0C,QAArD,EAA+DkB,YAA/D,CAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;;AAVK,GAhQ0B,EA4Q1B;AACDjE,IAAAA,GAAG,EAAE,qBADJ;AAEDsB,IAAAA,KAAK,EAAE,SAAS8C,mBAAT,CAA6BxC,OAA7B,EAAsC;AAC3C,aAAO,KAAKyC,oBAAL,CAA0BzC,OAA1B,EAAmCtB,YAAY,CAACyD,QAAhD,CAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;;AAVK,GA5Q0B,EAwR1B;AACD/D,IAAAA,GAAG,EAAE,kBADJ;AAEDsB,IAAAA,KAAK,EAAE,SAASgD,gBAAT,CAA0B1C,OAA1B,EAAmC;AACxC,aAAO,KAAKyC,oBAAL,CAA0BzC,OAA1B,EAAmCtB,YAAY,CAAC6C,KAAhD,CAAP;AACD;AACD;AACJ;AACA;;AAEI;AACJ;AACA;AACA;;AAZK,GAxR0B,EAsS1B;AACDnD,IAAAA,GAAG,EAAE,UADJ;AAEDsB,IAAAA,KAAK,EAAE,SAASiD,QAAT,GAAoB;AACzB,aAAO,KAAKhD,MAAL,GAAc,CAAd,CAAP;AACD;AACD;AACJ;AACA;AACA;AACA;;AATK,GAtS0B,EAiT1B;AACDvB,IAAAA,GAAG,EAAE,QADJ;AAEDsB,IAAAA,KAAK,EAAE,SAASkD,MAAT,GAAkB;AACvB,aAAO;AACLxD,QAAAA,IAAI,EAAE,KAAKiB,aAAL,EADD;AAELwC,QAAAA,GAAG,EAAE,KAAKlD,MAAL,EAFA;AAGLmD,QAAAA,UAAU,EAAE,KAAKjD,aAAL;AAHP,OAAP;AAKD;AACD;AACJ;AACA;;AAXK,GAjT0B,EA8T1B;AACDzB,IAAAA,GAAG,EAAE,kBADJ;AAEDsB,IAAAA,KAAK,EAAE,SAAS4C,gBAAT,CAA0BtC,OAA1B,EAAmC+C,QAAnC,EAA6CV,YAA7C,EAA2D;AAChE,UAAIpC,QAAQ,GAAG,KAAKgB,YAAL,CAAkBjB,OAAlB,CAAf;;AAEA,aAAOC,QAAQ,IAAIA,QAAQ,CAAC8C,QAAD,CAAR,CAAmBV,YAAnB,CAAnB;AACD;AANA,GA9T0B,EAqU1B;AACDjE,IAAAA,GAAG,EAAE,SADJ;AAEDsB,IAAAA,KAAK,EAAE,SAASD,OAAT,GAAmB;AACxB,WAAKG,IAAL,GAAYjB,wBAAwB,CAACqE,SAAzB,CAAmC,KAAKzD,KAAxC,CAAZ;AACA,WAAKO,WAAL,GAAmBmD,eAAe,CAAC,KAAK1D,KAAN,CAAlC;AACD;AALA,GArU0B,EA2U1B;AACDnB,IAAAA,GAAG,EAAE,sBADJ;AAEDsB,IAAAA,KAAK,EAAE,SAAS+C,oBAAT,CAA8BzC,OAA9B,EAAuCqC,YAAvC,EAAqD;AAC1D,aAAO,KAAKH,gBAAL,CAAsBlC,OAAtB,EAA+BqC,YAA/B,MAAiDpD,aAAa,CAACiE,SAAtE;AACD;AAJA,GA3U0B,EAgV1B;AACD9E,IAAAA,GAAG,EAAE,eADJ;AAEDsB,IAAAA,KAAK,EAAE,SAASW,aAAT,GAAyB;AAC9B,aAAO,KAAKd,KAAZ;AACD;AAJA,GAhV0B,EAqV1B;AACDnB,IAAAA,GAAG,EAAE,cADJ;AAEDsB,IAAAA,KAAK,EAAE,SAASuB,YAAT,CAAsBjB,OAAtB,EAA+B;AACpC,UAAIC,QAAQ,GAAG,KAAKV,KAAL,CAAWS,OAAX,CAAf;;AAEA,UAAIC,QAAJ,EAAc;AACZ,eAAOA,QAAP;AACD,OAFD,MAEO;AACL,YAAIC,QAAQ,GAAG,KAAKJ,WAAL,CAAiBE,OAAjB,CAAf;;AAEA,YAAIE,QAAJ,EAAc;AACZ,iBAAO,KAAKX,KAAL,CAAWW,QAAX,CAAP;AACD;AACF;AACF;AAdA,GArV0B,EAoW1B;AACD9B,IAAAA,GAAG,EAAE,cADJ;AAEDsB,IAAAA,KAAK,EAAE,SAASiB,YAAT,CAAsBX,OAAtB,EAA+BC,QAA/B,EAAyC;AAC9C,UAAIC,QAAQ,GAAG,KAAKH,oBAAL,CAA0BC,OAA1B,CAAf;AACA,WAAKT,KAAL,CAAWW,QAAX,IAAuBD,QAAvB;;AAEA,WAAKR,OAAL;AACD;AAPA,GApW0B,CAAjB,CAAZ;;AA8WA,SAAON,cAAP;AACD,CA1YD,EAFA;;AA8YA,SAAS8D,eAAT,CAAyBE,aAAzB,EAAwC;AACtC,SAAOjF,MAAM,CAACkB,IAAP,CAAY+D,aAAZ,EAA2BpB,MAA3B,CAAkC,UAAUC,IAAV,EAAgBhC,OAAhB,EAAyB;AAChEpB,IAAAA,eAAe,CAACoB,OAAD,CAAf,CAAyB0B,OAAzB,CAAiC,UAAU0B,aAAV,EAAyB;AACxDvE,MAAAA,wBAAwB,CAACsE,aAAD,CAAxB,CAAwCzB,OAAxC,CAAgD,UAAU2B,aAAV,EAAyB;AACvEA,QAAAA,aAAa,CAACD,aAAD,CAAb,CAA6B1B,OAA7B,CAAqC,UAAUxB,QAAV,EAAoB;AACvD,cAAIA,QAAQ,KAAKF,OAAb,IAAwBA,OAAO,KAAKoD,aAAxC,EAAuD;AACrDpB,YAAAA,IAAI,CAAC9B,QAAD,CAAJ,GAAiBF,OAAjB;AACD;AACF,SAJD;AAKD,OAND;AAOD,KARD;AASA,WAAOgC,IAAP;AACD,GAXM,EAWJ,EAXI,CAAP;AAYD;;AAED,eAAe7C,cAAf","sourcesContent":["function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nimport KeyEventSequenceIndex from '../../const/KeyEventSequenceIndex';\nimport KeyEventType from '../../const/KeyEventType';\nimport KeyCombinationSerializer from '../shared/KeyCombinationSerializer';\nimport resolveKeyAlias from '../../helpers/resolving-handlers/resolveKeyAlias';\nimport applicableAliasFunctions from '../../helpers/resolving-handlers/applicableAliasFunctions';\nimport KeyEventStateArrayManager from '../shared/KeyEventStateArrayManager';\nimport isEmpty from '../../utils/collection/isEmpty';\nimport size from '../../utils/collection/size';\nimport KeyEventState from '../../const/KeyEventState';\nimport dictionaryFrom from '../../utils/object/dictionaryFrom';\n/**\n * Record of one or more keys pressed together, in a combination\n * @class\n */\n\nvar KeyCombination =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Creates a new KeyCombination instance\n   * @param {Object.<ReactKeyName, Array.<KeyEventState[]>>} keys Dictionary\n   *        of keys\n   * @returns {KeyCombination}\n   */\n  function KeyCombination() {\n    var keys = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, KeyCombination);\n\n    this._keys = keys;\n    this._includesKeyUp = false;\n\n    this._update();\n  }\n  /********************************************************************************\n   * Getters\n   *********************************************************************************/\n\n  /**\n   * List of ids (serialized representations) for the keys involved in the combination\n   * @returns {KeySequence[]} List of combination ids\n   */\n\n\n  _createClass(KeyCombination, [{\n    key: \"getIds\",\n    value: function getIds() {\n      return this._ids;\n    }\n    /**\n     * Dictionary mapping keys to their acceptable aliases. This includes \"shifted\" or\n     * \"alted\" key characters.\n     * @returns {Object.<ReactKeyName, ReactKeyName[]>}\n     */\n\n  }, {\n    key: \"getKeyAliases\",\n    value: function getKeyAliases() {\n      return this._keyAliases;\n    }\n    /**\n     * A normalized version of the key, achieved by comparing it to the list of known\n     * aliases for the keys in the combination\n     * @param {ReactKeyName} keyName Name of the key to normalize\n     * @returns {ReactKeyName} Normalized key name\n     */\n\n  }, {\n    key: \"getNormalizedKeyName\",\n    value: function getNormalizedKeyName(keyName) {\n      var keyState = this._keys[keyName];\n\n      if (keyState) {\n        return keyName;\n      } else {\n        var keyAlias = this._keyAliases[keyName];\n\n        if (keyAlias) {\n          return keyAlias;\n        } else {\n          return keyName;\n        }\n      }\n    }\n    /********************************************************************************\n     * Query attributes of entire combination\n     *********************************************************************************/\n\n    /**\n     * Number of keys involved in the combination\n     * @returns {number} Number of keys\n     */\n\n  }, {\n    key: \"getNumberOfKeys\",\n    value: function getNumberOfKeys() {\n      return size(this._keys);\n    }\n    /**\n     * Whether there are any keys in the combination\n     * @returns {boolean} true if there is 1 or more keys involved in the combination,\n     *          else false.\n     */\n\n  }, {\n    key: \"any\",\n    value: function any() {\n      return Object.keys(this._getKeyStates()).length > 0;\n    }\n    /**\n     * Whether any of the keys in the combination have been released\n     * @returns {boolean} true if at least 1 key has been released in the combination\n     */\n\n  }, {\n    key: \"isEnding\",\n    value: function isEnding() {\n      return this._includesKeyUp;\n    }\n    /**\n     * Whether there are any keys in the current combination still being pressed\n     * @returns {boolean} True if all keys in the current combination are released\n     */\n\n  }, {\n    key: \"hasEnded\",\n    value: function hasEnded() {\n      return isEmpty(this.keysStillPressedDict());\n    }\n    /********************************************************************************\n     * Adding & modifying key states\n     *********************************************************************************/\n\n    /**\n     * Add a new key to the combination (starting with a state of keydown)\n     * @param {ReactKeyName} keyName Name of key\n     * @param {KeyEventState} keyEventState State key is in\n     * @returns {void}\n     */\n\n  }, {\n    key: \"addKey\",\n    value: function addKey(keyName, keyEventState) {\n      this._setKeyState(keyName, [KeyEventStateArrayManager.newRecord(), KeyEventStateArrayManager.newRecord(KeyEventType.keydown, keyEventState)]);\n    }\n    /**\n     * Adds a key event to the current key combination (as opposed to starting a new\n     * keyboard combination).\n     * @param {ReactKeyName} keyName - Name of the key to add to the current combination\n     * @param {KeyEventType} recordIndex - Index in record to set to true\n     * @param {KeyEventState} keyEventState The state to set the key event to\n     */\n\n  }, {\n    key: \"setKeyState\",\n    value: function setKeyState(keyName, recordIndex, keyEventState) {\n      var existingRecord = this._getKeyState(keyName);\n\n      if (this.isKeyIncluded(keyName)) {\n        var previous = KeyEventStateArrayManager.clone(existingRecord[1]);\n        var current = KeyEventStateArrayManager.clone(previous);\n        KeyEventStateArrayManager.setBit(current, recordIndex, keyEventState);\n\n        this._setKeyState(keyName, [previous, current]);\n      } else {\n        this.addKey(keyName, keyEventState);\n      }\n\n      if (recordIndex === KeyEventType.keyup) {\n        this._includesKeyUp = true;\n      }\n    }\n    /********************************************************************************\n     * Iteration and subsets\n     *********************************************************************************/\n\n    /**\n     * @callback forEachHandler\n     * @param {ReactKeyName} keyName Name of a key in the combination\n     * @returns {void}\n     */\n\n    /**\n     * Iterates over every key in the combination, calling an function with each\n     * key name\n     * @param {forEachHandler} handler Function to call with the name of each key\n     *        in the combination\n     * @returns {void}\n     */\n\n  }, {\n    key: \"forEachKey\",\n    value: function forEachKey(handler) {\n      return Object.keys(this._keys).forEach(handler);\n    }\n    /**\n     * @callback evaluator\n     * @param {ReactKeyName} keyName Name of a key in the combination\n     * @returns {boolean}\n     */\n\n    /**\n     * Whether at least one of the keys causes a evaluator function to return true\n     * @callback {evaluator} evaluator Function to evaluate each key\n     * @returns {boolean} Whether at least one key satisfies the evaluator\n     */\n\n  }, {\n    key: \"some\",\n    value: function some(evaluator) {\n      return Object.keys(this._keys).some(evaluator);\n    }\n    /**\n     * Dictionary of keys included in the combination record\n     * @returns {Object.<ReactKeyName, boolean>}\n     */\n\n  }, {\n    key: \"getKeyDictionary\",\n    value: function getKeyDictionary() {\n      return dictionaryFrom(Object.keys(this._getKeyStates()), true);\n    }\n    /**\n     * Returns a new KeyCombination without the keys that have been\n     * released (had the keyup event recorded). Essentially, the keys that are\n     * currently still pressed down at the time a key event is being handled.\n     * @returns {KeyCombination} New KeyCombination with all of the\n     *        keys with keyup events omitted\n     */\n\n  }, {\n    key: \"keysStillPressedDict\",\n    value: function keysStillPressedDict() {\n      var _this = this;\n\n      return Object.keys(this._keys).reduce(function (memo, keyName) {\n        if (_this.isKeyStillPressed(keyName)) {\n          memo[keyName] = _this._getKeyState(keyName);\n        }\n\n        return memo;\n      }, {});\n    }\n    /********************************************************************************\n     * Query individual keys\n     *********************************************************************************/\n\n    /**\n     * Whether key is in the combination\n     * @param {ReactKeyName} keyName Name of key\n     * @returns {boolean} true if the key is in the combination\n     */\n\n  }, {\n    key: \"isKeyIncluded\",\n    value: function isKeyIncluded(keyName) {\n      return !!this._getKeyState(keyName);\n    }\n    /**\n     * Whether key is in the combination and has yet to be released\n     * @param {ReactKeyName} keyName Name of key\n     * @returns {boolean} true if the key is in the combination and yet to be released\n     */\n\n  }, {\n    key: \"isKeyStillPressed\",\n    value: function isKeyStillPressed(keyName) {\n      return this.isEventTriggered(keyName, KeyEventType.keypress) && !this.isKeyReleased(keyName);\n    }\n    /**\n     * Whether key is in the combination and been released\n     * @param {ReactKeyName} keyName Name of key\n     * @returns {boolean} true if the key is in the combination and has been released\n     */\n\n  }, {\n    key: \"isKeyReleased\",\n    value: function isKeyReleased(keyName) {\n      return this.isEventTriggered(keyName, KeyEventType.keyup);\n    }\n    /**\n     * Whether an event has been recorded for a key yet\n     * @param {ReactKeyName} keyName Name of the key\n     * @param {KeyEventType} keyEventType Index of the event type\n     * @returns {boolean} true if the event has been recorded for the key\n     */\n\n  }, {\n    key: \"isEventTriggered\",\n    value: function isEventTriggered(keyName, keyEventType) {\n      return this._getKeyStateType(keyName, KeyEventSequenceIndex.current, keyEventType);\n    }\n    /**\n     * Whether an event has been previously recorded for a key (the second most recent\n     * event to occur for the key)\n     * @param {ReactKeyName} keyName Name of the key\n     * @param {KeyEventType} keyEventType Index of the event type\n     * @returns {boolean} true if the event has been previously recorded for the key\n     */\n\n  }, {\n    key: \"wasEventPreviouslyTriggered\",\n    value: function wasEventPreviouslyTriggered(keyName, keyEventType) {\n      return this._getKeyStateType(keyName, KeyEventSequenceIndex.previous, keyEventType);\n    }\n    /**\n     * Whether a keypress event is currently being simulated\n     * @param {ReactKeyName} keyName Name of the key\n     * @returns {boolean} true if the keypress event is currently being simulated for the\n     *        key\n     */\n\n  }, {\n    key: \"isKeyPressSimulated\",\n    value: function isKeyPressSimulated(keyName) {\n      return this._isKeyEventSimulated(keyName, KeyEventType.keypress);\n    }\n    /**\n     * Whether a keyup event is currently being simulated\n     * @param {ReactKeyName} keyName Name of the key\n     * @returns {boolean} true if the keyup event is currently being simulated for the\n     *        key\n     */\n\n  }, {\n    key: \"isKeyUpSimulated\",\n    value: function isKeyUpSimulated(keyName) {\n      return this._isKeyEventSimulated(keyName, KeyEventType.keyup);\n    }\n    /********************************************************************************\n     * Presentation\n     *********************************************************************************/\n\n    /**\n     * Return a serialized description of the keys in the combination\n     * @returns {KeySequence}\n     */\n\n  }, {\n    key: \"describe\",\n    value: function describe() {\n      return this.getIds()[0];\n    }\n    /**\n     * A plain JavaScript representation of the key combination record, useful for\n     * serialization or debugging\n     * @returns {Object} Serialized representation of the combination record\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        keys: this._getKeyStates(),\n        ids: this.getIds(),\n        keyAliases: this.getKeyAliases()\n      };\n    }\n    /********************************************************************************\n     * Private methods\n     *********************************************************************************/\n\n  }, {\n    key: \"_getKeyStateType\",\n    value: function _getKeyStateType(keyName, keyStage, keyEventType) {\n      var keyState = this._getKeyState(keyName);\n\n      return keyState && keyState[keyStage][keyEventType];\n    }\n  }, {\n    key: \"_update\",\n    value: function _update() {\n      this._ids = KeyCombinationSerializer.serialize(this._keys);\n      this._keyAliases = buildKeyAliases(this._keys);\n    }\n  }, {\n    key: \"_isKeyEventSimulated\",\n    value: function _isKeyEventSimulated(keyName, keyEventType) {\n      return this.isEventTriggered(keyName, keyEventType) === KeyEventState.simulated;\n    }\n  }, {\n    key: \"_getKeyStates\",\n    value: function _getKeyStates() {\n      return this._keys;\n    }\n  }, {\n    key: \"_getKeyState\",\n    value: function _getKeyState(keyName) {\n      var keyState = this._keys[keyName];\n\n      if (keyState) {\n        return keyState;\n      } else {\n        var keyAlias = this._keyAliases[keyName];\n\n        if (keyAlias) {\n          return this._keys[keyAlias];\n        }\n      }\n    }\n  }, {\n    key: \"_setKeyState\",\n    value: function _setKeyState(keyName, keyState) {\n      var keyAlias = this.getNormalizedKeyName(keyName);\n      this._keys[keyAlias] = keyState;\n\n      this._update();\n    }\n  }]);\n\n  return KeyCombination;\n}();\n\nfunction buildKeyAliases(keyDictionary) {\n  return Object.keys(keyDictionary).reduce(function (memo, keyName) {\n    resolveKeyAlias(keyName).forEach(function (normalizedKey) {\n      applicableAliasFunctions(keyDictionary).forEach(function (aliasFunction) {\n        aliasFunction(normalizedKey).forEach(function (keyAlias) {\n          if (keyAlias !== keyName || keyName !== normalizedKey) {\n            memo[keyAlias] = keyName;\n          }\n        });\n      });\n    });\n    return memo;\n  }, {});\n}\n\nexport default KeyCombination;"]},"metadata":{},"sourceType":"module"}